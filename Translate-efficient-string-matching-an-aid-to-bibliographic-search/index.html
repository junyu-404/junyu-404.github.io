<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-fish.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-fish.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-fish.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fish-404.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="原文地址：Efficient String Matching - An Aid to Bibliographic Search 作者 Alfred V. Aho，Margaret J. Corasick 贝尔实验室 本文为个人毕业设计外文参考文献翻译部分，有不当之处欢迎指正。 文章主要论述了 AC 自动算法的原理，函数构建，性能。（伪代码部分由于未能找到在代码块中插入数学符号的方式，故采">
<meta property="og:type" content="article">
<meta property="og:title" content="翻译-高效的字符串匹配：辅助参考书目检索">
<meta property="og:url" content="https://fish-404.github.io/Translate-efficient-string-matching-an-aid-to-bibliographic-search/index.html">
<meta property="og:site_name" content="在逃的貓">
<meta property="og:description" content="原文地址：Efficient String Matching - An Aid to Bibliographic Search 作者 Alfred V. Aho，Margaret J. Corasick 贝尔实验室 本文为个人毕业设计外文参考文献翻译部分，有不当之处欢迎指正。 文章主要论述了 AC 自动算法的原理，函数构建，性能。（伪代码部分由于未能找到在代码块中插入数学符号的方式，故采">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/06/10/QgEY7y2BbcUd9pm.png">
<meta property="og:image" content="https://i.loli.net/2020/06/12/LkejgAN8c6WV7il.png">
<meta property="og:image" content="https://i.loli.net/2020/06/10/6SZBLcHPk1j2gIK.png">
<meta property="og:image" content="https://i.loli.net/2020/06/10/uDa9p7P5fiWXjQJ.png">
<meta property="og:image" content="https://i.loli.net/2020/06/10/TZxzdrIf1895PQH.png">
<meta property="og:image" content="https://i.loli.net/2020/06/10/AUm7QOHfPsTFWlq.png">
<meta property="og:image" content="https://i.loli.net/2020/06/11/dzRUHEXoTBvW9Lw.png">
<meta property="og:image" content="https://i.loli.net/2020/06/11/Eors8MIag4S5TZe.png">
<meta property="og:image" content="https://i.loli.net/2020/06/11/oByixRQCLEvWbZm.png">
<meta property="og:image" content="https://i.loli.net/2020/06/11/xuDSKyivF8nagWX.png">
<meta property="article:published_time" content="2020-06-07T16:00:00.000Z">
<meta property="article:modified_time" content="2020-06-12T10:04:38.000Z">
<meta property="article:author" content="Fish__404">
<meta property="article:tag" content="Translate">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/06/10/QgEY7y2BbcUd9pm.png">


<link rel="canonical" href="https://fish-404.github.io/Translate-efficient-string-matching-an-aid-to-bibliographic-search/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://fish-404.github.io/Translate-efficient-string-matching-an-aid-to-bibliographic-search/","path":"Translate-efficient-string-matching-an-aid-to-bibliographic-search/","title":"翻译-高效的字符串匹配：辅助参考书目检索"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>翻译-高效的字符串匹配：辅助参考书目检索 | 在逃的貓</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">在逃的貓</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">A cat called fish.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fab fa-fort-awesome fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-question fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-list fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-inbox fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%9C%BA"><span class="nav-number">2.</span> <span class="nav-text">模式匹配机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E8%B7%B3%E8%BD%AC%E5%A4%B1%E8%B4%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">构造跳转，失败，输出函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95123%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">4.</span> <span class="nav-text">算法1，2，3的性质</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95123%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">5.</span> <span class="nav-text">算法1，2，3的时间复杂度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E9%99%A4%E5%A4%B1%E8%B4%A5%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.</span> <span class="nav-text">消除失败转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E5%8F%82%E8%80%83%E4%B9%A6%E7%9B%AE%E6%A3%80%E7%B4%A2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">在参考书目检索中的应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="nav-number">8.</span> <span class="nav-text">结束语</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%B4%E8%B0%A2"><span class="nav-number">9.</span> <span class="nav-text">致谢</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">10.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fish__404"
      src="/images/cat.jpg">
  <p class="site-author-name" itemprop="name">Fish__404</p>
  <div class="site-description" itemprop="description">What's dream? Just fun!</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button site-overview-item animated">
    <button><i class="fa fa-comment"></i>
      留言
    </button>
  </div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/fish-404" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fish-404" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fish404hsif@gmail.com" title="E-Mail → mailto:fish404hsif@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fish-404.github.io/Translate-efficient-string-matching-an-aid-to-bibliographic-search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.jpg">
      <meta itemprop="name" content="Fish__404">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="在逃的貓">
      <meta itemprop="description" content="What's dream? Just fun!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="翻译-高效的字符串匹配：辅助参考书目检索 | 在逃的貓">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          翻译-高效的字符串匹配：辅助参考书目检索
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020/06/08 0:00:00" itemprop="dateCreated datePublished" datetime="2020-06-08T00:00:00+08:00">2020/06/08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020/06/12 18:04:38" itemprop="dateModified" datetime="2020-06-12T18:04:38+08:00">2020/06/12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>原文地址：<a
target="_blank" rel="noopener" href="https://dl.acm.org/doi/epdf/10.1145/360825.360855">Efficient
String Matching - An Aid to Bibliographic Search</a></p>
<p>作者 Alfred V. Aho，Margaret J. Corasick 贝尔实验室</p>
<p>本文为个人毕业设计外文参考文献翻译部分，有不当之处欢迎指正。</p>
<p>文章主要论述了 AC
自动算法的原理，函数构建，性能。（伪代码部分由于未能找到在代码块中插入数学符号的方式，故采用图片方式，若有相关方法，期待评论告知。）</p>
<span id="more"></span>
<p>本文描述了一种简单高效的算法，用于在文本字符串中找出任一有限字符数的关键词所有出现位置。这种算法通过关键词构建一个有限状态模式匹配机，然后通过这个模式匹配机在一趟遍历中处理单词输入的文本字符串。构建此模式匹配机的时间与关键字的长度之和成正比。通过模式状态匹配机处理文本字符串的状态转换次数与关键字的长度无关。这个算法已经将图书馆的参考书目搜索程序运行速度提升了
5 到 10 倍。</p>
<p><strong>关键词</strong>：关键字和短语，字符串模式匹配，参考书目检索，信息检索，文本编辑，有限状态机，计算复杂度</p>
<p>CR类别：3.74,3.71,5.22,5.25</p>
<h1 id="简介">简介</h1>
<p>在许多信息检索和文字编辑的应用程序中，能够在文本中快速定位用户指定的词或短语某些或者所有出现的位置是非常重要的。本文介绍了一种简单高效的算法，用于在任意的文本字符串中找出任一有限字符数的关键词或短语所有出现位置。</p>
<p>熟知有限自动机的人应该熟悉这种方法。这个算法由两部分组成。在第一部分中我们从关键词字符集中构造有限状态模式匹配机；在第二部分中我们将字符串作为模式匹配机的输入。只要这个机器已发现一个匹配的关键词，它就会发出信号。</p>
<p>在模式匹配程序中使用有限状态机并不新奇
[4,8,17]，但程序员们似乎常常回避使用它们。部分程序员不愿意这样做的部分原因可能是因为从正则表达式
[3,10,15] 构建有限自动机的常规算法的复杂性，尤其是在需要最优解的情况下
[2,14]
。本文表明，从受限的正则表达式，也即由有限集合组成的关键词，可以快速而简单地构建一个高效的有限状态模式匹配机。我们的方法将有限状态机与
KMP 算法 [13] 相结合。</p>
<p>也许本文最有趣的地方在于有限状态算法提供了比常规方法更多的改进。我们在一个图书馆的参考书目查询程序中使用有限状态模式匹配算法。这个程序的目的是，让书目编者在引文索引中找到所有满足布尔匹配的关键词和短语的标题。这个查询程序开始是使用一种直接的字符串匹配算法。在该程序中使用有限状态算法来替代这个算法后，在典型输入上，运行时间为原程序的五到十分之一。</p>
<h1 id="模式匹配机">模式匹配机</h1>
<p>本节描述了一种在文本字符串中定位关键词的有限状态字符串模式匹配机。下一节将描述从一个给定的有限关键字集合中构建类似机器的算法。</p>
<p>在本文中，字符串只是简单地表示为一个有限符号序列。设 <span
class="math inline">\(K={y_1,y_2,\dots,y_k}\)</span>
是一个有限字符串集合，我们称之为关键字，设 <span
class="math inline">\(x\)</span>
为任意字符串，我们称之为文本字符串。我们的问题是找出有限的所有x的子字符串中在K集合中的关键词。子字符串可能彼此重叠。</p>
<p>用于K的模式匹配机是一个程序，它将文本字符串 <span
class="math inline">\(x\)</span> 作为输入，关键字 <span
class="math inline">\(K\)</span> 在 <span
class="math inline">\(x\)</span>
的子字符串中的出现的位置作为输出。这种模式匹配机由一个状态集组成。每种状态都用一个数字表示。这种机器通过连续读取
<span class="math inline">\(x\)</span> 中的字符来处理文本字符串 <span
class="math inline">\(x\)</span>
，产生状态转换，或是状态输出。这种状态机的行为由三个函数决定：一个跳转函数
<span class="math inline">\(g\)</span> ，一个失败处理函数 <span
class="math inline">\(f\)</span> ，以及一个输出函数 <span
class="math inline">\(output\)</span> 。</p>
<p>图1展示了函数在模式匹配状态机针对关键字集 {he, she, his, hers}
时的使用情况。</p>
<figure>
<img
src="https://d3i71xaburhd42.cloudfront.net/3547ac839d02f6efe3f6f76a8289738a22528442/2-Figure1-1.png"
alt="图1 模式匹配机" />
<figcaption aria-hidden="true">图1 模式匹配机</figcaption>
</figure>
<p>一种状态（通常是 0 状态）被指定 <span
class="math inline">\(start\)</span> 状态。在图1中状态表示为
0,1,···,9。跳转函数 <span class="math inline">\(g\)</span>
将一种状态和一个输入字符组成一对映射为一种状态或 <span
class="math inline">\(fail\)</span> 信息。图1(a)
的有向图表示跳转函数。例如，从 0 到 1 标有 h 的边表示 <span
class="math inline">\(g(0,h) = 1\)</span> 。没有箭头表示<span
class="math inline">\(fail\)</span>。因此，对于所有不是 e 或者 i
的输入字符 <span class="math inline">\(\delta\)</span> ， <span
class="math inline">\(g(1,\delta)=fail\)</span>
。我们的模式匹配机具有对所有的输入字符 <span
class="math inline">\(\delta\)</span> ， <span
class="math inline">\(g(0,\delta)\ne fail\)</span>
的特性。我们将看到跳转函数在 0
状态的这个特性确保在每一个机器周期机器都将处理一个输入字符。</p>
<p>失败处理函数f将一个状态映射到另一个状态。当跳转函数返回 <span
class="math inline">\(fail\)</span>
时失败函数将被调用。当一组关键字被找到时，某些状态将被指定为输出状态。输出函数将一组关键字（可能为空）与每个状态组合将此形式化。</p>
<p>模式匹配机的一个操作周期定义如下：设 <span
class="math inline">\(s\)</span> 表示机器的当前状态， <span
class="math inline">\(a\)</span> 表示输入字符串 <span
class="math inline">\(x\)</span> 中的当前字符。</p>
<ol type="1">
<li><p>如果 <span class="math inline">\(g(s, a) =
s’\)</span>，状态机执行跳转转换，进入状态 <span
class="math inline">\(s’\)</span> ，并将 <span
class="math inline">\(x\)</span>
的下一个字符作为当前输入字符。此外，如果 <span
class="math inline">\(output(s’)\)</span> 不为空，则机器输出 <span
class="math inline">\(output(s’)\)</span>
集合和当前输入字符的位置。这个操作周期现在已完成。</p></li>
<li><p>如果 <span class="math inline">\(g(s,a) = fail\)</span>
，状态机调用失败函数 <span class="math inline">\(f\)</span>
，也就是执行了失败转换。如果 <span class="math inline">\(f(s) =
s’\)</span> ，状态机重复以 <span class="math inline">\(s’\)</span>
作为当前状态，以 <span class="math inline">\(a\)</span>
作为当前输入字符的循环。</p></li>
</ol>
<p>最初，状态机的当前状态为开始状态，文本字符串的第一个字符作为当前输入字符。状态机随后通过对每一个文本字符串的字符执行一个操作周期来处理文本字符串。</p>
<p>例如，考虑状态机 <span class="math inline">\(M\)</span> 使用图1
中的函数处理文本字符串 “ushers” 的行为。图2表明了 <span
class="math inline">\(M\)</span> 处理文本字符串的状态转换关系。</p>
<p><img src="https://i.loli.net/2020/06/10/QgEY7y2BbcUd9pm.png"
alt="状态转化队列" /> 考虑这样一个操作周期， <span
class="math inline">\(M\)</span> 处在状态 4，当前输入字符为 e 。因为
<span class="math inline">\(g(4,e) = 5\)</span> ，状态机进入状态
5，前移到下一个输入字符，并输出 <span
class="math inline">\(output(5)\)</span>
，表明状态机已经发现了在文本字符串的倒数4个位置是关键词 “she” 和 “he”
。</p>
<p>在状态 5输入字符 r，状态机在它的操作周期中执行两次状态转换。因为
<span class="math inline">\(g(5,r) = fail\)</span> ， <span
class="math inline">\(M\)</span> 进入状态 <span class="math inline">\(2
= f(5)\)</span> 。然后因为<span class="math inline">\(g(2,r) =
8\)</span>，<span class="math inline">\(M\)</span> 进入状态
8，接着前移一个输入字符。在这个操作周期中没有产生输出。</p>
<p>以下算法总结了模式匹配机的行为。</p>
<p><strong>算法1</strong> 模式匹配机</p>
<p><strong>输入</strong> 一个文本字符串 <span class="math inline">\(x =
a_1a_2 \dots a_n\)</span> ,每一个 <span
class="math inline">\(a_i\)</span> 作为一个输入字符，模式匹配机 <span
class="math inline">\(M\)</span> 包含跳转函数 <span
class="math inline">\(g\)</span>，失败函数 <span
class="math inline">\(f\)</span>，以及输出函数 <span
class="math inline">\(output\)</span>，如上所述</p>
<p><strong>输出</strong> 关键词在<span
class="math inline">\(x\)</span>中的位置</p>
<p><strong>方法</strong></p>
<figure>
<img src="https://i.loli.net/2020/06/12/LkejgAN8c6WV7il.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>每一趟<strong>for</strong>循环都代表状态机的一个操作周期。</p>
<p>算法1是在 KMP 算法的基础上模式化得到的，KMP
算法用于在一个文本字符串中查找一个关键字 [13]，也可以看作是 [11]
中讨论的 “trie”
搜索方法的扩展。Hopcroft和Karp（当时未发表）提出一种类似于算法1的模式，用于在文本字符串中查找任一有限关键字集合第一次出现的位置
[13]。本文的第6节探讨了一种算法1的有限自动机版本，它避免了所有的失败转换。</p>
<h1 id="构造跳转失败输出函数">构造跳转，失败，输出函数</h1>
<p>我们说，当 <span class="math inline">\(g,f,output\)</span>
三个函数应用于一组关键字，算法1表现为，关键字 <span
class="math inline">\(y\)</span> 在文本字符串 <span
class="math inline">\(x\)</span> 的第 <span
class="math inline">\(i\)</span> 个位置中止，当且仅当 <span
class="math inline">\(x= uyv\)</span> 并且<span
class="math inline">\(uy\)</span>的长度为 <span
class="math inline">\(i\)</span>。</p>
<p>现在我们应该展示如何从一个关键字集构建有效的跳转，失败和输出函数。构建分为两部分。第一部分我们定义状态和跳转函数。第二部分我们计算失败函数。输出函数的计算则在第一部分开始构建，在第二部分完成。</p>
<p>为了构建跳转函数，我们应该构建一个跳转图。我们从一个表示状态 0
的顶点开始这幅图。然后我们通过往图中添加一条从开始状态引出的有向路径将关键字
<span class="math inline">\(y\)</span>
添加到图中。这样就会有新的顶点和边被添加到图中，从开始状态开始，一条路径拼出关键字
<span class="math inline">\(y\)</span>。当一个状态终结了这条路径，关键字
<span class="math inline">\(y\)</span>
将被添加到输出函数中。我们仅在必要时才往图中添加新的边。</p>
<p>例如，设 {he,she,his,hers}
是关键字集。将第一个关键字添加到图中，我们得到：</p>
<figure>
<img src="https://i.loli.net/2020/06/10/6SZBLcHPk1j2gIK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从0到2的路径拼出了关键字 “he”;我们将输出 “he”
关联到状态2.添加第二个关键字 “she”，我们得到图：</p>
<figure>
<img src="https://i.loli.net/2020/06/10/uDa9p7P5fiWXjQJ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>输出 “she” 被关联到状态 5。添加关键字
“his”，我们得到下面的图。注意到，当我们添加关键字 “his” 时，已经有从状态
0 到状态 1 标号为 “h” 的边，所以我们不需要添加另一条从状态 0 到状态 1
标号为 “h” 的边。输出 “his” 被关联到状态 7。</p>
<figure>
<img src="https://i.loli.net/2020/06/10/TZxzdrIf1895PQH.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>添加最后一个关键字 “hers”，我们得到：</p>
<figure>
<img src="https://i.loli.net/2020/06/10/AUm7QOHfPsTFWlq.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>输出 “hers” 被关联到状态 9。这时我们可以使用已经存在的从状态 0 到状态
1 标号为 “h” 的边和从状态 1 到状态 2 标号为 “e” 的边。</p>
<p>到目前为止，这幅图是一棵有根的有向树。为了完成跳转函数的构建，我们为所有不是
“h” 或 “s” 的输入字符添加一个从状态 0 到状态 0
的循环。我们得到了一个如图1（a）所示的有向图。这幅图表示跳转函数。</p>
<p>失败函数从跳转函数构建。不妨设状态<span
class="math inline">\(s\)</span>的深度为在跳转图中从开始状态到 <span
class="math inline">\(s\)</span>
的最短路径。这样在图1（a）中，开始状态的深度为
0，状态1和状态3深度为1，状态2，4，6深度为2，以此类推。</p>
<p>我们应该计算失败函数中所有深度为 1 的状态，所有深度为 2
的状态，以此类推，直到失败函数计算了所有的状态（除了在失败函数中未定义的状态
0）。这个算法从理论上通过状态来计算失败函数 <span
class="math inline">\(f\)</span> 非常简单。我们令所有深度为1的状态 <span
class="math inline">\(f(s)=0\)</span>。现在假设所有深度小于 <span
class="math inline">\(d\)</span> 的状态的 <span
class="math inline">\(f\)</span> 都已被计算，深度为<span
class="math inline">\(d\)</span>的状态的失败函数值将从深度小于 <span
class="math inline">\(d\)</span> 的状态的失败函数值来计算。深度为 <span
class="math inline">\(d\)</span> 的状态可以从深度为 <span
class="math inline">\(d-1\)</span> 的状态的跳转函数定义。</p>
<p>特别地，为了计算深度为 <span class="math inline">\(d\)</span>
的状态的失败函数，我们考虑深度为 <span
class="math inline">\(d-1\)</span> 的每个状态<span
class="math inline">\(r\)</span>，按照如下步骤进行:</p>
<ol type="1">
<li><p>如果对所有 <span class="math inline">\(a\)</span>，<span
class="math inline">\(g(r,a) = fail\)</span>，不执行任何操作</p></li>
<li><p>否则，对于每个字符 <span class="math inline">\(a\)</span>，<span
class="math inline">\(g(r,a) = s\)</span>，执行如下操作：</p>
<ol type="a">
<li><p>令 <span class="math inline">\(state = f(r)\)</span></p></li>
<li><p>执行语句 <span class="math inline">\(state\leftarrow
f(state)\)</span> 零至多次，直到有一个状态的值满足 <span
class="math inline">\(g(state,a)\ne
fail\)</span>。（注意因为对于所有的输入 <span
class="math inline">\(a\)</span>，<span class="math inline">\(g(0,a)\ne
fail\)</span>，因此满足条件的状态总是可以找到。）</p></li>
<li><p>令 <span class="math inline">\(f(s) =
g(state,a)\)</span></p></li>
</ol></li>
</ol>
<p>例如，为了计算图1（a）中的失败函数，我们将首先令 <span
class="math inline">\(f(1) = f(3) =
0\)</span>，因为状态1和3的的深度为1。之后我们来计算深度为2
的状态2，6，4。为了计算<span class="math inline">\(f(2)\)</span>，我们令
<span class="math inline">\(state=f(1) = 0\)</span>;接着因为 <span
class="math inline">\(g(0,e) = 0\)</span>，我们得到 <span
class="math inline">\(f(2) = 0\)</span>。为了计算 <span
class="math inline">\(f(6)\)</span>，我们令 <span
class="math inline">\(state = f(1) = 0\)</span>；而因为 <span
class="math inline">\(g(0,i) = 0\)</span>，我们得到 <span
class="math inline">\(f(6) = 0\)</span>。为了计算 <span
class="math inline">\(f(4)\)</span>，我们令 <span
class="math inline">\(state = f(3) = 0\)</span>；又因为 <span
class="math inline">\(g(0,h) = 1\)</span>，我们得到 <span
class="math inline">\(f(4) =
1\)</span>。继续这个方法，我们得到图1(b)中所示的失败函数表。</p>
<p>在计算失败函数时，我们同时更新输出函数。当我们确认 <span
class="math inline">\(f(s) = s’\)</span> 时，我们将状态 <span
class="math inline">\(s\)</span> 的输出与状态 <span
class="math inline">\(s’\)</span> 的输出归并。</p>
<p>例如，在图1(a)中我们定义 <span class="math inline">\(f(5) =
2\)</span>。此时我们归并状态2的输出集，也即
{he}，加上状态5的输出及得到新的输出集
{he,she}。最后非空的输出及如图1(c)所示。</p>
<p>这个从<span
class="math inline">\(K\)</span>集合构建了跳转，失败和输出函数的算法小结如下。</p>
<p><strong>算法2</strong> 跳转函数构建</p>
<p><strong>输入</strong> 关键字集<span
class="math inline">\(K={y_1,y_2,\dots,y_k}\)</span></p>
<p><strong>输出</strong> 跳转函数 <span class="math inline">\(g\)</span>
和部分输出函数的计算值</p>
<p><strong>方法</strong> 我们假设当状态 <span
class="math inline">\(s\)</span> 开始被创建时 <span
class="math inline">\(output(s)\)</span> 为空，以及当 <span
class="math inline">\(a\)</span> 未定义或 <span
class="math inline">\(g(s,a)\)</span> 尚未被定义时，<span
class="math inline">\(g(s,a) = fail\)</span>。过程 <span
class="math inline">\(enter(y)\)</span> 往跳转图中插入一条拼写为 <span
class="math inline">\(y\)</span> 的路径。</p>
<p>上面的算法，内循环与算法1类似，计算失败函数值。</p>
<figure>
<img src="https://i.loli.net/2020/06/11/dzRUHEXoTBvW9Lw.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><strong>算法3</strong> 构建失败函数。</p>
<p><strong>输入</strong> 算法2中的跳转函数 <span
class="math inline">\(g\)</span> 和输出函数 <span
class="math inline">\(output\)</span>。</p>
<p><strong>输出</strong> 失败函数 <span class="math inline">\(f\)</span>
和输出函数 <span class="math inline">\(output\)</span>。</p>
<p><strong>方法</strong></p>
<figure>
<img src="https://i.loli.net/2020/06/11/Eors8MIag4S5TZe.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>第一个 <strong>for</strong>
循环计算深度为1的状态并将它们记录在一个先入先出的可变队列表示的表中。
<strong>while</strong> 主循环从深度为 <span
class="math inline">\(d-1\)</span> 的状态集中计算深度为 <span
class="math inline">\(d\)</span> 的状态集。</p>
<p>算法3所产生的失败函数值在下面的情况下可能并非最佳。考虑图1中的模式匹配机
<span class="math inline">\(M\)</span> ，我们看到 <span
class="math inline">\(g(4,e) = 5\)</span>。如果 <span
class="math inline">\(M\)</span> 在状态4并且当前输入字符 <span
class="math inline">\(a_i\)</span> 不是 e，那么 <span
class="math inline">\(M\)</span> 将进入状态 <span
class="math inline">\(f(4) = 1\)</span>。因为 <span
class="math inline">\(M\)</span> 已经认定 <span
class="math inline">\(a_i\ne e\)</span>，于是 <span
class="math inline">\(M\)</span> 无需考虑跳转函数在输入为 e
时状态1的值。实际上，如果关键字 “his” 不存在，<span
class="math inline">\(M\)</span>
将直接从状态4到状态0，跳过一个并非必要的中间转换状态1。</p>
<p>为了避免不必要的失败转换我们可以使用 <span
class="math inline">\(f’\)</span> 概括[13]中的下一个函数取代算法1中的
<span class="math inline">\(f\)</span>。特别地，令 <span
class="math inline">\(f’(1)=0\)</span>。对于 <span
class="math inline">\(i\)</span> 大于1的情况，定义 <span
class="math inline">\(f’(i) = f’(f(i))\)</span>，因此对于所有的输入字符
<span class="math inline">\(a\)</span>，<span
class="math inline">\(g(f(i),a)\ne fail\)</span> 即 <span
class="math inline">\(g(i,a)\ne fail\)</span>；否则令 <span
class="math inline">\(f’(i) =
f(i)\)</span>。但是，为了避免任何失败转换，我们可以使用第6节介绍的算法1的确定有限自动机版本。</p>
<h1 id="算法123的性质">算法1，2，3的性质</h1>
<p>本节证明从一个给定的关键字集合 <span class="math inline">\(K\)</span>
同通过算法2和算法3来构建跳转函数，失败函数和输出函数确实有效。</p>
<p>我们设字符串 <span class="math inline">\(uv\)</span> 的 <span
class="math inline">\(u\)</span> 为前缀，<span
class="math inline">\(v\)</span> 为后缀。如果 <span
class="math inline">\(u\)</span> 不是一个空字符串，那么 <span
class="math inline">\(u\)</span> 是一个合法的前缀，同样地，如果 <span
class="math inline">\(v\)</span> 非空，那么 <span
class="math inline">\(v\)</span> 是一个合法的后缀。</p>
<p>我们设字符串 <span class="math inline">\(u\)</span>
表示在模式匹配机中的跳转图中从开始状态到状态<span
class="math inline">\(s\)</span>的最短路径所拼出的字符。开始状态用空字符串表示。</p>
<p>我们的第一个引理表示通过算法3构建的失败函数。</p>
<p>引理1 <em>假定跳转图中状态 <span class="math inline">\(s\)</span>
由字符串 <span class="math inline">\(u\)</span> 表示，而状态 <span
class="math inline">\(t\)</span> 由字符串 <span
class="math inline">\(v\)</span> 表示。那么，<span
class="math inline">\(f(s)=t\)</span> 当且仅当 <span
class="math inline">\(v\)</span> 是 <span
class="math inline">\(u\)</span>
的最长合法后缀，是某个关键词的前缀。</em></p>
<p>证明 证明通过对 <span class="math inline">\(u\)</span>
的长度（或者也可以说状态<span
class="math inline">\(s\)</span>的深度）进行归纳法达成。在算法3中，<span
class="math inline">\(f(s)=0\)</span>
的所有状态深度为1。既然每个深度为1的状态都由一个长度为1的字符串所代表，引理对所有的长度为1的字符串成立。</p>
<p>归纳的下一步，假设引理1的叙述对所有长度小于 <span
class="math inline">\(j(j&gt;1)\)</span> 的字符串为真，令 <span
class="math inline">\(u=a_1a_2\dots a_j\)</span> ,对于部分大于1的 <span
class="math inline">\(j\)</span>，<span class="math inline">\(v\)</span>
是 <span class="math inline">\(u\)</span>
最长的合法后缀，是一些关键字的前缀。假设<span
class="math inline">\(u\)</span>代表状态 <span
class="math inline">\(s\)</span> 而 <span class="math inline">\(a_1
a_2\dots a_{j-1}\)</span> 代表状态 <span
class="math inline">\(r\)</span>。状态队列 <span
class="math inline">\(r_1，r_2，\dots，r_n\)</span> 会像是：</p>
<ol type="1">
<li><p><span class="math inline">\(r_1 = f(r)\)</span></p></li>
<li><p><span class="math inline">\(r_{i+1} = f(r_i)(1\le
i＜n)\)</span></p></li>
<li><p><span class="math inline">\(g(r_i,a_j) = fail(1\le
i＜n)\)</span></p></li>
<li><p><span class="math inline">\(g(r_n,a_j) = t \ne
fail\)</span></p></li>
</ol>
<p>(如果 <span class="math inline">\(g(r_1,a_j)\ne fail\)</span>，那么
<span class="math inline">\(r_n = r_1\)</span>。)队列 <span
class="math inline">\(r_1,r_2,\dots,r_n\)</span> 是算法3中的
<strong>while</strong>
内循环的可变状态的假设值队列。<strong>while</strong> 循环的上述描述使得
<span class="math inline">\(f(s) = t\)</span>。我们定义 <span
class="math inline">\(t\)</span> 由 <span
class="math inline">\(u\)</span>
的最长合法后缀表示，同时也是一些关键字的前缀。</p>
<p>为了证明这点，假设 <span class="math inline">\(v_i\)</span> 表示状态
<span class="math inline">\(r_i(1\ne i\ne
n)\)</span>。通过归纳假设，<span class="math inline">\(v_1\)</span> 是
<span class="math inline">\(a_1 a_2 \dots a_{j-1}\)</span>
的最长后缀，是某些关键字的前缀；<span class="math inline">\(v_2\)</span>
是 <span class="math inline">\(v_1\)</span>
的最长后缀，是某些关键词的前缀；<span
class="math inline">\(v_3\)</span>是<span
class="math inline">\(v_2\)</span>的最长后缀，是某些关键词的后缀，以此类推。</p>
<p>现在 <span class="math inline">\(v_n\)</span> 是 <span
class="math inline">\(a_1a_2\dots a_{j-1}\)</span> 的最长合法后缀，<span
class="math inline">\(v_na_j\)</span> 是一些关键字的前缀。因此 <span
class="math inline">\(v_na_j\)</span> 是 <span
class="math inline">\(u\)</span>
的最长后缀，同时是也些关键字的前缀。根据算法3有 <span
class="math inline">\(f(s)=g(r_n,a_j)=t\)</span> ，证毕。</p>
<p>下一条引理证明通过算法2和算法3构建的输出函数。</p>
<p>引理2 <em><span class="math inline">\(output(s)\)</span>
集合有且仅有包含一个关键字，同时也是代表状态<span
class="math inline">\(s\)</span>的后缀字符串。</em></p>
<p>证明 在算法2中无论我们何时向跳转图中添加一个状态 <span
class="math inline">\(s\)</span> ，它都由我们通过 <span
class="math inline">\(output(s)={y}\)</span> 得到的关键字 <span
class="math inline">\(y\)</span>
表示。给定这个初值，我们可以演示关于状态 <span
class="math inline">\(s\)</span> 的深度的推演，<span
class="math inline">\(output(s)
={y|y\text{是一个表示状态}s\text{的后缀字符串关键字}}\)</span>。</p>
<p>这个描述对于深度为0的开始状态是绝对正确的。假定这个叙述对于所有深度小于
<span class="math inline">\(d\)</span> 的状态为真，考虑深度为 <span
class="math inline">\(d\)</span> 的状态 <span
class="math inline">\(s\)</span>。我们用字符串 <span
class="math inline">\(u\)</span> 代表状态 <span
class="math inline">\(s\)</span>。</p>
<p>考虑在 <span class="math inline">\(output(s)\)</span> 中的一个字符串
<span class="math inline">\(y\)</span>。如果 <span
class="math inline">\(y\)</span> 是通过算法2添加到 <span
class="math inline">\(output(s)\)</span> 中的，那么 <span
class="math inline">\(y=u\)</span>，且 <span
class="math inline">\(y\)</span> 是一个关键字。如果 <span
class="math inline">\(y\)</span> 是通过算法2添加到 <span
class="math inline">\(output(s)\)</span> 中的，那么 <span
class="math inline">\(y\)</span> 在 <span
class="math inline">\(output(f(s))\)</span>中。通过归纳假设，<span
class="math inline">\(y\)</span> 是一个关键字，同时是一个代表状态 <span
class="math inline">\(f(s)\)</span>
的字符串的后缀。根据引理1，任一这样的关键字必须有一个 <span
class="math inline">\(u\)</span> 的后缀。</p>
<p>反过来，假设 <span class="math inline">\(y\)</span>
是任一关键字，同时是 <span class="math inline">\(u\)</span> 的后缀。因为
<span class="math inline">\(y\)</span> 是一个关键字，又状态 <span
class="math inline">\(t\)</span> 由 <span
class="math inline">\(y\)</span> 表示，根据算法2，<span
class="math inline">\(output(t)\)</span> 包含 <span
class="math inline">\(y\)</span>。因此如果 <span
class="math inline">\(y=u\)</span>，那么 <span
class="math inline">\(s=t\)</span> 并且 <span
class="math inline">\(output(t)\)</span> 中包含<span
class="math inline">\(y\)</span>。如果 <span
class="math inline">\(y\)</span> 是 <span
class="math inline">\(u\)</span>
的一个合法后缀，那么从归纳假设和引理1我们知道 <span
class="math inline">\(output(f(s))\)</span> 包含 <span
class="math inline">\(y\)</span>。因为算法3从增长的深度来考虑状态，算法3的最后一条语句添加
<span class="math inline">\(output(f(s))\)</span>，因此 <span
class="math inline">\(y\)</span> 在 <span
class="math inline">\(output(s)\)</span> 中。</p>
<p>下面这条引理表示算法1在一个文本字符串 <span
class="math inline">\(x=a_1a_2\dots a_n\)</span> 上的行为。</p>
<p>引理3 <em>在第 <span class="math inline">\(j\)</span>
个操作周期之后，当且仅当表示 <span class="math inline">\(s\)</span> 的
<span class="math inline">\(a_1a_2\dots a_j\)</span>
最长后缀是某个关键词的前缀时，算法1会处在 <span
class="math inline">\(s\)</span> 状态。</em></p>
<p>证明 和引理1类似。</p>
<p>定理1 <em>算法2和算法3产生有效的跳转，失败，和输出函数。</em></p>
<p>证明 通过引理2和引理3。</p>
<h1 id="算法123的时间复杂度">算法1，2，3的时间复杂度</h1>
<p>现在我们考查算法1，2，3的时间复杂度。我们会证明使用通过算法2和算法3创建的跳转，失败和输出函数，在处理一个文本字符串时，由算法1导出的状态转化数量与关键字数量无关。我们还将证明算法2和算法3在处理时间上可以达到与
<span class="math inline">\(K\)</span>
中的关键字的总长度成线性比例。</p>
<p>定理2
<em>使用通过算法2，算法3和算法1构造的跳转，失败和输出函数处理一个长度为
<span class="math inline">\(n\)</span>
的文本字符串可以让状态转换次数小于 <span
class="math inline">\(2n\)</span>。</em></p>
<p>证明
在算法1的每一个操作周期中通过一个跳转函数制造0次或者更多的失败转换。从一个深度为<span
class="math inline">\(d\)</span>的状态<span
class="math inline">\(s\)</span>，算法1永远不会在一个操作周期中制造多于<span
class="math inline">\(d\)</span>次的失败转换（作者注：最多可以达到<span
class="math inline">\(d\)</span>次失败转换，[13]证明，如果<span
class="math inline">\(K\)</span>中仅有一个关键字，在一个操作周期中，失败转换次数的最大值是
<span class="math inline">\(O(log
d)\)</span>）。那么总的失败转换次数一定最少比总的跳转转换次数少1.在处理一个长度为
<span class="math inline">\(n\)</span> 的输入时，算法1恰好进行<span
class="math inline">\(n\)</span>次跳转转换。因此总的转换次数小于 <span
class="math inline">\(2n\)</span>。</p>
<p>算法1的实际时间复杂度取决于它有多繁杂：</p>
<ol type="1">
<li><p>对于每个状态 <span class="math inline">\(s\)</span> 和输入字符
<span class="math inline">\(a\)</span>，确定 <span
class="math inline">\(g(s,a)\)</span></p></li>
<li><p>对于每个状态 <span class="math inline">\(s\)</span>，确定 <span
class="math inline">\(f(s)\)</span></p></li>
<li><p>确定 <span class="math inline">\(output(s)\)</span>
是否为空</p></li>
<li><p>输出 <span class="math inline">\(output(s)\)</span></p></li>
</ol>
<p>我们可以将跳转函数值存储在一个二维数组中，它将允许我们在常数时间内对于每一组
<span class="math inline">\(s\)</span> 和 <span
class="math inline">\(a\)</span> 确定 <span
class="math inline">\(g(s,a)\)</span>
的值。如果输入字母表的长度和关键字集较大，那么可能对于每个状态仅在一个线性表[1,11]中存储不合格的值要合理得多。这样的处理将使取决于
<span class="math inline">\(g(s,a)\)</span> 的复杂度变为状态 <span
class="math inline">\(s\)</span>
在跳转函数中不合格值的数量。一个合理的折中，也是我们使用的，是将最频繁使用的状态（例如状态0）存储在直接存取表中，下一个状态可以通过当前输入字符在表中的直接索引来定位。对于最频繁使用的状态，我们可以在常数时间内对每一个
<span class="math inline">\(a\)</span> 确定 <span
class="math inline">\(g(s,a)\)</span>。较少使用的状态和跳转函数值为不合格的状态可以编码在线性表中。</p>
<p>另一个方法会将每一个状态的跳转值以二叉树的形式存储。</p>
<p>失败函数值可以存储在一维数组中，这样对于每一个 <span
class="math inline">\(s\)</span> 可以在常数时间内确定 <span
class="math inline">\(f(s)\)</span>。</p>
<p>算法1中未打印的部分可以用于在 <span class="math inline">\(cn\)</span>
步内处理长度为 <span class="math inline">\(n\)</span>
的文本字符串，<span class="math inline">\(c\)</span>
是一个与关键字数量无关的常数。</p>
<p>现在我们考虑需要打印的输出次数。可以使用一个一维数组在常数时间内确定
<span class="math inline">\(output(s)\)</span>
是否为空。在每一个操作周期中，打印输出花费的时间正比于 <span
class="math inline">\(output(s)\)</span> 中关键字的长度总和，<span
class="math inline">\(s\)</span> 是算法1
在每个操作周期中的结束状态。在许多情况下，<span
class="math inline">\(output(s)\)</span>
通常只有一个关键字，所以对于每个输入状态打印输出所需的时间是常数。</p>
<p>然而，数量众多的关键词集可能出现在文本字符串的每个位置。在这种情况下算法1将会花费相当大的时间来打印输出结果。在最坏的情况下我们可能不得不打印<span
class="math inline">\(K\)</span>中的所有关键字，简直是文本字符串的每个位置。（考虑一个极端情况，<span
class="math inline">\(K = {a,a^2,a^3,\dots,a^k}\)</span>，文本字符串是
<span class="math inline">\(a^n\)</span>。即 <span
class="math inline">\(a_i\)</span> 是 <span
class="math inline">\(i\)</span> 个 <span
class="math inline">\(a\)</span>
的字符串。）任何其他的模式匹配机算法将不得不打印所有在文本字符串的每个位置打印同样数量的关键字，所以，比较模式匹配算法在使用时间的基础上识别关键字出现的位置是合理的。</p>
<p>我们应该比较算法1与另一种更直接的方式的表现，这种方式定位 <span
class="math inline">\(K\)</span>
中的所有是给定的文本字符串的子串的位置。这样的方式将会返回每一个 <span
class="math inline">\(K\)</span>
中的关键字，并针对文本字符串的所有字符位置成功匹配关键字。这种方法的运行时间最多与<span
class="math inline">\(K\)</span>中关键字的数量乘以文本字符串的长度成比例。如果有许多的关键字，算法性能将会比算法1差得多。实际上，正是早前算法的时间复杂度促使了算法1的发展。（读者可能希望在以下情况比较以下两个算法的性能，<span
class="math inline">\(K = {a,a^2,a^3,\dots,a^k}\)</span>，文本字符串是
<span class="math inline">\(a^n\)</span>。）</p>
<p>定理3 <em>算法2所需时间与关键字的总长度成线性比例关系。</em></p>
<p>证明 前面已证明。</p>
<p>定理4 <em>算法3对关键字的总长度处理可以达到线性级别。</em></p>
<p>证明 使用与定理2类似的方法，我们可以证明状态语句 <span
class="math inline">\(state\leftarrow f(state)\)</span>
执行的总次数超出了关键字的总长度。使用链表来表示一个状态的输出集，我们可以在常数时间内执行语句
<span class="math inline">\(output(s)\leftarrow output(s)\cup
output(f(s))\)</span>。注意当语句执行时 <span
class="math inline">\(output(s)\)</span> 和 <span
class="math inline">\(output(f(s))\)</span>
是不相关的。因此使用算法3所需的总时间主要取决于关键字的总长度。</p>
<h1 id="消除失败转换">消除失败转换</h1>
<p>本节展示如何在算法1中使用下一个函数到一个在跳转函数和失败函数的确定有限自动机位置来消除失败转换。</p>
<p>一个确定有限自动机[15]包括一个有限状态集 <span
class="math inline">\(S\)</span> 和一个下一步转移函数 <span
class="math inline">\(\delta\)</span>，对于每个状态 <span
class="math inline">\(s\)</span> 和输入字符 <span
class="math inline">\(a\)</span>，<span
class="math inline">\(\delta(s,a)\)</span> 是 <span
class="math inline">\(S\)</span>
中的一个状态。也就是说，一个确定有限自动机使状态转换和每个输入字对应。</p>
<p>通过在算法1中的跳转函数合适的地方在一个合适的有限自动机中使用下一步转移函数
<span
class="math inline">\(\delta\)</span>，我们可以分配所有的失败转换。这很容易通过替换算法1的<strong>for</strong>循环中前两句语句为一条语句
<span class="math inline">\(state\leftarrow
\delta(state,a_i)\)</span>。使用 <span
class="math inline">\(\delta\)</span>，算法1完全做到每个输入字符一个状态转换。</p>
<p>我们可以计算通过算法2，3，4建立的跳转和失败函数所需的下一步转换函数
<span
class="math inline">\(\delta\)</span>。算法4对每一个队列中的可能失败转换做了计算。算法4所需的时间与关键字集的大小呈线性相关。实际上，算法4会在算法3中被评估。</p>
<p>下一步转换函数计算通过算法4计算图1中展示的和图3中列表的跳转函数和失败函数。</p>
<p>下一步转换函数在图3中的编码如下。例如，在状态0中，我们有一个到状态1的转换
h，一个到状态3的转换
s，和一个到状态0的任一字符表示的状态。在每一个状态中，点表示任一上面其他的输入字符。这种下一步跳转函数的编码函数比将
<span class="math inline">\(\delta\)</span>
存储为一个二维的数组更经济。但是以这种方式存储 <span
class="math inline">\(\delta\)</span> 所需的内存大于相应的 <span
class="math inline">\(\delta\)</span> 函数所构建的跳转函数，因为在 <span
class="math inline">\(\delta\)</span>
中的许多状态，每一个都包含来自很多跳转函数的状态转换。</p>
<p>在图3中使用下一步跳转函数，算法1在输入为 “ushers”
时将会产生如图2第一行状态所示的状态转换。</p>
<p>在算法1中使用一个确定的有限自动机很可能将状态转换数量减少50%。但理论上节省的开销未必在实践中能达到，因为在典型案例中算法1将花费大多数实践中没有失败转换的状态0上。但是计算预期节省的开销是困难的，因为无法定义有意义的平均关键字集和平均文本字符串。</p>
<p><strong>算法4</strong> 构造一个确定有限自动机</p>
<p><strong>输入</strong> 算法2的跳转函数 <span
class="math inline">\(g\)</span> 和算法3的失败函数 <span
class="math inline">\(f\)</span></p>
<p><strong>输出</strong> 下一步输出跳转函数 <span
class="math inline">\(\delta\)</span></p>
<figure>
<img src="https://i.loli.net/2020/06/11/oByixRQCLEvWbZm.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="https://i.loli.net/2020/06/11/xuDSKyivF8nagWX.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h1 id="在参考书目检索中的应用">在参考书目检索中的应用</h1>
<p>算法1在模式匹配应用于大规模关键字时很有优势，因为所有的关键字在文本字符串中同时匹配只需要遍历一次文本字符串。这种算法类似的应用已经成功被用于一个图书馆参考书目检索程序中，用于定位在所有的参考书目中找到满足一定关键字布尔函数的所有参考书目。</p>
<p>这个检索系统所使用的数据库是贝尔实验室的技术图书库中用于当代科技论文的机器可读数据。这些参考书目来自期刊，覆盖了很广阔的技术领域。在1973年夏天，三年累积的数据，覆盖了大概150000条参考书目，总长度约有107个字符。</p>
<p>使用这个搜索系统书目编者可以在数据库中找到所有标题满足布尔组合条件的关键字。例如，书目编者可以请求查找数据库中所有同时包含关键字
“ion” 和 “bombardment” 的条目。书目编者也可以指定一个关键字是否有优先词
and/or，以及一些标点符号例如空格，逗号，分号等等。指明特性可以精确排除嵌于文本中的关键字。例如，将
“ions” 视为子串 “ion” 的匹配结果通常是合理的。但是，将 “motions”
视为该关键词的匹配结果通常就不合理了。这种实践允许选择接收完全嵌入的情况，左包含，右包含，或者不允许包含。这条规定对于算法1来说完全没有难度，即使用于标点符号在大量的跳转转换的关键词语法创造的状态。这可能导致算法1的确定有限自动机的应用消耗更多的空间，从而对一些应用来说失去魅力。</p>
<p>这个参考书目搜索程序的一个早期版本引进了一个直接的模式匹配算法，每个关键词在搜索指令中成功匹配每个标题。这个程序的第二个版本被投入使用，也是使用
FORTRAN
语言，不同之处仅仅在于模式匹配模式在算法1，2，3的子情况。下面的表格展示了两个样本运行在Honeywell
6070电脑中的两个程序的情况。第一个搜索样本包含15个关键字，第二个搜索样本包含24个关键字。（计算时间开销如下表所示）</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>15个关键字</th>
<th>24个关键字</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>旧系统</td>
<td>0.79</td>
<td>1.27</td>
</tr>
<tr class="even">
<td>新系统</td>
<td>0.18</td>
<td>0.21</td>
</tr>
</tbody>
</table>
<p>越大的关键字集性能的改善更明显。数据表明算法1的搜索开销几乎与关键字的数量相独立。构建模式匹配机和状态转换的时间开销与读取和输出文本字符串的时间开销微不足道。</p>
<h1 id="结束语">结束语</h1>
<p>本文阐述了模式匹配的有效应用，我们在文本字符串中查找大量的关键字的位置。因为没有额外的信息需要添加到文本字符串中，搜索可以跨任意文件。</p>
<p>一些信息查找系统计算一个文本文件的索引或者词语注解索引，使得搜索可以无需扫描整个文本字符串来进行[7]。在此类系统中改变文本文件很奢侈，因为每一处更改之后文件索引也必须更新。因此，此类系统最好用于长期静态的文本文件以及简短的模式。</p>
<p>有限自动机理论中一个有趣的问题是：给定一个长度为<span
class="math inline">\(r\)</span>的正则表达式 <span
class="math inline">\(R\)</span> 和一个长度为 <span
class="math inline">\(n\)</span> 的字符串 <span
class="math inline">\(x\)</span>，在 <span
class="math inline">\(R\)</span> 中找到 <span
class="math inline">\(x\)</span> 可以多快？解决这个问题的一种方法是从
<span class="math inline">\(R\)</span> 构建一个并非确定的有限自动机
<span class="math inline">\(M\)</span> 然后模拟 <span
class="math inline">\(M\)</span> 输入 <span
class="math inline">\(x\)</span> 时的行为。这种方案的时间复杂度为 <span
class="math inline">\(O(r n)\)</span>。</p>
<p>另一种方式循着正则表达式去构建一个不确定的有限自动机 <span
class="math inline">\(M\)</span>，然后将 <span
class="math inline">\(M\)</span>转化为一个确定的有限自动机 <span
class="math inline">\(M’\)</span> 并且使用 <span
class="math inline">\(M’\)</span> 模拟输入 <span
class="math inline">\(x\)</span> 时的行为。这种方法的唯一难处在于<span
class="math inline">\(M\)</span>可能有 <span
class="math inline">\(2^r\)</span> 种状态顺序。当然另一方面 <span
class="math inline">\(M’\)</span> 的仿真是线性的。总体的时间复杂度为
<span class="math inline">\(O(2^r+n)\)</span>。</p>
<p>我们可以使用算法4从一个正则表达式<span
class="math inline">\(R\)</span>直接构建一个确定有限自动机，所需时间与R的长度呈线性关系。但是，正则表达式的形式目前仅限为
<span class="math inline">\(\Sigma*(y_1 + y_2 + \dots +
y_k)\Sigma*\)</span> ，<span class="math inline">\(\Sigma\)</span>
是输入字符表。通过一系列确定有限自动机的前后级联，我们可以将正则表达式扩充为
<span class="math inline">\(\Sigma*Y_1\Sigma*Y_2\dots
\Sigma*Y_m\Sigma*\)</span> 的形式，<span
class="math inline">\(Y_i\)</span>是一个形式为<span
class="math inline">\(y_{i1} + y_{i2} +\dots+
y_{ik_i}\)</span>的正则表达式。</p>
<p>一个相关的开放性问题是新型常规集可以在少于<span
class="math inline">\(O(rn)\)</span>的时间内被识别出。[5]中表明循着这种方式具有形式为
<span class="math inline">\(\Sigma*y\Sigma*\)</span> 的正则表达式（
<span class="math inline">\(y\)</span> 是关键字“don’t care”字符）可以在
<span class="math inline">\(O(n log r log log r)\)</span>
时间内被识别出。</p>
<h1 id="致谢">致谢</h1>
<p>作者们感谢A.F.Ackerman,A.D.Hall,S.C.Johnson,B.W.Kernighan,以及M.D.McIlroy对手稿的有帮助的意见。本文使用Kernighan和Cherry[9]创制的排版设置。感谢B.W.Kernighan以及M.E.Lesk在准备这篇文论时的帮助。</p>
<p>1974年8月收到；1975年1月修订</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><p>Aho, A.V., Hoperoft, J.E., and Ullman, J.D. <em>The Design and
Analysis of Computer Algorithms.</em> Addison-Wesley, Reading, Mass.,
1974.</p></li>
<li><p>Booth, T.L. <em>Sequential Machines and Automata Theory.</em>
Wiley, New York, 1967.</p></li>
<li><p>Brzozowski, J.A. Derivatives of regular expressions. <em>J.
ACM</em> <strong>11:4</strong> (October 1964), 481-494.</p></li>
<li><p>Bullen, R.H., Jr., and Millen, J.K. Microtext - the design of a
microprogrammed finite state search machine for full-text retrieval.
<em>Proc. Fall Joint Computer Conference,</em> 1972, pp.
479-488.</p></li>
<li><p>Fischer, M.J., and Paterson, M.S. String matching and other
products. Technical Report 41, Project MAC, M.I.T., 1974.</p></li>
<li><p>Gimpel, J.A. A theory of discrete, patterns and their
implementation in SNOBOL4. <em>Comm. ACM</em> <strong>16:2</strong>
(February 1973), 91-100.</p></li>
<li><p>Harrison, M.C. Implementation of the substring test by hashing.
<em>Comm.ACM14:12</em> (December 1971), 777-779.</p></li>
<li><p>Johnson, W.L., Porter, J.H., Ackley, S.I., and Ross, D.T.
Automatic generation of efficient lexical processors using finite state
techniques. <em>Comm. ACM 11:12</em>(December 1968), 805-813.</p></li>
<li><p>Kernighan, B.W., and Cherry, L.L. A system for typesetting
mathematics. <em>Comm. ACM 18:3</em> (March 1975), 151-156.</p></li>
<li><p>Kleene, S.C. Representation of events in nerve nets. In
*Au**tomata Studies,* C.E. Shannon and J.McCarthy (eds.), Princeton
University Press, 1956, pp. 3-40.</p></li>
<li><p>Knuth, D.E. <em>Fundamental Algorithms,</em> second edition, The
Art of Computer Programming <strong>1,</strong> Addison-Wesley, Reading,
Mass.,1973</p></li>
<li><p>Knuth, D.E. <em>Sorting and Searching,</em> The Art of Computer
Programing 3, Addison-Wesley, Reading, Mass., 1973.</p></li>
<li><p>Knuth, D.E., Morris, J.H., Jr., and Pratt, V.R. Fast pattern
matching in strings. TR CS-74-440, Stanford University, Stanford,
California, 1974.</p></li>
<li><p>Kohavi, Z. <em>Switching and Finite Automata Theory.</em>
McGraw-Hill, New York, 1970.</p></li>
<li><p>McNaughton, <strong>R.,</strong> and Yamada, H. Regular
expressions and state graphs for automata. <em>IRETrans. Electronic
Computers</em> 9:1 (1960), 39-47.</p></li>
<li><p>Rabin, M.O., and Scott, D. Finite automata and their decision
problems. <em>IBM J. Research and Development</em> 3, (1959),
114-125.</p></li>
<li><p>Thompson, K.Regular search expression algorithm. <em>Comm.</em>
<em>ACM</em> <strong>11:6</strong> (June 1968), 419-422.</p></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Translate/" rel="tag"><i class="fa fa-tag"></i> Translate</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/python-use-selenium-control-browser/" rel="prev" title="Python-使用Selenium模块控制浏览器">
                  <i class="fa fa-chevron-left"></i> Python-使用Selenium模块控制浏览器
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Blog-bind-subdomain-to-blog/" rel="next" title="Blog-为博客绑定自定义二级域名">
                  Blog-为博客绑定自定义二级域名 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user-secrect"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">逃貓</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>
<script class="next-config" data-name="chatra" type="application/json">{"enable":true,"async":true,"id":"JBgdQtj33YZBaPNj7"}</script>
<script src="/js/third-party/chat/chatra.js"></script>
<script async src="https://call.chatra.io/chatra.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
