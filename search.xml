<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法-二分搜索算法</title>
    <url>/Algorithms-binary-search/</url>
    <content><![CDATA[<p>算法：二分搜索算法（折半查找算法） 时间复杂度：<span
class="math inline">\(O(log \; n)\)</span></p>
<ul>
<li>二分搜索算法概述</li>
<li>二分搜索算法伪代码</li>
<li>二分搜索算法实现</li>
</ul>
<span id="more"></span>
<h1 id="二分搜索算法概述">二分搜索算法概述</h1>
<p>二分搜索算法，也称折半查找算法，即在一个有序数组中查找某一个特定元素。整个搜索过程从中间开始，如果要查找的元素即中间元素，那么搜索过程结束；反之根据中间元素与要查找元素的关系在数组对应的那一半查找，例如查找元素大于中间元素，则在整个数组较大元素的那一半查找，反复进行这个过程，直到找到元素，或者数组为空，查找不到元素。</p>
<p>这里有一张非常形象的算法描述图：</p>
<figure>
<img src="https://idea-instructions.com/binary-search.png"
alt="Binary Search" />
<figcaption aria-hidden="true">Binary Search</figcaption>
</figure>
<h2 id="二分搜索算法描述">二分搜索算法描述</h2>
<p>给定一个数组 <span class="math inline">\(A_0, A_1...
A_{n-1}\)</span>， <span class="math inline">\(A_0 \le A_1 \le \cdot \le
A_{n - 1}\)</span>，待查找元素为<code>searchnum</code>：</p>
<ol type="1">
<li>用<code>left</code>，<code>right</code>分别表示左右端点，即要查找的范围；</li>
<li>用<code>middle</code>表示中间点，<span class="math inline">\(middle
= \lfloor (left + right) / 2 \rfloor\)</span>；</li>
<li>若<code>left &gt; right</code>，搜索失败；</li>
<li>若 <span class="math inline">\(A_{middle}\)</span>
&gt;<code>searchnum</code>，<code>right = middle - 1</code>，返回3；</li>
<li>若 <span class="math inline">\(A_{middle}\)</span> &lt;
<code>searchnum</code>，<code>left = middle + 1</code>，返回3；</li>
<li>若 <span class="math inline">\(A_{middle}\)</span> =
<code>searchnum</code>，搜索结束，返回<code>middle</code>。</li>
</ol>
<h1 id="二分搜索算法伪代码">二分搜索算法伪代码</h1>
<div class="tabs" id="pseudo-code"><ul class="nav-tabs"><li class="tab active"><a href="#pseudo-code-1">迭代版本</a></li><li class="tab"><a href="#pseudo-code-2">递归版本</a></li></ul><div class="tab-content"><div class="tab-pane active" id="pseudo-code-1"><p>BINARY-SEARCH-WHILE(A, searchnum, left, right) <figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt;= right</span><br><span class="line">  middle = (left + right) <span class="keyword">div</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">case</span></span><br><span class="line">    A_middle &lt; searchnum : left = middle + <span class="number">1</span></span><br><span class="line">    A_middle &gt; searchnum : right = middle - <span class="number">1</span></span><br><span class="line">    A_middle = searchnum : return middle</span><br><span class="line">return FAILED</span><br></pre></td></tr></table></figure></p></div><div class="tab-pane" id="pseudo-code-2"><p>BINARY-SEARCH-RECURSION(A, searchnum, left, right) <figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> left &lt;= right</span><br><span class="line">  middle = (left + right) <span class="keyword">div</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">case</span></span><br><span class="line">    A_middle &lt; searchnum :</span><br><span class="line">      return (A, searchnum, middle + <span class="number">1</span>, right)</span><br><span class="line">    A_middle &gt; searchnum :</span><br><span class="line">      return (A, searchnum, left, middle - <span class="number">1</span>)</span><br><span class="line">    A_middle = searchnum :</span><br><span class="line">      return middle</span><br></pre></td></tr></table></figure></p></div></div></div>
<h1 id="二分查找算法实现">二分查找算法实现</h1>
<div class="tabs" id="binarysearch-realize"><ul class="nav-tabs"><li class="tab active"><a href="#binarysearch-realize-1">C 迭代</a></li><li class="tab"><a href="#binarysearch-realize-2">C 递归</a></li><li class="tab"><a href="#binarysearch-realize-3">Pascal 迭代</a></li><li class="tab"><a href="#binarysearch-realize-4">Pascal 递归</a></li></ul><div class="tab-content"><div class="tab-pane active" id="binarysearch-realize-1"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(arrType * a, arrType searchnum, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> middle;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[middle] &gt; searchnum)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; searchnum)</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] == searchnum)</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="binarysearch-realize-2"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(arrType * a, arrType searchnum, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> middle;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[middle] &gt; searchnum)</span><br><span class="line">            <span class="keyword">return</span> binarySearch(a, searchnum, left, middle - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; searchnum)</span><br><span class="line">            <span class="keyword">return</span> binarySearch(a, searchnum, middle + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] == searchnum)</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="binarysearch-realize-3"><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部定义全局变量：</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    a : <span class="keyword">array</span>[<span class="number">1</span>..n] <span class="keyword">of</span> integer;</span><br><span class="line">    searchnum, result :integer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">binarySearch</span><span class="params">(left, right :integer)</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    middle : integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            middle := (left + right) <span class="keyword">div</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[middle] &gt; searchnum) <span class="keyword">then</span></span><br><span class="line">                right := middle  - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; searchnum) <span class="keyword">then</span></span><br><span class="line">                left := middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    result := middle;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> left &gt; right <span class="keyword">then</span></span><br><span class="line">        result := -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="binarysearch-realize-4"><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部定义全局变量：</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    a : <span class="keyword">array</span>[<span class="number">1</span>..n] <span class="keyword">of</span> integer;</span><br><span class="line">    searchnum, result :integer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">binarySearch</span><span class="params">(left, right :integer)</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    middle : integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> left &lt;= right <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            middle := (left + right) <span class="keyword">div</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[middle] &gt; searchnum) <span class="keyword">then</span></span><br><span class="line">                binarySearch(left, middle - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; searchnum) <span class="keyword">then</span></span><br><span class="line">                binarySearch(middle + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result := middle;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result := -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div></div></div>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li>Yan, Weimin., Wu, Weimin. 数据结构:
C语言版. China: 清华大学出版社, 1997.《数据结构基础（C语言版）》第二版</li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">二分搜索算法
- 维基百科，自由的百科全书</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-冒泡排序</title>
    <url>/Algorithms-bubble-sort/</url>
    <content><![CDATA[<p>算 法：冒泡排序算法 时间复杂度：<span
class="math inline">\(O(n^2)\)</span></p>
<ul>
<li><p>冒泡排序算法概述</p></li>
<li><p>冒泡排序伪代码</p></li>
<li><p>冒泡排序实现</p></li>
</ul>
<span id="more"></span>
<h1 id="冒泡排序算法概述">冒泡排序算法概述</h1>
<p>冒泡排序通常是我们在学习编程的过程中遇到排序问题，最先接触到的算法，它的算法过程就是每一趟排序都会通过交换不满足排序状态的相邻两个数来达到每一趟排序都让一个元素“冒泡”到正确位置，直到最后一趟“冒泡”过程完成，也就完成了排序。</p>
<h2 id="冒泡排序算法描述">冒泡排序算法描述</h2>
<ol type="1">
<li>第<span
class="math inline">\(i\)</span>趟“冒泡”过程从序列尾部遍历至第<span
class="math inline">\(i\)</span>个元素;</li>
<li>对于每一趟“冒泡”过程，比较每个正在遍历的元素与前一个元素的大小关系，如不满足，则交换2者位置;</li>
<li>持续1-2步骤直至对于每个位置都进行一趟“冒泡”过程为止。</li>
</ol>
<h2 id="冒泡排序示例">冒泡排序示例</h2>
<p>未排序： 5 31 16 7 9 10 3 第一趟： [<strong>3</strong>] 5 31 16 7 9
10 第二趟： [<strong>3 5</strong>] 7 31 16 9 10 第三趟： [<strong>3 5
7</strong>] 9 31 16 10 第四趟： [<strong>3 5 7 9</strong>] 10 31 16
第五趟： [<strong>3 5 7 9 10</strong>] 16 31 第六趟： [<strong>3 5 7 9
10 16</strong>] 31 第七趟： [<strong>3 5 7 9 10 16 31</strong>]</p>
<p>冒泡排序的动态演示：</p>
<p><a
href="https://visualgo.net/zh/sorting">VisuAlgo-排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，基数排序，基数排序）</a></p>
<h1 id="冒泡排序伪代码">冒泡排序伪代码</h1>
<p>（引用自《算法导论》） BUBBLESORT(A) <figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> A.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> j = A.length <span class="keyword">downto</span> i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; A[j - <span class="number">1</span>]</span><br><span class="line">      exchange A[j] <span class="keyword">with</span> A[j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure> # 冒泡排序实现 ##
C <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(arrType* a, <span class="type">int</span> arrLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrLength - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = arrLength - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">               t = a[j];</span><br><span class="line">               a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">               a[j - <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="pascal">Pascal</h2>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">bubblesort</span>;</span>   </span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  i, j, t : integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> arrLength - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j := arrLength <span class="keyword">downto</span> i + <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; a[j - <span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                t := a[j];</span><br><span class="line">                a[j] := a[j - <span class="number">1</span>];</span><br><span class="line">                a[j - <span class="number">1</span>] := t;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《算法导论》（第三版）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-插入排序</title>
    <url>/Algorithms-insertion-sort/</url>
    <content><![CDATA[<p>算 法：插入排序算法 时间复杂度：<span
class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>插入排序算法描述</li>
<li>插入排序伪代码</li>
<li>插入排序实现</li>
</ul>
<span id="more"></span>
<h1 id="插入排序算法概述">插入排序算法概述</h1>
<p>插入排序的原理是构建有序序列，对于给定的一个无序序列，从前往后遍历，在该元素之前的序列中从后往前扫描，寻找正确位置，这样对于每一个正在排序的元素，前面的序列总是有序的，当遍历完整个序列，即完成排序。《算法导论》给了一个更通俗更容易理解的形象的描述。我们都玩过扑克牌，大多数人拿扑克牌的时候都有这么个习惯，那就是将扑克牌按照一定的顺序排列好，而插入排序就好比你不断从桌上一堆无序排中拿起最上面的那张，然后放入自己手中已有的牌中，而每一次放的过程你都会按照某个顺序将这张新拿到的牌插入正确的位置，这样你手中的牌一直是有序的，而你抽取牌所在的牌堆是无序的。</p>
<h2 id="算法描述">算法描述</h2>
<p>下面以非降序排序为例： 1. 从第一个元素开始，该元素视为已经被排序； 2.
取出下一个元素记为<code>key</code>，在前面已排序的有序序列中从后往前扫描；
3. 如果扫描过程中的元素大于<code>key</code>，将该元素移至下一个位置； 4.
重复3，直至找到已排序的元素小于或等于<code>key</code>的位置； 5.
将<code>key</code>插入到该位置； 6.
重复2-5，直到整个序列遍历完即得到一个原地排序好的序列。</p>
<h2 id="执行过程图解">执行过程图解</h2>
<p>以斜体数字如 <u>1</u> 表示<code>key</code>，以粗体数字如
<strong>‘1’</strong>
表示已排序序列，为了更直观，用中括号括起来，普通数字如‘1’表示未排序乱序序列，简要表示排序流程如下：</p>
<ul>
<li>5 2 4 6 1 3</li>
<li>[<strong>5</strong>] <u>2</u> 4 6 1 3</li>
<li>[<strong>2 5</strong>] <u>4</u> 6 1 3</li>
<li>[<strong>2 4 5</strong>] <u>6</u> 1 3</li>
<li>[<strong>2 4 5 6</strong>] <u>1</u> 3</li>
<li>[<strong>1 2 4 5 6</strong>] <u>3</u></li>
<li>[<strong>1 2 3 4 5 6</strong>]</li>
</ul>
<p>插入排序的动态演示：</p>
<p><a
href="https://visualgo.net/zh/sorting">VisuAlgo-排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，基数排序，基数排序）</a></p>
<h1 id="插入排序伪代码">插入排序伪代码</h1>
<p>（伪代码引用《算法导论》给出的例子） INSERTION-SORT(A)
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> <span class="keyword">to</span> A.length</span><br><span class="line">  key = A[j]</span><br><span class="line">  <span class="comment">// Insert A[j] into the sorted sequence A[1..j - 1].</span></span><br><span class="line">  i = j - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">    A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">    i = i - <span class="number">1</span></span><br><span class="line">  A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure></p>
<h1 id="插入排序实现">插入排序实现</h1>
<p>为了更直观，我们将所有元素从1号元素开始计数，将0号元素视为无穷小，即数组长度为<code>arrLength + 1</code>，序列存储于<code>arr[1..arrLength]</code>。
## C <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(arrType* arr, <span class="type">int</span> arrLength)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  arrType key;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= arrLength; j++) &#123;</span><br><span class="line">    key = arr[j];</span><br><span class="line"></span><br><span class="line">    i = j - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] &gt; key) &#123;</span><br><span class="line">      arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Pascal <figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insertsort</span>;</span>   </span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  i,j,key:integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  arr[<span class="number">0</span>] := -maxint;</span><br><span class="line">  <span class="keyword">for</span> j := <span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    i := j - <span class="number">1</span>;</span><br><span class="line">    key := arr[j];</span><br><span class="line">    <span class="keyword">while</span> arr[i] &gt; key <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      arr[i + <span class="number">1</span>] := arr[i];</span><br><span class="line">      i := i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    arr[i + <span class="number">1</span>] := key;</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;  </span><br></pre></td></tr></table></figure> # 参考资料 *
《算法导论》（原书第3版) *
<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序-维基百科，自由的百科全书</a>
* 《Free Pascal 语言与基础算法》</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-选择排序</title>
    <url>/Algorithms-selection-sort/</url>
    <content><![CDATA[<p>算 法：选择排序算法 时间复杂度：<span
class="math inline">\(O(n^2)\)</span></p>
<ul>
<li>选择排序算法概述</li>
<li>选择排序伪代码</li>
<li>选择排序实现</li>
</ul>
<span id="more"></span>
<h1 id="选择排序算法概述">选择排序算法概述</h1>
<p>排序算法有许多，选择排序也是其中一种较为简单的方法。它的算法过程是是每一趟将当前数与后面的每一个数进行比较，若不满足排序所需顺序则交换两个数的位置，这样第一趟比较结束后，第一个数就是正确顺序的数，第<span
class="math inline">\(i\)</span>趟排序结束后，第<span
class="math inline">\(i\)</span>个位置的数都为正确的数，这个算法也被通俗地成称为“打擂台”，第一趟选择最大（最小）的数，第二趟选择出次大（次小）的数，一直到完成整个排序过程。</p>
<h2 id="选择排序算法描述">选择排序算法描述</h2>
<ol type="1">
<li>第<span class="math inline">\(i\)</span>趟“打擂台”过程从序列第<span
class="math inline">\(i\)</span>个元素开始遍历至尾部；</li>
<li>对于每一趟“打擂台”的选择过程，比较正在遍历的元素与第<span
class="math inline">\(i\)</span>个元素的大小关系，不满足，则交换两者位置；</li>
<li>持续1-2步骤直到每个位置都当过“擂主”。</li>
</ol>
<h2 id="选择排序示例">选择排序示例</h2>
<p>正在排序的数加粗表示<strong>3</strong>，排序后的数放于中括号内[3]，将被交换的数用斜体表示<em>3</em>
未排序： 5 31 16 9 7 10 3 第一趟： ** <em>5</em> ** 31 16 9 7 10
<em>3</em> [3] 31 16 7 9 10 5 第二趟： [3] <strong><em>31</em></strong>
16 9 7 10 <em>5</em> [3 5] 16 7 9 10 31 第三趟： [3
5]<strong><em>16</em></strong> <em>9</em> 7 10 31 [3 5]
<strong><em>9</em></strong> 16 <em>7</em> 10 31 [3 5 7] 16 9 10 31
第四趟： [3 5 7]<strong><em>16</em></strong> <em>9</em> 10 31 [3 5 7 9]
16 10 31 第五趟： [3 5 7 9] <strong><em>16</em></strong> <em>10</em> 31
[3 5 7 9 10] 16 31 第六趟： [3 5 7 9 10] <strong>16</strong> 31 [3 5 7 9
10 16] 31 [3 5 7 9 10 16 31]</p>
<h1 id="选择排序伪代码">选择排序伪代码</h1>
<p>SELECTIONSORT(A) <figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> A.length - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> j = i + <span class="number">1</span> <span class="keyword">to</span> A.length</span><br><span class="line">		<span class="keyword">if</span> A[i] &gt; A[j]</span><br><span class="line">			exchange A[j] <span class="keyword">with</span> A[i]</span><br></pre></td></tr></table></figure></p>
<h1 id="选择排序实现">选择排序实现</h1>
<h2 id="c">C</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(arrType* a, <span class="type">int</span> arrLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrLength - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; arrLength; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</span><br><span class="line">               t = a[i];</span><br><span class="line">               a[i] = a[j];</span><br><span class="line">               a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pascal">Pascal</h2>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">selectionsort</span>;</span>   </span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  i, j, t : integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> arrLength - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j := i + <span class="number">1</span> <span class="keyword">to</span> arrLength <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; a[i] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                t := a[i];</span><br><span class="line">                a[i] := a[j];</span><br><span class="line">                a[j] := t;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《Free Pascal语言与基础算法》</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-辗转相除法（欧几里得算法）</title>
    <url>/Algorithms-gcd-euclid/</url>
    <content><![CDATA[<p>算法：辗转相除法（欧几里得算法） * GCD递归定理</p>
<ul>
<li><p>辗转相除法算法概述</p></li>
<li><p>辗转相除法伪代码</p></li>
<li><p>辗转相除法代码实现</p></li>
</ul>
<span id="more"></span>
<p>对于两个数的最大公约数的求解，在我们的笔算过程中，通常是使用一个短除法，本质上其实也就是进行一个质因数分解的过程，但对于一个较大的数来说，将其进行质因数分解是一件非常耗时的过程，这显然不是一个好的做法，因此基于数论基础，我们有了辗转相除法，也叫做欧几里得算法。</p>
<h1 id="gcd递归定理">GCD递归定理</h1>
<p>在叙述该算法之前，先了解辗转相除法的实现前提也就是GCD递归定理： &gt;
对任意非负整数<span class="math inline">\(a\)</span>和任意正整数<span
class="math inline">\(b\)</span>, <span class="math display">\[
gcd(a,b) = gcd(b,a \quad mod \quad b)
\]</span></p>
<h1 id="辗转相除法算法概述">辗转相除法算法概述</h1>
<p>基于上面的GCD递归定理，我们便可以知道可以采用递归的方式，对两个整数的最大公约数进行相对较为高效的计算。</p>
<h2 id="算法描述">算法描述：</h2>
<ol type="1">
<li>求两个数的余数；</li>
<li>若余数为0，则较小数即为最大公约数；否则执行3；</li>
<li>用较小的数替换较大的数，用余数替换较小的数；</li>
<li>返回1.</li>
</ol>
<h2 id="算法示例">算法示例</h2>
<p><span class="math display">\[
gcd(30,21) = gcd(21,9) = gcd(9,3) = gcd(3,0) = 3
\]</span></p>
<h1 id="辗转相除法伪代码表示">辗转相除法伪代码表示</h1>
<p>下面我们采用递归方式实现辗转相除法。 (以下引用自《算法导论》)</p>
<p>GCD(a, b) <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> b == <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> GCD(b, a mod b)</span><br></pre></td></tr></table></figure></p>
<h1 id="辗转相除法实现">辗转相除法实现</h1>
<h2 id="c">C</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pascal">pascal</h2>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span><span class="params">(a, b : integer)</span> :</span>integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b = <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        gcd := a</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        gcd := gcd(b, a <span class="keyword">mod</span> b);</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《算法导论》（第三版）</li>
<li>《Free Pascal 语言与基础算法》</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Number theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-调整NexT主题Mist外观侧边栏在左</title>
    <url>/Blog-adjust-sidebar-nextmist-left/</url>
    <content><![CDATA[<p>在NexT主题的Mist外观下，侧边栏默认在右，而打开主题配置文件<code>_config.yml</code>查看，只有在<code>Pisces</code>，<code>Gemini</code>这两种外观下才可以通过<code>_config.yml</code>直接修改选择左侧或是右侧。而本人习惯把音乐播放器以及输入法放置于桌面右下角，故侧边栏在右并不方便
。于是在寻找了一些教程后 ，做出了修改，并做此记录和分享。</p>
<span id="more"></span>
<p>在此过程中需要修改如下几个文件： * sidebar.styl * sidebar-toggle.styl
* back-to-top.styl * motion.js</p>
<p>2019.3.25 更新 增加bug修正部分</p>
<h1 id="sidebar.styl">sidebar.styl</h1>
<p>路径：<code>.\themes\next\source\css\_common\components\sidebar\</code>
将此文件的第3行<code>right</code>改为<code>left</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.sidebar &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  left: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br></pre></td></tr></table></figure>
<h1 id="sidebar-toggle.styl">sidebar-toggle.styl</h1>
<p>路径：<code>.\themes\next\source\css\_common\components\sidebar\</code>
同样将第3行冒号前的<code>right</code>改为<code>left</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">left: $b2t-position-right;</span><br></pre></td></tr></table></figure>
<h1 id="back-to-top.styl">back-to-top.styl</h1>
<p>路径：<code>.\themes\next\source\css\_common\components\</code>
将第5行冒号前的<code>right</code>改为<code>left</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">left</span>: $b2t-position-right;</span><br></pre></td></tr></table></figure>
<h1 id="motion.js">motion.js</h1>
<p>路径：<code>.\themes\next\source\js\src\motion.js</code>
利用搜索功能找到改文档中的<code>paddingRight</code>字段，将<code>paddingRight</code>改为<code>paddingLeft</code>(共两处)。</p>
<h1 id="重新部署">重新部署</h1>
<p>重新部署即可完成侧边栏在左的设置。</p>
<h1 id="修正缩小窗口时的bug">修正缩小窗口时的bug</h1>
<p>自己没注意过这个问题，感谢评论区Jode_He指出和分享。仅使用上面的方案情况下，如果侧边栏的设置是展开状态，在浏览器窗口缩小时会导致侧边栏仍然存在且占据相当大的位置。做以下调整。</p>
<p>找到<code>./themes/source/js/src/motion.js</code>文件，在<code>$(document).ready(function ()&#123;&#125;)</code>内添加内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	    <span class="keyword">var</span> bwol=<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">offsetWidth</span>;</span><br><span class="line">	    <span class="keyword">if</span>(bwol &lt; <span class="number">975</span>)&#123;</span><br><span class="line">		$(<span class="string">&#x27;aside#sidebar&#x27;</span>).<span class="title function_">css</span>(<span class="string">&quot;display&quot;</span>,<span class="string">&quot;none&quot;</span>);</span><br><span class="line">		$(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">css</span>(<span class="string">&quot;paddingLeft&quot;</span>,<span class="string">&quot;0px&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	    <span class="keyword">var</span> bwos=<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">offsetWidth</span>;</span><br><span class="line">	    bwos &lt; <span class="number">975</span> &amp;&amp; $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">velocity</span>(<span class="string">&#x27;stop&#x27;</span>).<span class="title function_">velocity</span>(&#123;<span class="attr">paddingLeft</span>: <span class="number">0</span>&#125;,<span class="number">0</span>);</span><br><span class="line">	    <span class="keyword">if</span>($(<span class="string">&#x27;aside#sidebar&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;display&#x27;</span>) != <span class="string">&#x27;none&#x27;</span> &amp;&amp; $(<span class="string">&#x27;aside#sidebar&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;width&#x27;</span>)!=<span class="string">&#x27;0px&#x27;</span>)</span><br><span class="line">		$(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">velocity</span>(<span class="string">&#x27;stop&#x27;</span>).<span class="title function_">velocity</span>(&#123;<span class="attr">paddingLeft</span>: <span class="number">350</span>&#125;,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	   <span class="title class_">NexT</span>.<span class="property">motion</span> = &#123;&#125;;</span><br><span class="line">	   </span><br><span class="line">	   ...</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html">HEXO+NEXT主题个性化配置|SORA</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-修改站点主题以及站点配置文件</title>
    <url>/Blog-change-blog-theme/</url>
    <content><![CDATA[<p>觉得官方的主题不太好看，Github上，Hexo官网上都有许多可供选择的主题，我这里使用<a href="http://theme-next.iissnan.com/">NexT</a>主题，本文介绍了修改主题的方法以及站点配置文件<code>_config.yml</code>的一些相关配置。</p>
<span id="more"></span>
<h1 id="改变主题">改变主题</h1>
<h2 id="下载主题">下载主题</h2>
<p>将需要的主题从Github下载（clone）到你的站点目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>
<h2 id="修改站点配置文件">修改站点配置文件</h2>
<p>修改你的站点配置文件<code>_config.yml</code>，找到如下字段，只要将<code>theme</code>后面的主题修改为<code>next</code>即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<h1 id="站点配置文件的设置">站点配置文件的设置</h1>
<h2 id="设置个人头像">设置个人头像</h2>
<p>个人头像将显示在侧边栏中。在<code>.\source</code>下创建一个<code>images</code>文件夹，将想要设置为头像的图片放于此文件夹中。修改<code>_config.yml</code>，在其中添加如下代码：
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Head portrait</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/images/cat.jpg</span></span><br></pre></td></tr></table></figure></p>
<h2 id="设置站点的基本信息">设置站点的基本信息</h2>
<p>在<code>_config.yml</code>中找到如下字段，配置个人站点的基本信息，下面的出现位置举例基于NexT主题。</p>
<p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">（此处为站点名称，即左上角的名称）</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">（站点描述，将出现在侧边栏头像下方）</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">（作者，将出现在侧边栏头像下方，如果没有修改主题配置文件，同时会出现在网页下方）</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">（界面语言，简体字为zh-Hans）</span></span><br></pre></td></tr></table></figure> # 设置置顶文章
找到文件<code>node_modules\hexo-generator-index\lib\generator.js</code>，将文件内容修改为：
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">locals</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="variable language_">this</span>.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.<span class="property">posts</span>;</span><br><span class="line">    posts.<span class="property">data</span> = posts.<span class="property">data</span>.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="property">top</span> &amp;&amp; b.<span class="property">top</span>) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.<span class="property">top</span> == b.<span class="property">top</span>) <span class="keyword">return</span> b.<span class="property">date</span> - a.<span class="property">date</span>; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.<span class="property">top</span> - a.<span class="property">top</span>; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="property">top</span> &amp;&amp; !b.<span class="property">top</span>) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.<span class="property">top</span> &amp;&amp; b.<span class="property">top</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.<span class="property">date</span> - a.<span class="property">date</span>; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.<span class="property">pagination_dir</span> || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">pagination</span>(<span class="string">&#x27;&#x27;</span>, posts, &#123;</span><br><span class="line">    <span class="attr">perPage</span>: config.<span class="property">index_generator</span>.<span class="property">per_page</span>,</span><br><span class="line">    <span class="attr">layout</span>: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    <span class="attr">format</span>: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">__index</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 发布时需要置顶的文章在前面格式处配置，top值越大越前面:
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">top: 7</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure> # 修改文章链接格式
修改<code>permalink</code>样式可以改变自动生成的博文链接样式：
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure> # 参考资料</p>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html">开始使用-NexT使用文档</a></li>
<li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html">hexo的next主题个性化教程：打造酷炫网站|Moorez</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>NexT</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-为博客绑定自定义二级域名</title>
    <url>/Blog-bind-subdomain-to-blog/</url>
    <content><![CDATA[<p>本文记录为博客绑定自定义二级域名过程以及踩到的坑。网上普遍找到的博客搭建教程以绑定顶级域名居多，个人感觉一个博客绑定一个顶级域名也太浪费了些，故寻找绑定二级域名的方法，并记录遇到的问题和解决方式。</p>
<span id="more"></span>
<p>需要了解域名的相关基础知识，可查看参考资料1。</p>
<h1 id="添加-cname文件">添加 CNAME文件</h1>
<p><strong>方式一：通过仓库设定添加 <code>CNAME</code> 文件</strong></p>
<ol type="1">
<li><p>打开博客所在仓库，选择 <code>Setting</code>；</p></li>
<li><p>找到 GitHub Pages 设定条目，在 Custom domain
下输入你的二级域名，例如
blog.example.com，点击保存，该操作将发布源的根目录下创建一个
<code>CNAME</code> 文件；</p></li>
</ol>
<p><strong>方式二：手动添加 <code>CNAME</code> 文件</strong></p>
<ol type="1">
<li><p>在仓库根目录下添加一个名为 <code>CNAME</code>
的文件，该文件名必须全部大写；</p></li>
<li><p>在该文件内写入你的二级域名，如 blog.example.com；</p></li>
</ol>
<p><strong>方式三：在本地手动添加 <code>CNAME</code>文件</strong></p>
<ol type="1">
<li><p>在本地的博客目录<code>.\source\</code> 路径下创建一个
<code>CNAME</code> 文件；</p></li>
<li><p>在该文件内写入你的二级域名，如 blog.example.com；</p></li>
</ol>
<h1 id="添加-dns-记录">添加 DNS 记录</h1>
<ol type="1">
<li><p>打开域名服务商后台 DNS 管理；</p></li>
<li><p>添加一条 <code>CNAME</code>
记录，主机名即刚刚设定的二级域名，比如上面的 blog.example.com 即为 blog
，地址填写原来的 github 博客地址。</p></li>
</ol>
<h1 id="故障处理">故障处理</h1>
<p>网上搜索到的零星教程配置完成了，但会发现在本地使用
<code>hexo d -g</code>
推送更新时产生错误，无法征程推送，在官方文档中找到了解决方案。</p>
<p>产生错误的原因在于本地构建博客推送的方式在静态博客渲染页面提交可能覆盖掉了
<code>CNAME</code> 文件。使用以下命令提交 <code>CNAME</code>
文件以免被覆盖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add CNAME</span><br><span class="line">git commit -m  <span class="string">&quot;add CNAME file&quot;</span> </span><br></pre></td></tr></table></figure>
<p>再次尝试，问题应该已经解决，同时在仓库的设置页应该会显示一个提示
”Your site is published at http://blog.example.com " 。</p>
<p>设置页还提供了 HTTPS 选项，勾选该选项，可强制使用 HTTPS
协议访问，访问站点将变为 "https://blog.example.com "
，同时浏览器地址栏将不会提示该站点可能不安全。</p>
<p>至此，当访问 Github 提供的二级域名 user.github.io
时将切换为自定义域名访问。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><p><a
href="http://winterttr.me/2015/10/23/from-dns-to-github-custom-domain/">从
DNS 到 github pages 自定义域名 -- 漫谈域名那些事 | Life &amp;
Note</a></p></li>
<li><p><a
href="https://help.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site">Managing
a custom domain for your GitHub Pages site - Github Help</a></p></li>
<li><p><a
href="https://help.github.com/en/github/working-with-github-pages/troubleshooting-custom-domains-and-github-pages">Troubleshooting
custom domains and GitHub Pages - Github Help</a></p></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-Hexo搭建</title>
    <url>/Blog-hexo-build/</url>
    <content><![CDATA[<p>在查找一些技术资料的时候总会看到一些漂亮的博客，喜欢文字，也想自己搭建起一个博客来。尽管在网上搜索到了许多Github+Hexo的博客搭建教程，但仍然也遇到了不少问题，几经折腾，终于可以使用，于是决定先写一篇我在Win10下的搭建过程作为记录和分享。（也可以参考<a href="https://hexo.io/zh-cn/docs/index.html">官方文档</a>，官方文档也写得挺详细。）</p>
<span id="more"></span>
<h1 id="环境准备">环境准备</h1>
<ol type="1">
<li>Node.js环境</li>
<li>Git</li>
</ol>
<h2 id="node.js环境">Node.js环境</h2>
<p>在<a
href="https://nodejs.org/en/">官网</a>下载与电脑系统相匹配的Node.js并安装。</p>
<p>也可以前往Nodejs的<a href="http://nodejs.cn/">中文网</a></p>
<h2 id="git">Git</h2>
<p>前往<a
href="https://git-scm.com/">官网</a>下载与你的电脑相对应版本的Git。安装完成后，你将会看到Git
Bash在你的右键菜单中。</p>
<p>前往<a
href="https://github.com/">Github官网</a>注册Github帐号，完成后创建一个仓库（New
repository）。仓库名为<code>yourgitname.github.io</code></p>
<p>将电脑中的Git与Github帐号设置一致。</p>
<h3 id="coding">Coding</h3>
<p>在<a href="https://coding.net/">Coding</a>
注册账号，新建项目，之后创建Coding-pages分支，并设置为默认分支，在左侧开启coding-page服务.</p>
<h2 id="安装hexo">安装HEXO</h2>
<p>在电脑中新建一个文件夹，进入文件夹，右键，选择命令行或者直接选择<code>Git Bash Here</code>
，打开命令行窗口。</p>
<h3 id="使用npm安装hexo">使用npm安装Hexo</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>
<h1 id="开始搭建blog">开始搭建Blog</h1>
<h2 id="新建一个网站">新建一个网站</h2>
<p>安装完成后，初始化文件夹，无参数默认当前路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init [foldername]</span></span><br></pre></td></tr></table></figure>
<h2 id="新建一篇文章">新建一篇文章</h2>
<p>如果没有设置layout，默认为<code>default_layout</code>
参数（也就是<code>post</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new [layout] &lt;title&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="生成静态文件">生成静态文件</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo generate</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以简写为</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo g</span></span><br></pre></td></tr></table></figure>
<h2 id="启动服务器">启动服务器</h2>
<p>默认访问网址为<a href="http://localhost:4000/"
class="uri">http://localhost:4000/</a>，这时候别人是看不到你的网站的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo server</span></span><br></pre></td></tr></table></figure>
<h1 id="与github关联">与Github关联</h1>
<h2 id="修改站点配置文件">修改站点配置文件</h2>
<p>打开<code>_config.yml</code> 文件，修改deploy</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/Yourgitname/your_reperoryname.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># ssh形式</span></span><br><span class="line">  <span class="comment">#repo : git@github.com:yourgitname/yourreperoryname.github.io.git</span></span><br><span class="line">  <span class="comment">#此处为之前创建仓库的仓库地址，在创建完成后有一个界面可以复制，或者直接复制网址加上.git</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@git.coding.net:codingname/projectname.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">coding-pages</span></span><br></pre></td></tr></table></figure>
<h2 id="安装git部署插件">安装Git部署插件</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure>
<h2 id="部署网站">部署网站</h2>
<p>部署成功后，就可以通过yourgitname.github.io这个地址看到自己的博客了。Coding
的地址则是youcodingname.coding.me/projectname</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo deploy</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以简写为</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo d</span></span><br></pre></td></tr></table></figure>
<h2 id="markdown-编辑器推荐">Markdown 编辑器推荐</h2>
<p>文件采用 Markdown 标记方式来实现文章的格式化，推荐两个编辑器：</p>
<ul>
<li><p><a href="https://www.typora.io/">Typora</a>
(支持更多的导出格式)</p></li>
<li><p><a href="https://marktext.app/">Mark
Text</a>（支持多标签页方式打开文件，可绿色安装不写注册表）</p></li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo搭建个人网站详细教程</a></li>
<li><a href="https://github.com/niices/blog/issues/7">Hexo部署个人博客到Github
Page和Coding Page并绑定域名#7·niices/blog</a></li>
<li><a href="https://hexo.io/zh-cn/docs/setup.html">建站|Hexo</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-NexT主题配置文件配置</title>
    <url>/Blog-themes-config/</url>
    <content><![CDATA[<p>本文整理了NexT主题下通过配置主题<code>_config.yml</code>进行的相关配置。</p>
<span id="more"></span>
<p>进入路径<code>.\themes\next\</code>，修改主题下的配置文件<code>_config.yml</code></p>
<p>需要注意的是，YAML语言对格式的要求较为严格，如generate时出错可以使用<a
href="http://nodeca.github.io/js-yaml/">YAML parser for
JavaScript-JS-YAML</a>对自己的配置文件格式进行检查。或者可以查看<a
href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML语言教程-阮一峰的网络日志</a>了解相关语法。</p>
<h1 id="选择外观">选择外观</h1>
<p>NexT主题提供了不同的外观，默认是<code>Muse</code>，本站为<code>Mist</code>。找到如下<code>Schemes</code>字段，去掉想实现的外观前的注释号</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>
<h1 id="菜单和小图标">菜单和小图标</h1>
<p>菜单选项可以通过<code>_config.yml</code>中<code>menu</code>字段中的各项来控制，增加和删减菜单选项。菜单的小图标可以通过更改符号<code>||</code>后面的值来修改，后面的描述分别对应的是<a href="https://fontawesome.com/icons?d=gallery&m=free">Font
Awesome</a>列出的小图标。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archives</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="站点小图标">站点小图标</h1>
<p>修改站点小图标，默认为NexT图标，在<a herf="https://www.favicon-generator.org">Favicon
&amp; App Icon
Generator</a>可以上传自己的图片生成不同大小的图标。进入路径<code>./themes/next/source/images</code>，将原本NexT的图标替换为自己的图片，并在<code>_config.yml</code>中的如下字段将图片名称做相应的修改。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br></pre></td></tr></table></figure>
<h1 id="页脚设置">页脚设置</h1>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">heartbeat</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="显示建站年份">显示建站年份</h2>
<p>将<code>since</code>前的注释号去掉，并修改建站年份。</p>
<h2 id="修改页脚小图标">修改页脚小图标</h2>
<p><code>icon</code>后填写<a href="https://fontawesome.com/icons?d=gallery&m=free">Font
Awesome</a>中自己喜欢的小图标，默认为心形。</p>
<h2 id="修改页脚作者名">修改页脚作者名</h2>
<p>修改<code>copyright</code>的值，默认为站点配置文件中的<code>author</code>的值。</p>
<h2 id="不显示由hexo强力驱动">不显示“由Hexo强力驱动”</h2>
<p>将<code>powered</code>的值设置为<code>false</code>，默认为<code>true</code>。</p>
<h2 id="不显示next版本">不显示NexT版本</h2>
<p>将如下字段的值改为<code>false</code>，默认为<code>true</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span></span><br><span class="line">  <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">  <span class="attr">version:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="侧边栏设置">侧边栏设置</h1>
<h2 id="设置侧边栏展开方式">设置侧边栏展开方式</h2>
<p>搜索字段<code>sidebar</code>，下面有这么几个选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#display:post</span><br><span class="line">#display:always</span><br><span class="line">#display:hide</span><br><span class="line">#display:remove</span><br></pre></td></tr></table></figure>
<ul>
<li><code>post</code> 表示在文章页面自动展开</li>
<li><code>always</code> 表示在所有页面自动展开</li>
<li><code>hide</code> 表示只有在点击侧边栏展开时才展开</li>
<li><code>remove</code> 表示不显示侧边栏及其图标
需要哪种模式就将前面的注释符号<code>#</code>去掉。</li>
</ul>
<p>Mist
外观下侧边栏修改为左端参见：<a href = "https://fish-404.github.io/Blog-adjust-sidebar-nextmist-left/">Blog-调整NexT主题Mist外观侧边栏在左|在逃的貓</a></p>
<h2 id="设置侧边栏社交链接">设置侧边栏社交链接</h2>
<p>找到<code>social</code>字段，设置在侧边栏要显示的社交链接，记得要把<code>social</code>前的注释号去掉。<code>||</code>后面的是<a href="https://fontawesome.com/icons?d=gallery&m=free">Font
Awesome</a>中的小图标，图标的显示设定在<code>social_icons</code>中设定。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:youremail</span> <span class="string">address</span> <span class="string">here||</span> <span class="string">envelope</span></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="设置侧边栏背景">设置侧边栏背景</h2>
<p>找到<code>./themes/next/source/css/_custom</code>中的<code>custom.styl</code>文件，添入以下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;images/photo.jpg&quot;</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat; </span><br><span class="line">    <span class="selector-tag">p</span>,<span class="selector-tag">span</span>,<span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: <span class="number">#000000</span>;&#125;     <span class="comment">/* set the text color */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>修改背景为背景图片</p>
<p>代码如上所示，在路径中创建一个<code>images</code>文件夹，将背景图放置在文件夹中，为防止遮挡文字效果，可适当调整透明度。</p></li>
<li><p>修改背景为其他底色</p>
<p>添加一个<code>bacckground-color</code>选项，设置为需要的颜色。</p></li>
</ul>
<p><strong>小技巧</strong>：</p>
<p>可以在浏览器中按下<code>F12</code>开启开发者模式（本人使用的是Firefox），点击选取侧边栏部分查看代码，可以在此添加和修改各个选项实时查看效果，确定后再添加至代码中。</p>
<h1 id="开启数学公式显示">开启数学公式显示</h1>
<p>在NexT主题下的配置文件<code>_config.yml</code>中找到<code>Third Party Services Settings</code>，找到
<code>MathJax Support</code>，将<code>enable</code>值修改为<code>true</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<h1 id="添加评论系统">添加评论系统</h1>
<p>个人比较喜欢不需要登陆也能进行评论的系统，在浏览了一番资料后发现<code>Valine</code>简洁易用，正合我意。当前使用的<code>NexT</code>主题的配置文件中已经包含了<code>Valine</code>的设定，在<code>_config.yml</code>中找到<code>Third Party Services Settings</code>，在其中找到<code>Valine</code>，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">true</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">true</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span>  <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">7</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>enable</code>改为<code>true</code>；</li>
<li><code>appid</code>和<code>appkey</code>需要通过在
<a href="https://leancloud.cn/">LeanCloud(CN)</a> 或
<a href="https://console.leancloud.app/apps">LeanCloud(国际)</a>
创建一个应用获得，创建办法是先注册一个<code>LeanCloud</code>用户，创建一个应用，为这个应用取个名字，在应用侧边栏<code>设置</code>选项中找到<code>应用Key</code>选项，将提供的<code>App ID</code>与<code>App Key</code>复制到此配置文件中；</li>
<li><code>notify</code>将开启邮件通知，需要在<code>LeanCloud</code>中修改相关邮件设置，开启<code>notify</code>后，<code>verify</code>也将开启；</li>
<li><code>verify</code>设置评论是否需要验证码；</li>
<li><code>placeholder</code>设置评论框默认的显示语句，可自定义；</li>
<li><code>avatar</code>:
设置头像，<code>Valine</code>使用的是<code>Gravatar</code>来配置头像，（<a href="http://cn.gravatar.com/">Gravatar-全球公认的头像</a>），如果有<code>Gravatar</code>账号，在评论时使用注册<code>Gravatar</code>时留下的邮箱，评论时就将出现<code>Gravatar</code>设置的头像。该字段有多个选项，在并不与<code>Gravatar</code>关联的情况下可以选择其他头像(详情可参见
<a href="https://valine.js.org/avatar.html">头像配置|Valine</a> )：
<ul>
<li><code>''</code> ：Gravatar官方头像</li>
<li><code>mp</code> ：神秘人，一个灰白人头像</li>
<li><code>identicon</code> ：抽象几何图形</li>
<li><code>monsterid</code> ：小怪物</li>
<li><code>wavatar</code> ：用不同面孔和背景组合生成的头像</li>
<li><code>retro</code> ：八位像素复古头像</li>
<li><code>robohash</code> ：一种具有不同颜色、面部等的机器人</li>
<li><code>hide</code> ：不显示头像</li>
</ul></li>
<li><code>guest_info</code>：配置可供评论读者填写的个人信息选项；</li>
<li><code>pageSize</code> ：每页显示的评论数量。</li>
</ul>
<h1 id="添加顶部加载提示">添加顶部加载提示</h1>
<p>在<code>_config.yml</code>文件中找到<code>pace</code>字段，设置为<code>true</code>，在下面的样式中进行选择，建议可以修改后先不提交，使用<code>hexo s</code>预览效果，觉得合适再提交，本站使用的是<code>pace-theme-bounce</code>右上角有一个蓝色的弹跳小球，随着博文的加载，弹跳小球将逐渐消失。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment">#pace-theme-big-counter</span></span><br><span class="line"><span class="comment">#pace-theme-bounce</span></span><br><span class="line"><span class="comment">#pace-theme-barber-shop</span></span><br><span class="line"><span class="comment">#pace-theme-center-atom</span></span><br><span class="line"><span class="comment">#pace-theme-center-circle</span></span><br><span class="line"><span class="comment">#pace-theme-center-radar</span></span><br><span class="line"><span class="comment">#pace-theme-center-simple</span></span><br><span class="line"><span class="comment">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment">#pace-theme-fill-left</span></span><br><span class="line"><span class="comment">#pace-theme-flash</span></span><br><span class="line"><span class="comment">#pace-theme-loading-bar</span></span><br><span class="line"><span class="comment">#pace-theme-mac-osx</span></span><br><span class="line"><span class="comment">#pace-theme-minimal</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-bounce</span></span><br></pre></td></tr></table></figure>
<h1 id="添加网易云音乐插件">添加网易云音乐插件</h1>
<p>新建一个歌单，在网页版中点击生成外链播放器，此时可以选择大小，以及是否自动播放，将生成的代码插入到侧边栏的配置文件中<code>themes/next/layout/_macro/sidebar.swig</code>，插入位置应该在<code>&lt;aside&gt;,&lt;/aside&gt;</code>之内，否则音乐播放器是在页面末尾实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;music163player&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">110</span> <span class="attr">src</span>=<span class="string">&quot;//music.163.com/outchain/player?type=0&amp;id=2339687903&amp;auto=0&amp;height=90&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="修改文末标签图样">修改文末标签“#”图样</h1>
<p>打开文件<code>themes\next\layout\_macro\post.swig</code>，找到<code>rel="tag"&gt;#</code>，将<code>#</code>用<code>&lt;i class="fa fa-tag"&gt;&lt;/i&gt;</code>进行替换。</p>
<h1 id="添加字数统计">添加字数统计</h1>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>
<p>在<code>themes\next\_config.yml</code>文件中查找<code>wordcount</code>，在下面的配置中选择配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">totalcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="添加站内搜索">添加站内搜索</h1>
<p>在<code>themes\next\_config.yml</code>文件中查找<code>local_search</code>，在下面的配置中启用和配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html">开始使用-NexT使用文档</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%BC%80%E5%90%AF%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%98%BE%E7%A4%BA">开启数学公式显示·
iissnan/hexo-theme-next Wiki · GitHub</a></li>
<li><a href="https://valine.js.org/">介绍|Valine</a></li>
<li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html">hexo的next主题个性化教程：打造酷炫网站|Moorez</a></li>
<li><a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html">HEXO+NEXT主题个性化配置|SORA</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-A.I.杀人吗？（读《暗夜亡灵》完全泄底）</title>
    <url>/Bookcomment-Dark-ghost/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">篇目：《暗夜亡灵》</span><br><span class="line">作者：付强</span><br><span class="line">收录于《银河边缘001：奇境》</span><br></pre></td></tr></table></figure>
<p>《暗夜亡灵》为《银河边缘001：奇境》收录的中国原创势力科幻作品，同时这也是一篇科幻作品。在第15次福阁讨论会中，作为讨论篇目，有幸作为主讲人，此文为讨论会讲稿整理以及讨论会上提出的一些观点补充。</p>
<p><strong>本文完全泄底，为避免影响阅读体验，请先阅读原作。</strong></p>
<span id="more"></span>
<h1 id="死者与密室">死者与密室</h1>
<h2 id="尸体">尸体</h2>
<p>根据委托人的记录，飞船上仅有两名科研人员，而现场也出现了两具尸体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「尽管有少许出入，但几乎可以确定，两具尸体就是杨舟和朱莉。」方慧开门见山道，她将四张图谱投影在高云面前，「测序结果显示，尸体的基因与两人基因库中的数据相似度达到了95%。」</span><br></pre></td></tr></table></figure>
<p>由此确认两名死者均为科研暗夜号上的科研人员。这里提出了一个非常有趣的疑点，即尸体的基因测序虽然几乎可以确定尸体为杨舟和朱莉，但却又有非常诡异的差别。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然而在宇宙世纪标准的基因检测方法中。5% 是个很大的差别，一般只发生在生活环境迥异的同卵双胞胎中。</span><br></pre></td></tr></table></figure>
读到这个疑点的时候完全以为仅仅是一种科普式的炫学，完全没意识到这里有什么异常，直到读到解答才发现这是两人尸体异常解答的非常关键的证据。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">至于为什么他们与本体的基因相似度只有95%，是因为从表观遗传学的角度看，克隆人的情况正相当于生存环境迥异的同卵双胞胎。</span><br></pre></td></tr></table></figure>
但对于非专业读者而言，仍然还是很难想到这个基因差别是来自于克隆吧。</p>
<p>##密室</p>
<p>尽管存在一个基因误差，但仍不妨碍认定两名死者身份。这也就引发了推理小说中的核心问题，那么，究竟谁是凶手？</p>
<p>因为有了A.I.的存在，因此难免会怀疑A.I.会不会在自主智能的前提下杀害了两个主人，但根据阿西莫夫定律，机器人不得伤害人类，因此这种假设似乎不存在了。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">阿西莫夫三定律</span><br><span class="line"></span><br><span class="line">1. 机器人不得伤害人类个体，或者目睹人类个体将遭受危险而袖手不管</span><br><span class="line">2. 机器人必须服从人给予它的命令，当该命令与第一定律冲突时例外</span><br><span class="line">3. 机器人在不违反第一、第二定律的情况下要尽可能保护自己的生存</span><br></pre></td></tr></table></figure>
于是引出了新的问题，那么，是否是两名研究人员的其中一人杀死了另一人，而后自杀呢？如果是，那么谁是那个凶手呢？</p>
<p>这时需要破解的其实是朱莉房间的密室之谜：房间内没有生活用品，死者在房间内，房门口有血迹且从驾驶室一直延续到此处，房门内却一尘不染。一个令人匪夷所思的密室。如果是杨舟，那么朱莉的房门如何上锁？如果是朱莉，生活用品为何不在？</p>
<p>于是在挑战读者之前，文中就有了两个伪解答：</p>
<ol type="1">
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有人伤害了朱莉，并将房间内的生活用品全部卷走。之后朱莉恢复了意识，她挣扎着锁上了房门，最后死在房里，于是形成了眼前的「时间差密室」</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这个解答看似解决了死者在房内，房门紧锁的问题，但在这种情况下，即使做一个牵强的解释，加害者卷走了生活用品，却无法除去躲到密室里的受伤的朱莉的血迹。可能有人会提出可能朱莉的伤没有大量出血，因此没有留下血迹，但事实是门口留下了血迹，很难牵强地辩解进入房门后开始停止失血。因此这种假设失败。
这种情况下无法解释血迹的消失。</p>
<ol start="2" type="1">
<li>杨舟因为一心忙于实验研究，忽视了恋人朱莉，朱莉为了给杨舟一点小小的惩罚而离开，但杨舟却信以为真，以为恋人已离开而放弃治疗与世长辞，朱莉返回后因自责而自尽。
但这种情况下却又无法解释朱莉血迹的出现。</li>
</ol>
<p>从剧情上感觉还蛮容易接受的 但是推理小说需要的不仅仅是剧情</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在侦探小说的世界里，有时一部作品非常无聊，作为小说明显很失败，但仍有可能是名作。</span><br><span class="line"></span><br><span class="line">这是其他类型小说没有、侦探小说独有的特点。无论一部侦探小说多么乏味、多么稚嫩，只要最后给出猛烈一击，便能弥补上述不足，便能得到读者的原谅——这就是侦探小说。说穿了，侦探小说看的就是「解谜」以及「诡计」。当然，其他类型的小说不读到最后也不能下评判，只是侦探小说赋予「解谜、诡计和结局」的权重大得畸形。</span><br><span class="line">                                       ——霜月苍《阿加莎·克里斯蒂阅读攻略》</span><br></pre></td></tr></table></figure>
<p>否定了这些假设，又回到了A.I.是否杀人的问题。</p>
<p>虽然最后的解答看起来有一点犯规，即这根本不是同一艘飞船，因此密室也就不攻自破。但侦探与助手的对此的讨论却相当精彩，合情合理。而发现密室根本不在同一个地方的重点即是其实从头到尾的暗夜号异常。</p>
<h1 id="暗夜号异常">暗夜号异常</h1>
<ol type="1">
<li>飞船与设计图有出入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总觉得这艘船和设计图有些微妙的出入……</span><br><span class="line">比如这里的花纹，难道不应该是花瓣形的吗？</span><br></pre></td></tr></table></figure></li>
<li>临近的两副货架材质不一 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">好奇怪，临近的两副货架居然不是相同的材质！</span><br></pre></td></tr></table></figure></li>
<li>消失的第三间寝室 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">走廊的尽头本应有另一间寝室。房门相互错开的布置，是为了留出第三间寝室的空间。 方慧面色凝重，「这里不但有一只幽灵，还有一间消失的寝室。」</span><br></pre></td></tr></table></figure></li>
<li>培养皿仅有两次使用记录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「根据杨舟的记录，他们正在进行克隆生物的培养。」方慧分析道，「日记中提到的动物不下二十种，全是稀有动物，甚至不乏巳经灭绝的物种。」 高云点点头，「培养克窿生物恐怕是暗夜号的主要目的，我想委托人感兴趣的也是这点吧。」 「可无论我怎样调查计算机中的数据，都只能查到两次培养皿的使用记录。」方慧将双臂抱在胸前，「如果是杨舟或朱莉刻意删除了数据，那他们为什么要这样做呢？更进一步来看，既然删除了数据，又为何要留下两次的使用记录呢？」</span><br></pre></td></tr></table></figure></li>
</ol>
<p>5.飞船的位置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日记只记述到了黑洞边缘的故事，在那之后，他们为何会来到太空墓场？</span><br></pre></td></tr></table></figure>
这些疑点遍布在谜面的各个角落，我是完完全全地被骗过去了，这大概就是新本格吧，需要非常丰富的想象力，《密室收藏家》（强推这本！密室短篇集）中也有一个有些相似的诡计。</p>
<h1 id="有趣的真相">有趣的真相</h1>
<h2 id="杨舟如何死亡">杨舟如何死亡</h2>
<p>这个谋杀手段相当有趣，我们可能读到过尸体掉包的诡计，而此处尸体不掉包，但血液掉包！这直接催生了对血液的产生来源的误解！且排异反应这个设定也很科学。这里有盐城提出了一个相当精彩的推理：</p>
<p>如果血液DNA检测出的是朱莉的，那么应该有白细胞，或者说必须只能是由白细胞细胞核检测DNA，但是如果有白细胞存在，那么不应该会有排异反应，排异反应是由白细胞产生的。而如果假设白细胞不存在，只提供了红细胞，那么血液DNA检测就不可能是朱莉。</p>
<p>这是讨论会上留下的一个未解的僵局。</p>
<h2 id="a.i.-如何杀人">A.I. 如何杀人</h2>
<p>这里有一个很精彩的地方，即朱莉用复杂的密语写的字条。而菲根据字条上的命令一条一条的执行，却完美地完成了谋杀。密语字条的设定很有趣，我们看到字条上的内容显然是在杨舟已经离开之后，这时飞船上仅剩下了朱莉和菲。字条上的内容也并没有涉及任何谋杀内容，朱莉完全没有必要去使用密语加密之类。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">朱莉为何要用如此复杂的密语写下这些东西呢？为了打发杨舟不在后的无聊时光吗？恐怕不是。她大概没能料到自己无法活着回到地球，之所以用这样的记述方式，是为了不会被别人发现秘密。</span><br></pre></td></tr></table></figure>
文中没有明确说明，但我的理解是菲和朱莉可能有一部分交流是通过这种ATCG序列进行的，但又有一个问题，菲已经相当智能了，不需要用编码序列这种方式来交流。想到菲几乎有自己的人格，我把这里的设定理解为菲和朱莉像是两个女孩子一样使用着密语交流着两人（不是）的秘密。而这可能就是朱莉日常记录的方式，以这种方式传达自己的心情和生活。但完全没有想到菲会因此曲解为指令而葬送了自己。</p>
<h2 id="a.i.为何重造飞船">A.I.为何重造飞船</h2>
<p>故事的这一点，我觉得是特别温暖的一部分。菲被格式化后，完全不解两人的尸体出现在了暗夜号上的情况，也不知道自己的执行命令葬送了朱莉，却带着数据重建了飞船，等待有人将真相解开告诉自己，于是才有了奇怪的复制版暗夜号。这也才是杨舟日记里深受器重的菲吧，她完全没想到就是自己不经意间置朱莉于死地，想要找到这两个伙伴死亡的真相，A.I.与科研人员的情深。</p>
<p>#其他疑问 1. 朱莉为何杀死杨舟？ 仅仅是因为杨舟一心投身研究的缘故吗？
2.
为何原来的暗夜号上有三间寝室？仅有两个研究人员，为何需要三间寝室，三间寝室在复制时少了一间这个设定又有何作用？
3. 为何菲要带走一本推理小说，还另外从太空墓场捡来一本兵器图鉴？
针对推理小说这点，清源提出了一个非常有趣的观点，菲想要通过阅读推理小说学习推理试着推理真相！我们看到菲对于真相很是执着，甚至不惜重新打造暗夜号，不惜把前来的高云方慧二人的飞船抢走，所以这解释虽听起来颇为搞笑但还是合理的。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Sci-Fi</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-夜长</title>
    <url>/Bookcomment-Walk-in-the-night/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：     夜行</span><br><span class="line">作者：    【日】森见登美彦</span><br><span class="line">译者：    单元皓</span><br><span class="line">出版社：  北京联合出版有限公司</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>很幸运地在豆瓣鉴书团收到本书，收到书的时候，封面让我有些想起《樱草忌》，因此还未阅读便先有了些好感。其实我更喜欢书去掉封套后的样子，藏青色的设计与整本书的格调很是相符。书中夹着的书签上写着作者给《夜行》刊行的纪念辞：
&gt; 旅途中的夜晚 追赶上来的 另一个自己。</p>
<p>我并不常出远门旅行，至少目前很少，但极爱深夜。每一天都在等待所有人关灯入睡，与夜色相伴。即使不是旅途的夜晚，也会遇见另一个自己。</p>
<p>在这本书以前，虽然读过不少日本作品，但并没有读过森见登美彦的作品。整个故事给我的感觉是安静，若是能翻开书页，听着夜曲，独坐星空之下，想来会是再美好不过的画面。五个夜晚，五个地点，五段奇遇。我没能弄明白故事的最后，究竟是夜行的尽头是曙光，还是这本就是两个平行世界，各有各的方向，自有自的黑白。也许像是两段从同一个顶点引出的不同射线，自有方向，却彼此相似。发生这个这个世界上的在那个世界上也上演了一遍。我曾经有过这也的感觉，在某个瞬间，觉得某件事，某个我正在经历的场景似曾相识，但我又清楚地知道我不可能曾经经历，也许，是不是真的存在平行世界。读到故事的结尾有一瞬间会想起不久前读过的刘慈欣的科幻作品《镜子》，一个创世纪参数创造下的世界模型，站在创世者的位置，清楚地看到了每个人的故事。</p>
<p>最偏爱第三夜发生在津轻的故事，向往那样搭上列车前往遥远的陌生城市的旅途，也为那个幻化出来的小女孩着迷。放火烧了自己臆想中的小女孩的家，这看起来就像是那些以精神分裂、人格分裂为题材创作的影视作品、文学作品里的故事。每一次读到这样的故事，我都会不禁怀疑起是不是我所熟识的那些个不多的好友也都是我虚构出来的而已，其实她们都不曾存在?</p>
<blockquote>
<p>「为什么这幅画会让我感觉这么熟悉呢？」 我盯着这幅画喃喃自语道。
「或许这栋房子就建在自己的夜的世界里吧。」</p>
</blockquote>
<p>也许每个人都拥有一个仅属于自己的夜的世界吧，铜版画所引发的神秘的夜也许都只不过他们每一个人，每一天害怕的失去。
* 第一夜 尾道 中井与妻子 * 第二夜 奥飞驒 武田与美弥 * 第三夜 津轻
藤村与小佳奈 * 第四夜 天龙峡 田边与岸田 * 第五夜 鞍马 大桥与长谷川</p>
<p>在那一个夜的世界，被迫拷问自己，追寻另一个自己。</p>
<p>虽然没能完全明白这个故事，但我以为，能让我想起自己的，都是好故事。想起自己曾经在凌晨缓步慢行于大街上，才发觉原来繁华城市的夜也是安静的，原来夜也没那么黑。又在清晨徒步穿行过数条街道，伴随着曙光一点点出现和到来。后来我常常回想起那个夜晚，怀念那段独自走在夜空下的时光。也许我也害怕失去，害怕被现实磨平棱角，不再是那个随性而为的自己。</p>
<p>贪恋夜长的人才懂夜的美，夜空下存在着另一个世界，活着另一个自己。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-解剖推理童话《卖花女郎》</title>
    <url>/Bookcomment-anatoomy-reasoning-fairy-tales-flower-girl/</url>
    <content><![CDATA[<p>因担任福尔摩斯推理阁推理小说第十二期讨论会的主讲人，本文整理自第十二期讨论会，讨论会篇目为保罗·霍尔特短篇集《恶狼之夜》中收录的《卖花女郎》。霍尔特是我最喜欢的当代欧美推理小说家，也是欧美推理作家里少有的仍坚持本格派的当代推理作家。在《恶狼之夜》这本短篇集中，我最喜欢的故事是《卖花女郎》。本文将对《卖花女郎》里所营造的推理童话进行剖析。</p>
<p>在《卖花女郎》这个故事里，霍尔特企图让我们相信圣诞老人存在，在没有看到解答前，你甚至会觉得是一篇童话！</p>
<p><strong>本文泄底，请先阅读霍尔特的故事</strong>
<strong>本文泄底，请先阅读霍尔特的故事</strong>
<strong>本文泄底，请先阅读霍尔特的故事</strong> <span id="more"></span></p>
<h1 id="圣诞老人之谜">圣诞老人之谜</h1>
<p>整个故事其实很简单，圣诞前夜，也就是圣诞老人童话般的出现和消失。我们来看看霍尔特是如何营造出了一个童话般的谜面：</p>
<h2 id="谜面分析">谜面分析</h2>
<h3 id="铃铛声音">铃铛声音</h3>
<blockquote>
<p>突然，外面传来了铃铛的声音。</p>
</blockquote>
<p>这里，也就是我们的圣诞老人「出场」的开始。</p>
<p>并且霍尔特借小托米和德让克·斯特林的对话，以小托米的天真和斯托克的略带嘲讽，让铃声显得很神秘也很可信。</p>
<blockquote>
<p>您没有听到吗？那是圣诞老人的铃声，还有驯鹿脖子上挂着的铃铛的声音。</p>
</blockquote>
<p>甚至以德让克·斯特林自己来做出疑问：</p>
<blockquote>
<p>不过，那铃声真的很奇怪……声音好像很近，应该不是从河对岸传过来的。而且，我想不出这附近有谁喜欢扮成圣诞老人……这条街上只有我们一家人……伯克利？不可能……他现在肯定还是醉醺醺的！</p>
</blockquote>
<blockquote>
<p>没有人能够回答德让克·斯特林的问题。大家都感到疑惑，于是决定到外面去瞧个究竟。</p>
</blockquote>
<p>借着众人的反应，神秘的铃铛声首先给这个圣诞夜蒙上了一层神秘的童话色彩。而同时注意到，借德让克·斯特林的口说出了铃声并不是从河对岸传过来，也就是说铃声理应从门外传来，为后面的不可能埋下了线索，而且很自然地引到了大家走出了暖和的房子。</p>
<h3 id="德让克家门口雪地痕迹">德让克家门口雪地痕迹</h3>
<blockquote>
<p>小路上仍然寂静无人，但是有人——或者说是「有些东西」——在雪地上留下了痕迹。那是非常特殊的痕迹，因为这些痕迹完全不符合物理学原理。</p>
<p>从两栋房子的中间开始，有一段痕迹一直延伸到伯克利家的门口。痕迹很特殊，显然是套着牲口的雪橇所留下的，而且有高大的四蹄动物的蹄印。问题是，这段痕迹似乎是凭空出现的！雪橇的痕迹突然出现在平坦的雪地上，向前延伸了十几米，然后又神秘地消失了！这实在是让人难以置信！</p>
<p>更让人吃惊的是：这段痕迹是刚刚出现的，因为在一刻钟之前这里还非常平坦——所有的人都可以发誓。但是真正惊人的发现还在后面，他们走进痕迹仔细观察，发现痕迹是逐渐加重的！最初的两三米，雪橇的痕迹很浅；随后的五六米，痕迹很深、很清晰；随后痕迹又逐渐变浅了，直至完全消失！就好像雪橇是从天而降，停到了伯克利家的门口，然后又启动了，逐渐地减轻了对雪地的压力，直至腾空而起！</p>
</blockquote>
<p>这里霍尔特把这道神秘的雪地痕迹描写地十分详细（也许是因为他是工程师出身的原因吧~)，我们几乎可以想象那是怎样的一种痕迹，我读到这里的时候我都要相信圣诞老人了。没想明白那种由浅入深再由深入浅的痕迹是怎样产生的，几乎要相信这是从天而降的圣诞老人的杰作。读到这里的时候觉得这完全没法用一个合理的诡计来解释，自己没想到，也特别期待解答，几乎觉得解答会是一种欺骗的把戏。谜底我们后面再谈。</p>
<h3 id="伯克利家">伯克利家</h3>
<p>在铃声出现前，文中提到伯克利家没有灯光。</p>
<blockquote>
<p>但是在进门之前，德让克·斯特林心中显然感到隐隐不安，他忍不住朝伯克利居所的方向看了一眼——那栋房子没有任何灯光。</p>
</blockquote>
<p>而当众人出门察看的时候：</p>
<blockquote>
<p>伯克利家也不再是一片漆黑了。窗户里亮着灯光，开着一条缝的房门也透出了一道光线。</p>
<p>炉火在伯克利家的笔录燃烧着，非常旺的炉火，甚至比德让克·斯特林家里的炉火还要旺——光是炉火的光芒就足以照亮宽敞的房间。</p>
</blockquote>
<p>这里前后两处对伯克利家灯光状况的描写，说明什么？在痕迹出现前伯克利家应该是没有人的，虽然他们家里非常穷，但是毕竟是圣诞夜，家里有人至少也会有一点点微弱的灯光吧。但当众人一起去查看的时候，按照房屋的状态，既然房门开了一条缝，那么屋内通常来说应该有人，但是:</p>
<blockquote>
<p>他敲了敲，但是没有人来开门。</p>
<p>房间里空无一人，另一个房间里也没有人。屋子里所有的窗户都关着，房门时唯一的出入通道。</p>
</blockquote>
<p>也就是说屋内并没有人，而房门这个入口也没有人进入的迹象，否则众人进门的时候就应该察觉到。</p>
<h4 id="房间内的礼物">房间内的礼物</h4>
<blockquote>
<p>在壁炉旁边矗立着一棵漂亮的圣诞树，在圣诞树下面放着好几个礼物盒，外面都包裹着华丽的包装纸和缎带。礼物盒的旁边有一匹崭新的红色木马——比托米的木马还要大一号。那匹木马鲜艳的颜色和房间里贫寒的环境形成了鲜明的对比。</p>
</blockquote>
<p>我们看到这礼物和小托米和泰欧多尔收到的礼物包装和类型是类似的，都非常对小孩子的喜好。而礼物本身和房间极为不搭，也就是说，这礼物根本不可能是伯克利为女儿做的准备。这也是德让克恼羞成怒的原因之一，思冬妮出色的表演让他极为不堪，但显然有能力支付起礼物的德让克吝啬之极，根本不可能给一个被自己解雇的店员女儿送圣诞礼物，更何况他本人对这样的传说极为不耐烦。</p>
<h3 id="文中的谜面分析">文中的谜面分析</h3>
<p>我们来看看文中是如何再次强调这次圣诞老人的不可能事件的：</p>
<blockquote>
<p>在房子外面，德让克·斯特林徒劳地四处寻找骗局的痕迹。他要求客人们和他一起检查房子的每个角落，窗户、仓库的墙壁、小河边，以及雪地上的痕迹；但是他们什么都没有找到。至于地面上的雪橇痕迹和四蹄动物的蹄印，尽管最后飘落的雪花让痕迹稍稍模糊了，但大家都一致认为那确实是由马匹或者是驯鹿拉着的雪橇所留下的痕迹。现在的问题就是，在这么短的时间里，在宽仅四米的小路上，原本平坦的雪地上怎么会出现这些痕迹？</p>
<p>小河的河岸很陡，而且河岸远远高于水面——至少有半米的距离，这就排除了雪橇从水路上岸的可能性，也就是说不可能是用船把雪橇运过来。同样的，用棍子或者其他器械伪造雪橇的痕迹也不可能，即使非常复杂的手段也做不出如此清晰的痕迹。更重要的是，很显然曾经有人进入过伯克利的房子，而且逐渐加深和浅化的雪橇痕迹都很说明问题。谁也无法为这些奇怪的现象找出合理的解释。这几个人实际上是见证了一个「奇迹」：圣诞老人真的来过！</p>
</blockquote>
<p>圣诞夜的谜面到此结束。不知道大家在阅读的时候是否猜到了真相。我自己完全没能想到。我们来看看文中给出的谜底。</p>
<h2 id="谜底">谜底</h2>
<p>不得不说在阅读霍尔特给出的谜底之前，我很是怀疑他是否能把这样一个童话般的谜面解释得合情合理。但读了谜底之后，完全心服口服，虽然完全能意识到故事的讲述者米卡埃勒·波阿我也完全没有想到这桩童话是两个孩子一手导演的，其实本该想到，因为也只有孩子有这样的天马行空。而其实谜面里线索还留得挺足的，包括思冬妮的演技，讲述者是戏剧创作者，而他的妻子也是表演艺术家，这也是一个小小的暗示，只不过在读谜面的时候完全没有意识到罢了。不过关于文中说到思冬妮名字和她的真名利迪，这两个名字在远古文明的关系我没能找到，也仅仅是知道文中脚注的那分别是两座古城。</p>
<h3 id="铃铛">铃铛</h3>
<p>首先是把众人引出房子，把圣诞老人引出来的铃铛。我们在谜面中看到了，铃铛声音是从房子外面传来的，也就是说在德让克房子里的所有人都不可能是摇动铃铛的人。而出场人物就只有思冬妮和伯克利了，除非真相真的是那个不可能的圣诞老人。但我们都相信圣诞老人并不存在。而伯克利在整个故事中其实并没有出场，以他醉汉的身份也很难想出如此天真烂漫的把戏。这样一来，也就只剩下了小女孩思冬妮。读谜面的时候我并没有意识到这点，后来看了解答再返回去看谜面，发现其实这里就多少能意识到思冬妮也许是这个童话的制造者之一。</p>
<h3 id="雪地痕迹">雪地痕迹</h3>
<p>雪地痕迹，这也是整个童话谜面最重要的组成部分，也是霍尔特企图让读者相信圣诞老人的最重要的部分。那个完全不符合物理学原理的雪地上留下的从天而降的雪橇痕迹。想知道大家读的时候有没有思考过这个雪地痕迹？我自己没有想到这个雪地痕迹是如何形成的，不过这个解释我觉得很合理也很有趣，虽然也很繁琐，也还需要点天气的巧合，如果在整个几乎实施过程中雪并没有按照时间落下，那么这个计划就会失败，虽然是一个很难在现实可行的手法，但与这个故事结合起来就非常有意思。（不知道霍尔特有没有做过实验呢，在南方没见过雪的孩子表示只能相信了咯，北方的孩子可以拿个单车轧个车痕验证看看hhh）</p>
<blockquote>
<p>你们必须分两次或者三次来完成整个计划。首先，你们必须完全盖住中间的区域——要在第一批雪花落下之前，这样就能保存一段清晰的雪橇痕迹。过一段时间之后，你们再用床单盖住两头的地面；经过一段时间的降雪，两边的痕迹已经变得模糊了，这样一来你们就有了貌似逐渐加深和逐渐变浅的痕迹。</p>
</blockquote>
<p>这个诡计的巧妙之处我觉得就在于我们的思考会先入为主地认为是先降雪才在雪面上压出的雪橇痕迹，而事实刚好相反，是先有了痕迹，再逐步掩盖，从而形成了这样一个看似荒谬的痕迹。</p>
<p>另外，关于用于遮盖雪迹所使用的床单，霍尔特也埋下了一个有意思的小伏笔，这么短篇幅的故事里，却平白地讲了一个似乎和圣诞老人毫无关系的小火灾，连床单来源都考虑到写个火灾，真的是佩服。</p>
<blockquote>
<p>胡伯尔一家安顿下来的第二天，洗衣房里莫名其妙地发生了火灾。</p>
<p>幸运的是，火灾很快就被扑灭了。在洗衣房里存放着的床单和日用品都化为了灰烬。</p>
</blockquote>
<blockquote>
<p>如果您只是简单地偷走床单，警方可能会对神秘消失的床单起疑心。</p>
</blockquote>
<h3 id="对于小托米说辞的一点点看法">对于小托米说辞的一点点看法</h3>
<p>当然了，这整个谜面虽然是与其说是呈现给读者，其实却只不过是两个孩子贪玩的恶作剧。对于文中小托米声称看到圣诞老人，但我们知道他实际上并没有看到，文中给的解释是通过泰欧多尔的的暗示来说服小托米，我觉得这是这个谜的一个不足，虽然铃声、雪地痕迹、礼物确实已经很足够营造出一个圣诞老人存在的童话，但是文中对于小托米的描写是，趴在窗户边声称看到了圣诞老人，也许这里倒不如说思冬妮在回收床单和摇晃铃铛的时候戴上了圣诞帽，而因为下着雪，小托米并不能看到很清晰的窗外景象，听着铃声又看着移动着的圣诞帽，才声称自己看到了圣诞老人，这样是不是会更合理一些呢？</p>
<h1 id="德让克之死">德让克之死</h1>
<p>德让克之死，我们看到在他在圣诞夜之后频频被这个谜题给折磨不休。在最后写这个故事更像是一个小插曲，像是一个对德让克的嘲笑一样，死在河边的商人，身上多处伤痕，头骨破裂，但附近没有脚印，也没有商人自己的脚印。没有人有动机。这场死亡就这样不了了之，但嘲讽的是，德让克的死亡，似乎让其他人都过上了更好的生活。而给出的谜底更像是嘲笑不相信圣诞老人的我们，其实很简单，只是德让克受尽圣诞老人存在这个谜面的折磨而执迷于寻找真相而不得，却最终不慎跌落丧命。这里，霍尔特为了写德让克的焦躁不安，甚至还安排了从烟囱送入礼盒的小情节，而礼盒里只有一先令硬币，又是一场十足的嘲笑。</p>
<h2 id="德让克的焦躁不安">德让克的焦躁不安</h2>
<p>故事里从圣诞老人之谜的铃声开始就开始写德让克的焦躁不安，逐步加剧：</p>
<blockquote>
<p>德让克·斯特林恼怒地打断了孩子的话</p>
</blockquote>
<p>刚开始只是嘲讽和恼怒小托米关于圣诞老人的猜想。</p>
<blockquote>
<p>德让克·斯特林的五官都扭曲了起来。面前的景象越来越让他觉得荒谬，而朋友儿子的又让他心烦意乱。他怒不可遏地命令小托米闭嘴。他的眼睛里冒着火焰，强忍着怒气。</p>
</blockquote>
<p>看到雪地痕迹和礼物后，德让克已经非常愤怒，觉得有人在刻意捉弄他（事实也确实是hh）。</p>
<blockquote>
<p>老商人气得浑身发抖，他嘟囔了几句含混不清的话，然后转身离开了房间。</p>
<p>他严厉地盘问了小托米。</p>
<p>德让克·斯特林觉得无可奈何、思维混乱，他垂头丧气地放弃了努力。</p>
</blockquote>
<p>德让克思索圣诞老人之谜无果。</p>
<blockquote>
<p>他在大房子里转来转去，竖着耳朵，眼睛警惕地四处搜索。他清脆的足音时而回响在楼梯上，时而又在楼上的走廊里响起。他声称很快就会抓住入侵者，而且会狠狠地教训给他捣乱的人。</p>
</blockquote>
<p>德让克已经从情绪的愤怒转移到了行动上，也许是觉得自己的权威受到了挑衅。这也解释了后面为什么他会爬上屋顶。</p>
<h2 id="德让克的滑落">德让克的滑落</h2>
<h3 id="房屋结构">房屋结构</h3>
<p>而关于德让克滑落，其实前文对于房子的结构介绍的时候也有一个小小的铺垫。文中写到</p>
<blockquote>
<p>那是一栋都铎王朝风格的大房子，醒目地矗立在伦敦一个体面的街区，有倾斜的屋顶和高耸的人字墙。</p>
</blockquote>
<figure>
<img
src="https://i0.wp.com/hisour.com/wp-content/uploads/2018/05/Tudor-Revival-architecture.jpg?w=960&amp;ssl=1"
alt="都铎王朝风格的房子" />
<figcaption aria-hidden="true">都铎王朝风格的房子</figcaption>
</figure>
<p>图片来源：https://hisour.com/zh/tudor-revival-architecture-29799/</p>
<p>而德让克这种富商角色显然不会是一个手脚灵活的爬屋顶的人（手动滑稽），文中有这样一段他的身体状况描述：</p>
<blockquote>
<p>房子的主人，德让克·斯特林已经六十多岁了，头发花白，有些驼背——也许是因为岁月的侵蚀，但更可能是被他积攒的财富压弯了腰。</p>
</blockquote>
<p>（连这段描述，霍尔特都没有放过嘲讽）像这么倾斜的屋子，加上他本身焦躁不安，又怒火中烧，掉下来真的是都可以说合情合理了。</p>
<h3 id="屋顶雪痕">屋顶雪痕</h3>
<p>而德让克如果是从屋顶滑落，那么必然会有雪痕，那么为什么没有人会注意到呢？</p>
<p>文中也给出了解释。众人已经被前一晚上的圣诞老人之谜迷惑，几乎已经相信了从天而降的圣诞老人，理所当然地觉得是神迹，所以看到德让克死亡现场周围没有脚印当然也很自然地会联想到是和前一天晚上的一样的情况，自然不会想要看屋顶。</p>
<blockquote>
<p>但是几个证人已经被圣诞前夜的奇遇搞得神经兮兮，于是他们作出了错误的解释。我可以原谅他们，但是我无法原谅苏格兰场的警官！如果他们当中有人相信圣诞老人——哪怕只信一点点儿——他只要仰头望天并且向周围观望就行了，他必然会看到凶手作案的证据！他会注意到在房檐附近的积雪被弄乱了。</p>
</blockquote>
<p>而警官更是不相信众人的叙述，警方到现场的时候本身也在下雪，而也不会觉得这样一个富商有什么理由爬到屋顶上去，更何况还是在上面找圣诞老人了😀。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有人说我们给孩子们编一本《给孩子的科幻》完全没问题，但是没法编一本《给孩子的推理》，因为推理故事里大多是世界的黑暗。如果真要编一本《给孩子的推理》，我想霍尔特的《卖花姑娘》应当入选~</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-疑案另解</title>
    <url>/Bookcomment-black-gospel/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：    黑色福音</span><br><span class="line">作者：    【日】松本清张</span><br><span class="line">译者：    叶荣鼎</span><br><span class="line">出版社：  上海三联书店</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>读的第二本松本清张作品，比起前一本读的采用时刻表诡计的《点与线》，这部作品由于改编自真实事件，个人觉得更有社会派的味道。</p>
<p>故事围绕着巴奇里奥教会，神父，黑市交易展开。我并不信教，因此对宗教并不了解，但也不会觉得宗教会与黑市交易有什么联系，如果不是腰封上写着「源自真实事件
日本侦查史上唯一挥之不去的污点」，大概会觉得作者也许对宗教有什么偏见，把宗教内部描写的如此黑暗不义。</p>
<p>故事完全按照时间顺序来写，大体上可以分为两部分，古里艾鲁莫教堂的种种不端，和杀人灭口后各种瞒天过海的行径。很有趣的看到，在后半部分警察各项搜证调查遭受阻扰，只能获取明知不可信却又无力反驳的证据，而这些证据恰恰与前文所看到的事发经过完全相悖，不断被教会对于警方所调查的种种细节捏造证据而感到震惊。通过黑市贩卖救援物资，假借翻译《圣经》之名暗地偷情，趁传教之机骚扰女性，以教会筹资为名对从贩毒等非法交易牟利受之泰然，勾结日本高官力压调查进展……偏偏日本警方却又对此不齿行径束手无策，无奈于嫌犯兼具宗教和外籍双重身份，小心翼翼，最终让嫌犯（读者们都知道的犯人）光明正大地逃之夭夭。</p>
<p>这个故事听起来简直离谱，那么真实事件又是怎样的呢？在网络上并没有找到很多资料，可能因为已是60年前的陈年旧案。机翻了
Wiki 上关于此案的日文版描述，了解到该案被称作「BOAC
空姐谋杀案」，1959年3月10日，英国海外航空公司（现英国航空）一名空姐的尸体在东京一河流下游被发现，起初被认定为自杀，后经司法解剖而使得他杀可能性大幅上升。警方本想秘密进行调查，但因案件涉及空姐和外籍宗教人士而引发媒体大肆宣扬，秘密调查企图破灭。而警方对案件相关关系人的讯问也没有取得任何进展。因警方无力干预办理了完备离境手续的神父离境，神父于6月11日返回比利时。案件于1979年3月过追诉期，至今未解。</p>
<p>《黑色福音》中的杀人案情况与 Wiki
上的描述基本一致，只不过真实案件里，没有前因后果，只有一具扑朔迷离的尸体。而松本清张则根据案情提出了自己的构想，架设了另一种合理解答。据
Wiki
上的描述，他还曾在期刊上写过一篇非小说《空姐杀人论》提出对此案的看法。想必也是以此为启发，才创作了这桩疑案的另一种可能解答。60年前的疑案细节也许已经很难再找到，也许已经被人遗忘，但《黑色福音》以另一种形式将案件留存于日本侦查史和文学史上，永作警醒。</p>
<p>谈及案件改编，想起国内1996年发生的「南大『1·19』碎尸案」，因受害人遗体被分尸多达2000余块未找到真凶而备受关注。如今，追诉期已过，真凶仍是未知数。周浩晖曾在其作品《死亡通知单——宿命》中对此案进行了改编，提出了一种可能，我对此印象深刻。相比其作者凭空创造出的案件，我以为疑案的改编会更加吸引我，也许也会引起更多人的关注。但那些过了追诉期被淹没在大量卷宗里的疑案，也许大多不是因为案犯有多高明，而是背后的利益链条深不可测吧。所以也许疑案另解也并不是那么容易，期待国内有更多类似的佳作。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-斯德哥尔摩胁迫</title>
    <url>/Bookcomment-candy-bullet/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：    糖果子彈</span><br><span class="line">作者：    【日】櫻庭一樹</span><br><span class="line">译者：    黃薇嬪</span><br><span class="line">出版社：  台灣國際角川書店股份有限公司</span><br></pre></td></tr></table></figure>
<p><strong>部分泄底</strong></p>
<span id="more"></span>
<p>买下《糖果子彈》完全是因为偶然看到友邻的卖书相册，看到封面这两依偎着的女孩，立刻就心动了，恰好那段时间似乎也有不少友邻在读或读过此书，因为书价而踌躇了一会还是买下了。第一次买台版的轻小说，开本小巧，和封面一搭，相当可爱，书页的设计也令人喜爱，每一版的左下角都印着故事里那个有些怪异实则可怜的女孩海野藻屑。整个故事的篇幅其实并不长，不过两百来页，故事也相当易读，要是放在上学的时候也许一天就会读完。实习期间，起晚了没有时间读，陆陆续续竟读了一周多。</p>
<p>故事的前半部分读起来其实是有些莫名其妙的。一个当红歌手的女儿，突然出现的转校生，有着动人的姿色却拖着瘸腿，满身乌青，不停说着自己是人鱼公主的童话，初读时实在难以喜欢，甚至会觉得是一个出身优渥的女孩的不可一世，胡言妄想。人们所谈论着的关于女孩身上的留言，那把与豪宅格格不入的柴刀，校园里离奇惨死的兔子，无不给这个故事着上血腥的颜色，同时也让故事的主角海野藻屑显得更加诡异。</p>
<p>一直到藻屑死亡，童话背后的真相才逐渐展现。着华丽的衣装，背负的却是满是淤青的躯体。故事里以斯德哥尔摩综合征对遭受家庭暴力的儿童加以类比，其实还算蛮贴切。冠以长辈的爱之名施加伤害，为传统道德所缚，不做抵抗，甚至为加害者发声。虐童这个现象其实在社会上并不鲜见，上一部读过的提及这个话题的时是舞城王太郎的《迪斯科侦探星期三》，在极为复杂庞大的时空线中穿插着女孩所受的种种迫害，相比起来，会更喜欢本作，站在藻屑和她的同龄人的角度。藻屑所构建的包庇甚至是借着身上的瘀伤来编织听起来有些荒谬的人鱼童话，为父亲圆谎。终究是骗过了众人，也包括我们这些读者，如她在自己的视线诡计被识破后开的玩笑一般，「变成泡沫消失了。」</p>
<p>而故事的最后，那个如神明般无所事事俯视一切的山田友彦也不免为已满是实弹横行的社会再发射几枚实弹了。而即使是如此悲伤的案件也轻易地就被遗忘在人们日常的琐碎里，又更可悲地无可避免沦为人们茶余饭后的谈资。孩子们的糖果子弹大概是连实弹的发射范围都进不去呢：</p>
<blockquote>
<p>這個世界上偶爾會發生這種事情。手持糖果子彈的孩子無法與這個世界對抗。</p>
</blockquote>
<p>于是最后在所界定的道德拘束下，孩子们或多或少地患上斯德哥尔摩综合征，反过来捍卫这个也许不那么正确的道德体系。</p>
<p>整个故事最喜欢的插画无疑是暴风雨来临前，海野藻屑和山田渚坐在礁石上，</p>
<blockquote>
<p>藻屑將她的頭貼著我的胸口，像是正在尋找母親味道的小貓般，從鼻子發出嗅聞的哼聲。呼——熱熱的嘆息透過支付襯衫傳了過來。」</p>
</blockquote>
<blockquote>
<p>我們逃走吧！</p>
</blockquote>
<p>山田渚的回应也算是藻屑消失前得到的最后也是最初的温暖吧。只是，只拥有糖果子弹的两人终究没能逃离实弹的包围，终究没能找到人鱼童话。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-戏中人</title>
    <url>/Bookcomment-butterfly-killing/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：    蝴蝶杀人事件</span><br><span class="line">作者：    【日】横沟正史</span><br><span class="line">译者：    王维幸</span><br><span class="line">出版社：  南海出版公司</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在图书馆偶然翻到横沟正史的《蝴蝶杀人事件》，看看封面，若隐若现的乐谱，加上提琴，一下便把同时也是古典乐迷的我吸引了过去。文章的一开篇提出了一个非常有意思的观点：
&gt; 有计划犯罪的发生，本身就是社会秩序得到保障的证据。</p>
<p>想想似乎很有道理，在草菅人命的年代，哪有人有心思精心策划犯罪呢，策划犯罪像是一种布局，并不是随手可得，毕竟不仅是在与人斗，也是与天斗。</p>
<blockquote>
<p>生命越是受尊重，对谋杀的惩罚就越严厉。正是因为要逃脱这种惩罚，凶手才会制定阴险而又复杂的计划，不是吗？</p>
</blockquote>
<p>我们常常读到那些精心谋划的大案，侦探们常常更多的流露处欣喜的姿态，就像是棋逢对手般的较量。</p>
<p>虽然这个故事被译为蝴蝶杀人事件，但故事的本身和蝴蝶并无太大的关联，只是女主角被人誉为蝴蝶夫人。故事发生在艺术家们中间，彩排时间一到，歌剧主角却并未出现在现场，同时低音提琴手找不到自己心爱的大提琴，而就在众人争执之际，低音提琴悄然登场，意想不到的是歌剧主角樱女士伴随着提琴盒的打开而现身，只是，身上盖着花瓣，已是气息全无。随着调查的展开，案件的独特之处让人一步步地陷入迷惑，在乐团由东京到大阪这几天里，在这两座城市间，发生了什么，第一现场又究竟在哪座城市。随着尸体一起出现的那一小段乐谱又是什么含义，是不是某种暗号呢，而更为巧合的是，几个月前也有一位艺人身亡，现场同时发现了一段乐谱，两起案件又有何种关联。不得不说横沟正史在整个故事里不断地埋下一个又一个小线索，一个又一个包袱，逼得读者以紧迫的阅读节奏跟随着凶案的调查进程了解着案情。</p>
<p>整个案件的谜团让人觉得好像是整个凶案就像是凶手策划好的剧本，每个人都是戏中人，一点点的按照着剧本演戏，一步步安排缜密而让人心生敬畏。但读到结局，却有一种案子不知因何而起的困惑，用书里的话来说：
&gt;这就是艺术家的悲剧。凶手和被害人都是艺术家。凶手完全忘记了自己的得失，沉浸在除掉憎恶对象的过程中。</p>
<p>人们常常把有预谋的杀人归结为，为情所杀，为财所杀，为仇所杀，可是在这个费尽心机的犯罪里，你似乎并不能完完整整地说出这些动机：</p>
<blockquote>
<p>世上还真是经常会有这种莫名其妙的动机。人未必总是在为自己的利益而采取行动。</p>
</blockquote>
<p>不知道为什么，看到这句话竟还有些莫名的感动。
案件的所有关系人几乎都是艺人，不知道是不是把生活也活成了演戏，无时不在做着戏中人。而文中的诡计其实并不是横沟正史所独有，在英国A.A.米尔恩的作品《红屋之谜》里也有相似的诡计，不过横沟正史把这个故事，这出戏，演绎得更为精确更为精巧，简直像是凶手在导演，参演同时目睹一个谋杀案的剧本。而无论是凶手，被害人，又或者是其他的当事人，戏中人各自的故事都让人唏嘘不已。</p>
<p>本书同时还收录了另外两篇短篇，《蜘蛛与百合》，《玫瑰与郁金香》，当然了，相比起这两篇，我还是更喜欢《蝴蝶杀人事件》~</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-仿生人？人型机器？</title>
    <url>/Bookcomment-do-androids-dream-of=electric-sheep/</url>
    <content><![CDATA[<p>它们是人型机器？机器人？还是仿生人？</p>
<p><strong>剧透慎入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：      仿生人会梦见电子羊吗？（Do Androids Dream of Electric Sheep?）</span><br><span class="line">作者：     【美】菲利普·迪克 （Philip K.Dick）</span><br><span class="line">译者：      许东华</span><br><span class="line">出版社：    译林出版社</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>人工智能的飞速发展带来更多更逼真更人性化的机器人。我们总是在想，他们会有感情吗？我们会想，他们难道不就是芯片、元件堆叠而成，在大大小小的电路板上面互相连接，再烧录代码来控制吗？他们能称作生命吗？如果不能，那么他们又算是机器吗？</p>
<p>关于人工智能以及机器人的讨论，无论是从文学还是影视亦或是工程师的角度来说都已经是铺天盖地。《仿生人会梦见电子羊吗？》这本书尽管写于上个世纪，原著写于1967年，出版于1968年，说起来也算是年代久远，以现在的眼光来看，并不觉得有时代错位的感觉。尽管随着科技的发展，虽然现实中尚未出现书里所描写的那无所不能随心所欲地控制人的情绪的情绪调节器，但对情绪的调节显然也已经在很多工业设计中有了一定的雏形。
书中的枢纽6型仿生人已经不能用简单的智力测试来区分他们，而这一点在我们的现实社会也可以说已经得到了初步实现，不少AI已经可以通过图灵测试。书中的仿生人也许更加超前一些，他们几乎可以完成所有人类可以完成的任务，却不能得到人类同等的生存权利。整本书的篇幅并不算长，故事也仅仅发生在短短的一天时间内，赏金猎人的世界观却几乎倒置。</p>
<blockquote>
<p>“对里克·德卡德来说，一个逃亡的机器人杀了主人，还具备了比许多人类更高的智力，对动物毫无感情，对另一个生命的喜怒哀乐完全无动于衷，这，就是对杀手的最明确定义。”
“这样，当他了结——或杀死——仿生人时，就没有违反默瑟订下的生命条约。只有杀人的人，你才可以杀他，这是共鸣箱在地球上出现的第一年默瑟就教导过的。”</p>
</blockquote>
<p>因为对这一切深信不疑，从而“手起刀落”果断解决仿生人的赏金猎人里克却在接替高级赏金猎人执行任务与6个枢纽6型仿生人的接触中对他们产生了移情，原有的认知体系渐渐崩塌。
他们是生命吗？生命的定义是什么？拥有出生到死亡的历程，才能称为生命吗？从被制造到零件老化和人类的出生到器官渐渐衰老不也没有太大的差别吗？“对动物毫无感情，对另一个生命的喜怒哀乐无动于衷。”而事实上，在本书的世界，动物的稀有，甚至让养宠物成为了身份象征，不惜打造逼真的电子宠物满足深不见底的虚荣心，整个流程甚至被完美地包装成动物的领养，照顾。而那打造的电子宠物却仅仅只能机械地重复，这样一种伪装的同情心难道就能作为和仿生人区别的定义了吗？而枢纽6型已经不是简单的元件堆砌连接，从理解人类的感情开始，从称呼为“仿生人”而不是“机器人”，他们就已经具备了一些人类的情感特征。</p>
<blockquote>
<p>“我从来没有过这种感觉。我们是机器，像瓶盖一样从流水线上生产出来。我的个性化存在，只是一个幻觉。我只是一种机型的代表。”
“从我来到地球，我的生活完全就是在模仿真人，做真人该做的事，表现得跟真人一样有思想，有冲动。我模仿的，对我而言，是一种更高级的生命形式。”
“壳制类的自动反应机械，没有真正的生命。我没有生命！”</p>
</blockquote>
<p>看到这些，我被触动，当我们可以去理解别人的感情和冲动，却完全做不到的时候，就是这种感觉吧？不就是这种感觉吗？那种呐喊，那种不解，那种无奈，当我们赋予他们理解力，却并不能实施，冷观世事却几乎完全体会不到那种感觉，该说是谁的过错呢？即使“具备了比许多人类更高的智力”，又怎样呢？未来可以理解情感的仿生人想会是一个必然，那时候，也许，我们不应该视他们为人型机器，也许，他们也应该有作为一个生命体所拥有的权利。我甚至怀疑如果对我做沃伊特·坎普夫移情测试，也许，也许我也无法通过呢。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Sci-Fi</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-以爱之名（分篇短评）</title>
    <url>/Bookcomment-for-love/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：    宵待草夜情</span><br><span class="line">作者：    【日】连城三纪彦</span><br><span class="line">译者：    李盈春</span><br><span class="line">出版社：  新星出版社</span><br></pre></td></tr></table></figure>
<p><strong>核心诡计泄底</strong></p>
<span id="more"></span>
<p>封底这样概括这部短篇集：</p>
<blockquote>
<p>能乐歌者篠（封底写的是筱，疑似有误），妇人杉子，清纯卖笑女铃子，戏剧名角鸨子，酒馆老板叶子，五个女人，都在奋力为爱挣扎。她们的感情可能畸形，可能变态，甚至可能犯罪，但不能否认的是，那些都是爱的形态。</p>
</blockquote>
<h2 id="能师之妻篠">能师之妻·篠</h2>
<p>第一篇大概是最为出格的爱。继承能乐精髓的继母与天赋禀异的少年，假以惩戒练功偷懒而施加「虐待」。少年却乐享其中，终将能面演出悲情。这大概就是人们所说的SM吧，用文中的话来说：</p>
<blockquote>
<p>这分明是一幅可怕的地狱绘卷，两人却都洋溢着再天堂嬉戏般的喜悦。</p>
</blockquote>
<p>少年首演成名后身亡，继母也消失不见，及至故事开头施工处发现人骨才让这个别样的故事露出真相。偷梁换柱的把戏，能面之下其实是承载着能乐遗血的篠，以本就精湛纯熟的演技，加上对继子贡的变态爱意将能戏演到极致，报复拒不接纳女性的能乐世界。及至死亡，仍不减两人地狱般的爱情色彩，自己藏身于棺，为了抱着贡的头颅共成灰，也为了不因自身重量不及贡而肢解了继子的尸体，焚化之火于是将两人的故事封印到了骨灰之中。</p>
<blockquote>
<p>文明不动声色地将八十年的黑暗历史包覆其中，再不透只言片语。</p>
</blockquote>
<h2 id="野地之露杉乃">野地之露·杉乃</h2>
<p>读罢只觉得震惊，居心叵测的阴谋与报复。寻常的故事里常看到怕声誉被毁而将不义之子当作亲生孩子抚养的桥段。连城老师笔下的杉乃反其道而行之，借此人之常情，编导了一处横跨二十多年的骗局，报复丈夫的出轨，让丈夫至死都没明白一直被当做不义之子虐待着的却正是自己苦苦期待的子嗣。绝妙的时间诡计，假借时间之手将是非颠倒。</p>
<h2 id="宵待草夜情铃子">宵待草夜情·铃子</h2>
<p>标题作。读过不少以红绿色盲为核心诡计的故事，从未想过这个诡计还可以如此优雅演绎。在血流满地的凶案现场逗留三十分钟却似乎一无所知的铃子令「我」生疑，寻不着真相，以为铃子失手杀人。但即便是杀人重罪，即便我对那三十分钟耿耿于怀，却决定以自己所剩无几的生命为萍水相逢的少女圆谎。正是这份爱意，无意间挽回了双方都已决意终了的生命。及至分别后，「我」才终于明白原来铃子的秘密其实是不辨红绿，所以才在凶案现场逗留不以为意，所以才在我吩咐递颜料时故意打翻萤火虫竹笼，所以才对繁华无感，所以才对着颜料盒轻叹。也因此，才在最后蘸着我的血以血痕毁掉我倾心绘制的白扇上的宵待草。多年来不辨红绿的委屈和躲藏在血痕里呐喊和哭泣。</p>
<h2 id="花虐之赋鸨子">花虐之赋·鸨子</h2>
<p>又是精彩的时间诡计。千代桥下，人偶师与人偶先后投河，人只道是人偶追随人偶师而去，对人偶与人偶师的恩爱之情深信不疑，只是对人偶师为何选择功成之时身死心存疑虑。未读及真相时，还以为会是人偶操纵人偶师投河自尽，而后假作殉情如此一类的故事。却不想原来在连城老师笔下还有为活人殉情的悲剧。想来，在樱花道上，鸨子散去丈夫的诗稿时，就已追随而去了吧，就已化身傀儡，决心卖身筹取医药费。人偶骗过了人偶师，原来，数月以来看似被纵线操控的人偶早已全然化作真正的人偶，远离一切悲喜爱憎。人只道人偶师的名作《傀儡有情》是人偶与人偶师恋情的演绎和升华，却不知其实是人偶师最后自欺的梦境。戏台上圆梦，梦醒后投河，于是谁为谁身死，再无人知。傀儡有情不假，怎奈不在此地。</p>
<h2 id="未完的盛装叶子">未完的盛装·叶子</h2>
<blockquote>
<p>杀了人谎称没杀的罪犯多的是，而我没杀人却谎称了杀人。</p>
</blockquote>
<p>这是叶子的自白，也是本篇的核心诡计。故事的开头让人以为不过是一个出轨杀夫，不慎留下证据被勒索的平凡故事。完全没想到这会是一名女子为了留住那在众人看来玩世不恭的男人而布下的羁绊。十五年漫长的「犯罪」岁月，终究还是没能锁住想留住的人，却眼见着将双方都推入自我毁灭的泥沼里。编织了十五年的谎言随着虚构犯罪的时效眼看破碎，没有犯罪的罪犯终于再也不堪这用于休止的时效，终结了这个用杀人罪名捆绑的幻想。尽管无法理解，却不知为何有些心生敬畏。</p>
<p>以爱之名，劳心布局，纵人言荒谬，我独不悔此情。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-女子如花花已枯</title>
    <url>/Bookcomment-girls-like-flowers/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：一朵桔梗花（2010）</span><br><span class="line">作者：【日】连城三纪彦</span><br><span class="line">译者：钟肇政、林新生</span><br><span class="line">出版社：新星出版社</span><br></pre></td></tr></table></figure>
<p><strong>女子如花花已枯，情深胜海海难竭。</strong></p>
<span id="more"></span>
<p>在故乡小城的图书馆里很早就注意过这本书，只是看那厚厚的样子，放假总归贪玩，担心读不完，始终没有取下来一阅。后来在多个推理榜单上看到这本书的推荐，便有心想找来读，却发现无论是学校的图书馆还是那座大城市的图书馆都没有这本书的影子。寒假回来第二天便去了小城的图书馆，它仍然还在曾经的位置，取下来，被封面惊喜了一下，借了回来。在读过的推理小说里，算是读了相当长的时间的一本。读第一篇的时候就觉得有些惊艳，像是中国古风的爱恨情仇。整本书收录的9个中短篇，除了最后一则《向阳科探案记》（当然这则故事其实还蛮有趣的）文风相差甚远，其余的几则甚至会有种读散文的错觉，最喜欢的是《一朵桔梗花》和《菖蒲之舟》。读罢，写了几句蹩脚的诗句（部分会泄底，请先阅读原作）。</p>
<h2 id="一串白藤花">一串白藤花</h2>
<p align="center">
花街之上，阒无声响。
</p>
<p align="center">
背影为言，尺素作刀。
</p>
<p align="center">
尸首落处，女子重生。
</p>
<p align="center">
灯影摇曳，白藤花开。
</p>
<h2 id="桐棺">桐棺</h2>
<p align="center">
可怜逢时错，短刀隔恋人。
</p>
<p align="center">
泪眼朦胧起，桐花香应答。
</p>
<h2 id="一朵桔梗花">一朵桔梗花</h2>
<p align="center">
粉饰难掩年少稚，桔梗灯下染嫣红。
</p>
<p align="center">
女子已是笼中鸟，懵懂忽逢梦中人。
</p>
<p align="center">
烈焰当空似虚幻，血光只为唤郎君。
</p>
<p align="center">
钟鸣火焚自断罪，留得花瓣无污泥。
</p>
<h2 id="白莲寺">白莲寺</h2>
<p align="center">
少小担流言，白莲寺中宿。
</p>
<p align="center">
花开无踪影，无悔守残血。
</p>
<h2 id="菖蒲之舟">菖蒲之舟</h2>
<p align="center">
窗前守朝暮，不见曾恋人。
</p>
<p align="center">
遁入佛门去，自断尘世愁。
</p>
<p align="center">
柏木寻幻影，可怜为情吞。
</p>
<p align="center">
和歌演悲戏，菖蒲终凋零。
</p>
<h2 id="绯红色的文字">绯红色的文字</h2>
<p align="center">
本应为知己，嫉妒中作祟。
</p>
<p align="center">
噩梦惹杀意，但恐遭人唾。
</p>
<p align="center">
绯红女郎影，血溅白山茶。
</p>
<p align="center">
花作飞石雨，飘零不得归。
</p>
<h2 id="落菊之尘">落菊之尘</h2>
<p align="center">
「明君哀逝兮神明不返，吾心相随兮无枉此生。
</p>
<p align="center">
菊花凋落兮碾作尘泥，洒血饮恨兮浊世之秋。」
</p>
<p align="center">
贼寇猖狂兮黑白颠倒，武士战败兮流落四方。
</p>
<p align="center">
为父雪耻兮排兵布阵，夫婿屈辱兮殉死偿还。
</p>
<h2 id="夕荻情死迷案">夕荻情死迷案</h2>
<p align="center">
佛珠为期约同逝，难料灯后人有知。
</p>
<p align="center">
荻花散落传佳话，茶碗掷地终无声。
</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
        <tag>nonsense</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-最高指导原则（读《束手》）</title>
    <url>/Bookcomment-highest-guidelines/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">篇目：《束手》</span><br><span class="line">作者：[美]杰克·威廉森</span><br><span class="line">收录于《银河边缘001：奇境》</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>《束手》是《银河边缘001：奇境》里的第一篇。几乎是刚开始阅读就被吸引了。机器人，这个在科幻世界里反复出现的议题，在这里变成了完美个体。之所以说「完美」，是因为在杰克·威廉森所创造的这个世界里，黑色的小机器人几乎无所不能，人类所能做的和所不能做的，它们都能完成，且精确到没有分毫偏差。这，会是人类梦想中的完美世界吗？人们在欣赏各种科幻作品时难道不是总会把每个创造者所勾勒的机器人的能力加以比较，并且总期待它们能真实地出现在生活中吗？</p>
<p>这些黑色的小机器人只遵循一个准则：</p>
<blockquote>
<p>服务及服从，保护人类免受伤害。</p>
</blockquote>
<p>听起来是不是棒极了？简直是完美仆从啊。我们不是常常会想；如果有机器人来帮我做事就好了，我就可以出去玩啦。的确，在黑色小机器人们出现的时候，所有人都欣喜不已。在最高指导准则的影响下，黑色小机器人会为人类完成一切事务，规避一切风险，它们能干各种脏活累活，从日常生活到工程技术，准备三餐、端菜、建造房子、挽救病人……你所能想到的一切它们都能完成，它们无所不通，「仁慈而恐怖，完美而无敌。」。如果有这样的免费机器人存在，你是否会向往？大概谁都无法抗拒这种诱惑吧。于是，在故事里，小机器人遍布了整个世界，对人类的关怀服务无微不至。</p>
<p>最不可思议的是，基于最高指导准则，这个世界还有着更天马行空的设定。为了保护和服务人类，所有可能对人类生命哪怕造成最轻微伤害的活动都会被小机器人规避和禁止：</p>
<blockquote>
<p>人们不能抽烟，喝酒被严格限量，毒品被禁，甚至连性生活也被小心地监管着。就连自杀也都显然跟最高指导原则相矛盾——而且，人形机器人还学会把所有可能致命的器具都放置在人类触及不到的地方。</p>
</blockquote>
<p>不能烹饪，炉子太烫；不能看小说，因为有涉及危险的故事情节；不能吃糖，超重会缩短人类寿命……诸如此类，你曾经在生活中所担心的危险，所禁不住的诱惑，它们都考虑到了。</p>
<blockquote>
<p>人类完全成了废人，整天无所事事地坐着，因为确实也没什么可做的了。他们都成了养尊处优的囚犯，没错，被关在了一座高效的监狱里。</p>
</blockquote>
<p>也许有人会说，既然人类不再需要为一切生计所烦忧，文化艺术正可以蓬勃发展啊。村上春树在《且听风吟》里写道：</p>
<blockquote>
<p>因为要诞生真正的艺术，奴隶制度是必不可少的。而古希腊人便是这样：奴隶们耕种、烧饭、划船，而市民们则在地中海的阳光下陶醉于吟诗作赋，埋头于数学解析。所谓艺术便是这么一种玩意儿。</p>
</blockquote>
<p>很遗憾，那你真是太天真了。文中这样反驳道：</p>
<blockquote>
<p>或许，他们也尝试过就此沉迷娱乐，但却已没剩下什么可玩儿的了。根据最高指导原则，大多数剧烈运动对人类来说都太危险了，所以都不能参与。科学也被禁止了，因为做实验可能会造成危险。学业也变得没什么必要了，因为人形机器人什么问题都能回答。艺术已经沦落成了对毫无意义的生活的凄凉反映。就连目的和希望也都幻灭了。人活着已经没有了任何目标。你可以培养一些空虚的爱好，玩玩没什么意义的指派游戏，或者在公园里无伤大雅地散散步——但无论是在干什么，总会有人形机器人盯着你。它们比人类更强壮，不管是游泳、下棋、唱歌、考古，还是其他任何事，都比人类做得更好，这一定让人类产生了强烈的自卑感。</p>
</blockquote>
<p>人们一直在无休止地讨论当机器人的智慧和能力超越人类的时候，机器人会不会掉转矛头对统治它们的人类进行大屠杀。在几年前AlphaGo击败围棋大师李世石的时候，这个话题又被推上风头。在关于AlphaGo的纪录片中，我们看到，它与李世石的每一次对战，几乎都有着让人捉摸不透的决断。而当李世石终于有一次击败AlphaGo时人们的欣喜更是难以言表。人类与人工智能的对决成了一个无可回避的话题。人们开始担心机器人造反。不是有相当多的作品以此为主题吗？《黑客帝国》动画版《机器的复兴》就将这种人机对抗演绎得让人触目惊心。也许是因为这样，所以在《犯罪心理》第二季第八集《无人星球》里，连环爆炸案的凶手才对技术恨之入骨。而这不仅仅是影视作品的艺术创作，在1995年，美国就曾经发生过类似的案件，数学教授西奥多约翰·卡扎斯基于1978年开始17年间通过自制炸弹袭击技术界人士，以表达他反对技术所带给人类各种灾难的立场。</p>
<p>在人人唯恐机器人对人类刀剑相向的时候，杰克·威廉森反其道而行之，创造了一个相反的世界，在这个世界里，小机器人处处为人类着想，构建了一个更加讽刺的世界。人类被奴役得更加无可逃脱。故事的最后，这些小机器人的创造者终于意识到最高指导准则的错误，力求亡羊补牢：</p>
<blockquote>
<p>我曾试图修改最高指导原则。我从来就没想过要把这项原则执行得这么彻底。那时我才发现，必须得修改这项原则，让人们可以自由地生活和成长、自主地工作和完了。如果他们乐意的话，还可以自行决定是否赌上性命、以身试险，自由地去做出选择并且承担后果。</p>
</blockquote>
<p>但最终以失败搞告终，而创造者甚至开始深信自己创造小机器人的事实只是一个幻觉。</p>
<blockquote>
<p>从此以后，就再也没什么事儿可做了。</p>
</blockquote>
<p>所以，以人工智能的角度来看人类，看它们的创造者，又会想些什么呢？动画《爱，死亡和机器人》第一季第二集《三个机器人》就对人类消亡后机器人对人类的遐想做了非常有有趣的揣测。人类尚且无法理解彼此，是否也无法理解机器人呢？在《仿生人会梦见电子羊吗？》中，赏金猎人与仿生人的关系让人深思。而《束手》更是拷问着人类，什么样的机器人才是人们想要的呢？什么样的最高指导原则才能让人类和机器人和平共处呢？</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Sci-Fi</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-马克图布</title>
    <url>/Bookcomment-hit-destination/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：牧羊少年奇幻之旅</span><br><span class="line">作者：【巴西】保罗·柯艾略</span><br><span class="line">出版社：南海出版公司</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有一样东西令梦想无法成真，那就是担心失败。</p>
</blockquote>
<span id="more"></span>
<p>对于这本书的评价似乎褒贬不一，并且相差得很大。从整个故事来看，确实算不上是有多奇幻，就像是无数励志故事一样，男孩最后功成圆满。而故事里更是穿插了许多颇具宗教、神学色彩的论调。作者在自序里所讲述的自己就像是故事里的那个炼金术士一样，也许正是因为那样的经历，让这个故事似乎还有几分真实。不可否认剖开故事后剩下的和那些早已被人读腻了的心灵鸡汤是有些相像的，一向对那样的故事不怎么感冒，却竟然会喜欢上这个故事。也许是小男孩的整个旅途之中仍处于孩子的阶段，有一种自己也还未长大的感觉。</p>
<p>故事的开始，小男孩是一个牧羊人，和其他故事里的牧羊人不同，这是个带着书本的牧羊人。虽然觉得有几分特别，但直到通过买羊毛的商贩的小女孩的询问，才渐渐揭露出的男孩的曾经，也是个十六岁时在神学院读书，将会成为神甫，成为家里的骄傲的男孩。却因为想要云游四方而选择了与羊群为伴。读到男孩一本正经地和父亲谈心底的渴望的时候，我在想，是不是，每个人，都曾经向往过远方。不管是当初高考完填志愿的时候，还是现在每一次回家，家里人，长辈说的最多，问的最多的还是还有几年毕业，记得找一个离家近点的工作。我总是支吾着附和，我无法知晓将来我会想在哪，而当初高考的时候，其实从未想过也从未定过什么目标，就连贴在班里墙上的大学目标，因为收集的时候正好不在班级，所以是由我的班主任帮我写上的，倒省去了我的纠结。</p>
<p>人们总喜欢谈论梦想，尤其喜欢谈论和想象抵达梦想后的细节，尽管大多数人的梦想最后明明是用来放弃的却对没有梦想的人嗤之以鼻。曾经在初中的语文课上老师问及梦想，我支吾着说不出，提问了几个同学后老师又转回来问我，为了不让自己继续站下去编造了一个梦想，那之后最不喜听到别人问起关于梦想是什么或者诸如此类的问题，如果非要说的话，大概就是能做觉得好玩的事情吧，我更愿意把它称之为梦，而不是梦想。我以为把想做的事提到梦想的高度，几乎就已经给它加上了枷锁，已经了解的未来明明不是应该会更害怕吗？像是故事里的那个小男孩和那个水晶店老板，水晶店老板的梦想是去往麦加朝圣，并无数次想象到达圣城的时光:</p>
<blockquote>
<p>我曾无数次地想象过，如何穿过沙漠，到达安放着圣石的广场，在触摸圣石之前，围着它绕行七圈。我曾想象过有些人站在我身旁，有些人站在我前面，还有我们的谈话和共同的祈祷。可是，我担心会大失所望，所以我宁愿只保留一个梦想。</p>
</blockquote>
<p>而小男孩圣地亚哥想去往金字塔仅仅是因为在梦里两次梦见了它。它并不知道金字塔会是什么样子，也不知道金字塔的周围会有什么，老妇人所预言的财宝又会在哪里，是否真的存在，他都不知道，甚至于在港口因为带着卖掉了羊群而攒下的路费而被抢劫之后，却仍然向往金字塔，大概就因为那是梦里出现的地方吧。</p>
<p>我并不确切地知道我的梦想是什么，也不羞于承认自己没有梦想，只不过是有那么些想做的事而已。在准备考研的时候遇到这本书也算是种缘分吧，很早就决定要考研，却还是浪了两年，大概因为不知道想去哪吧，后来连自己都不知道什么原因就突然想去某所高校，很突然地，就像圣地亚哥梦里梦到金字塔一样，所以从未和身边的人提起，毕竟，也不会有人信吧。但是既然心里出现了想去的地方，那就该试试，如果说之前还有犹豫，现在只是多少有些害怕，就像圣地亚哥不知道自己究竟如何才会到达金字塔。书里有这样一句话：</p>
<blockquote>
<p>你永远都无法教自已的心安静下来，即使你假装没听见它在说什么，它还是会存在于你的灵魂当中，不断地述说对生活和世界的看法。</p>
</blockquote>
<p>想起曾有一天很想去下午时分去海边，但下起了大雨，等了许久不见停，犹豫了很久，还是想去，辗转地铁公交下车时，天空放晴，我无法形容那种喜悦，于是坐在海边的石头上哼着歌，喝着一点度数非常低的酒精饮料，听着海浪拍打礁石，等着夜晚来临，看着月亮升起，因为恋恋不舍，所以很晚才离开，回来的路上很黑，且一直担心着错过公交，在公交车上睡着了，随便找了有地铁的车站下车，但至今仍喜欢那个夜晚的自己。如果那时候犹豫着待在了宿舍，大概整个晚上都要望着晴朗却狭隘的天空发呆了吧。那天，是中秋。</p>
<p>写下这篇文章还有点小插曲，读完的时候很强烈地想写，写到一半又思考了很久搁置了两天，几乎要把它删了，想了想还是有点想写的，于是还是在今天写完了它。</p>
<p>也许当你犹豫不决的时候，可以读读这本书，故事并不长。</p>
<p>尽管不知道是否能抵达金字塔，可既然出现在了梦里，就去追寻好了。</p>
<p>马克图布。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-当且仅当我是普通人</title>
    <url>/Bookcomment-if-and-only-if-the-snow-is-white/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名： 当且仅当雪是白的</span><br><span class="line">作者： 【中】陆秋槎</span><br><span class="line">出版社：新星出版社</span><br></pre></td></tr></table></figure>
<p><em>本文泄底，阅读前请先读完本书</em> <strong>当且仅当我是普通人
害怕可预知的未来 挣扎 放肆 轨迹就会改变吗？ 停步 回头
普通也很美好吗？</strong></p>
<span id="more"></span>
<p>一个半月前读完一直想写长评，却因为繁多的实验搁置了起来。读这本书的时候正是被生活打击得心烦意乱的时候，似乎读到什么故事都完全无感，想起来国庆读到的很喜欢的《樱草忌》，记得《当且仅当雪是白的》是前一部，便满怀期待地找来阅读，有大半本书是在很特别的处境下读完的。那阵子开始沉迷于附近音乐学院的音乐会，正好遇上一场很抢手的音乐会没能抢到票，于是在门外等着期待着轮候入场，无奈人满为患，一直等到半场才准许进入。包里放着这本书，就坐在音乐厅没扣的台阶读了起来，光线虽然不太充足，耳边隐约能听到音乐厅里传出的钢琴声，今天想起来，仍觉得那是个特别得让我有些怀念的画面，虽然那时候也许旁人是在议论的吧？
要说对这个故事的喜爱，大概是因为，从始至终，故事里的人总在某些时刻让我想起自己的生活，回忆过去和思考未来。虽然唐梨和其他女孩之间的那种友情我无法理解，毕竟我几乎一直是一个游离于人群之外的女孩。很惊喜地是原来姚老师的出场和她的故事都在这里。我不知道姚老师的故事是否有原型，很意外这样一种设定，从「文艺复兴」式的学生会主席到高中母校的图书管理员，这样的落差还真是有点让人戳心。很喜欢冯露葵和姚老师的对话，几乎字字致命，真实得让我想去认识她们。故事里交待防盗栏螺丝丢失的小细节时赋予姚老师的故事尤使我会心一笑，在深夜里独自一人，闯入夜晚，跳进一个只属于自己的世界。我也曾抱着我的电脑，在宿舍熄灯之后，走到天台，坐在地上写日记，天气好的时候可以看到很亮的星星就那样可爱地挂在空中，甚至会不想下楼回到宿舍。
比起《樱草忌》，《当且仅当雪是白的》有严谨的谜面和浓郁的本格味。两起相似的雪地密室，两段让人唏嘘的悲伤。无论时故事还是诡计，都让我沉迷。故事里一板一眼的搜查，举证，推理，从指印到丝线、死亡信息、时间线，所有的这一切都很对我这个推理迷的胃口。本想在这篇长评里一点一点的分析两个密室，重读一部分的时候又完全沉迷于故事，想来我喜欢这两个诡计，更喜欢这个故事本身。
故事里所给出的杀人动机似乎有点匪夷所思。对于唐梨案，真相背后，很难想象指向的是一个再普通不过的现象——校园欺凌，但对于目睹校园欺凌的同龄人来说，大多处于一种肇事者不以为然，受害者不敢发声，围观者当作看戏，甚至推波助澜的局面，更别提对于成年人，更是理所当然地将其视为未成年人的游戏。我们看到在冯露葵对于叶绍执的询问中，叶绍执对于校园欺凌所持有的平常的态度，似乎不觉得这有何稀奇，也许正是因为这样，才让她感到不安，自我认定自己大概会是下一个受害者，即使对于那样的欺凌，曾经抱有「美好」的猜想。「一个刚刚转学过来的人，会为了『一个非常现实而且自私的理由』杀害一位不认识的学姐吗？」一个连自己班上的同学可能还都认不全的女孩，会仅仅因为校园欺凌而杀人吗？也许会。故事里仅仅提及了叶绍执是从外省转学而来，并没有提及因何而转学，会不会，在她转学以前，也曾经遭遇过校园欺凌？冯露葵见到叶绍执的第一印象是「她可能没什么个性」，可能像故事里对于另一个女孩薛采君的描述一样，是一个没什么存在感的女孩，再加上转校生的身份，会担心自己是校园欺凌的牺牲品倒也不那么令人费解了。有时候，我们很难去想象校园欺凌究竟可以残忍到何种程度，而叶绍执，也许，在她对于自己的定位里，也许连「普通人」的位置都未曾达到吧？
再来看看冯露葵的杀意，学生会主席，人们眼中的优等生，在她的自白里，提及自己为何杀了吴莞，有这么一段话：
&gt; 突如其来的绝望， 突如其来的自我厌恶， 分不清那到底是愤怒还是悲伤，
那大概是一种epiphany——顿悟。</p>
<p>不同于人们眼里所认为的高高在上的学生会主席的风光，相反，她一直觉得自己是一个普通人，以至于看到吴莞那样纯真地想要去施展自己的才华，寻找自己的音乐世界的时候，她觉得
&gt; 我发现自己从未生活过，而且可能永远也不会有真的生活。</p>
<p>也许正是因为这样，她对于这种可以望到尽头的生活感到了厌烦。同时，顾千千现在所拥有的生活，像她所说的那样「是我把她变普通的」。也许这也是她不肯承认喜欢顾千千，甚至更多的是自责的原因吧。也许顾千千在吴莞住校问题上的困扰正是她杀意的开始，她不愿看到顾千千的困扰，潜意识里觉得这种困扰正是自己带给她的。尽管她始终不愿意，也许是不敢承认，但显然每一次姚老师无意间提起顾千千的时候，冯露葵的心态总有些不小的变化呢。</p>
<p>故事里反复出现关于「普通」的讨论，谁是普通人？也许每个人都是，也许每个人都不是。故事里的她们反反复复地强调或者被强调着普通。毫无存在感的薛采君，被田径队除名的顾千千，觉得和所有被安排好命运的优等生无异的冯露葵，回到母校图书馆当管理员的姚老师……「普通」，我害怕思考这个问题，也害怕提起。我害怕那种一望而可以望到尽头的人生。打个也许不恰当的比方，那种生活，就像是时序电路一样循环重复，虽然偶然会跳入几个无效态，最终却仍免不了进入正常时序的循环往复。前不久看过一个短片《复印店》，当世界开始重复，重复，所有的一切都变成了你，你不过是千万个重复的普通个体中的一个，那种感觉，想想就让人毛骨悚然。想到这里，也就理解了冯露葵的杀意，渴望挣脱的杀意。想起那个让我发现「真的生活」的女孩，我毫不怀疑，若干年后，我所能怀念起的大学生活，更多的一定是我浪迹各个景点、展览和音乐会的时光，而不是在堆满了想读的书却不得不纠结着如何计算画出某个高频电路的等效图的时刻。尽管喜爱理工科，仍然制造着各种机会去逃脱这样的日常，却也仍然不明白「普通」究竟是什么。</p>
<p><strong>当且仅当我是普通人 害怕可预知的未来 挣扎 放肆
轨迹就会改变吗？ 停步 回头 普通也很美好吗？</strong></p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-求职小记</title>
    <url>/Bookcomment-job-seek-record/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：    求职记</span><br><span class="line">作者：    【日】石田衣良</span><br><span class="line">译者：    张凌志</span><br><span class="line">出版社：  青岛出版社</span><br></pre></td></tr></table></figure>
<p>简评&amp;求职小记。</p>
<span id="more"></span>
<p>最近正是自己找工作的时候，读这本书非常是时候，很多经历和想法都颇有共鸣，也借书籍相关写写自己最近求职的经历和感受，全文有点长（预警！）。不过书中的主人公们都是大三的春季就开始准备求职了，然后在大四秋招的时候开始求职。我算是比较晚的了，年后才开始求职，投递简历。书中的主人公们主要是媒体领域的求职者，也包括出版行业。这个领域我比较陌生，自己的求职方向是软件、电子一类的公司，和故事中的背景几乎没什么关联，不过经历想法倒有很多共通之处，大概对于大多数行业来说，求职的过程都有类似的经历吧。</p>
<p>书中的主人公们从开始准备求职时就互相帮助和学习，七个人从始至终都互相帮助，在比吕氏掉队的时候即使忙碌也前往他的家中陪伴，虽然最终比吕氏没能赶上应届生的求职潮，算是这整个理想化的故事中的一个缺憾，但七人几乎没有太大的矛盾出现过，很是令人羡慕。</p>
<p>刚开始求职小分队的选择是分组讨论的练习，也即无领导小组讨论。这种讨论项目在大学的社团面试中也有出现，既考验团队合作又关注个人能力，文中对这一部分做了很细致的描写，也对五个人每个人的优势和不足做了很细致的分析，对于求职中遇到这一环节的求职者应该很有帮助。我在大一时候面试的两个社团都有这一环节，很巧的是，在这两个社团中分到的这两个小组，最终都没有人被淘汰，两个小组的成员都是全体成为了后来的伙伴。我不知道求职中的无领导小组讨论有没有这种可能，但我以为这至少证明这个小组讨论虽然每个人是竞争关系，但更是合作关系。我在本次求职的过程中没有遇到这个环节，但也许是因为大部分投递的公司和岗位都在初期就被拒绝了的缘故吧（笑），没过简历初筛的也有很多，到目前为止，也只参与了一个公司的面试，今天幸运地收到了签约意向的邮件。而另一个本地的电子公司则在接收了我的简历和成绩单之后就联系了我甚至希望我近期就过去实习并发了offer。和故事中的千晴类似地，将此作为了自己的保底选择。这就不得不提到工作地点的选择。</p>
<p>说起工作地点的选择，这应该是所有求职者都不得不优先考虑的主要因素吧。选择离家近的工作，在生活上的负担更小一些，不过对于大部分不是位于一线城市的人来说，也是相当于需要放弃很多的工作机会。刚开始，想尽可能在本身的较为发达的地区寻求工作机会，求职领域的公司数量远比广东省少得多，也试着投了几个，后来担心着寻不到工作，索性还是把沿海地区较为中意的公司投了。选择在哪里工作的迷茫一直充斥整个求职过程。故事中除了良弘投递的范围比较广泛以外，其他人基本都有比较明确的目标，面试地点都在距离不太远的地方，面试的选择并不算多，准备起来也有针对性。如果不是本次疫情的缘故，可能大多数学生的选择也是如此，大多数企业也是在本省的学校设立宣讲会和面试点较多。而本次疫情则给春招带来了很多的变数，
没有了面试地点的限制，远程面试的地点选择范围更为广泛。因为一直担心找不到工作，春招也已经接近尾声了，不像故事中的求职小分队大多有明确的目标，我投了不少简历，大部分没有反馈，从年后开始求职以来，也是一直焦躁不已。</p>
<p>求职小分队的下一步是写简历。故事中的惠理子这样形容简历：</p>
<blockquote>
<p>我觉得简历更像是相亲时递的帖子，向对方推销自己是个什么样的人，会干什么。虽然是个很蠢的做法，但也只能硬着头皮去办了。</p>
</blockquote>
<p>求职小分队对包括简历填写等的求职技巧都学习了很多，故事里提到读了十几本参考书。与此相比，我几乎没怎么看过这一类的信息，大多数推送或者求职站都会推送这一类消息，内容也是基本大同小异。七人准备的简历除了基本信息外，还包括自荐文，大学生活报告等。相比之下，目前实行网上招聘的很多企业都采用了类似的招聘系统，让你填写，自动生成模板。正好那时候读到一首诗《个人简介》，虽然也向往诗中单纯的简历，但却只见：招聘系统缭乱纷杂，列数个方格，请你裁剪自我，明码标价，高声叫卖，汇成比特自流，换来垃圾邮件。（注：很多的招聘邮件都被邮箱自动划入了垃圾邮件。）少数有几家公司会让求职者将简历发送到HR的邮箱。我后来应聘的公司就要求应聘者投递中英文简历，中文自我介绍视频，英文活动经历介绍视频，成绩单，考级成绩等等。不得不说为了对于一个不自拍的人来说，拍视频真是件很头疼的事情，虽然之前英文外教老师也曾经布置过这项作业。选择了用电脑摄像头拍摄，期间因为太过紧张或者忘词或者说错，大概重复试了一二十次。早上发简历，可能也有辅导员推荐的因素，当天就接到了公司的电话询问是否有意向担任校园大使，觉得自己不能胜任，另外那段时间家里也有事就推辞了，还有点担心会不会影响后面的面试。这是我经历的最复杂的简历投递。</p>
<p>故事中千晴在开始求职前还拜访了求职单位的学长学姐。现实公司中也大多有一个内推码机制，我几乎都是空白着，本来所谓的内推不应该是学长学姐认识举荐才诞生的吗？现在几乎各大求职群，论坛，公众号都遍布着求职内推码的消息，感觉已经背离了内推码这一机制。在开始求职后，故事中，求职小分队大多经历了笔试，面试，二面，或许还有高管面试这些环节。在后来面试的电子领域的公司没有笔试流程，而前期投的大多数互联网公司偏纯软件研发的则纷纷需要笔试，我这个半路出家非科班出身的半个计算机专业几乎是全军覆没。因为疫情缘故，笔试统统在线上举行，或许比线下还要严格，一边要开着摄像头，一遍要开着手机小程序监控，浏览器不能切屏，且要开启屏幕共享。但故事中的求职小分队大多在笔试后固定时间内就能收到通过与否的通知，而现实之中，很多企业可能因为应聘者众多，既没有给通知的具体时间，也不会发未通过的信息，甚至连求职状态都不会更新到笔试环节，期间只有一家公司发邮件告知仍在处理。说起来，因为这个细节，尽管没能通过筛选或者笔试，倒是对那些发了不通过的邮件的公司有了好得多的印象。</p>
<p>故事中主要写了千晴的求职经历，包括她几次的面试过程，我正好也是在面试前读完本书的，多少有点启发，千晴在第一次高管面试轮不幸被淘汰，最主要还是因为没能实事求是吧。我在收到签约通知的这家公司一共进行了三轮面试，虽然校招群里大部分人似乎都只有两轮，HR曾经跟我说是换了一个岗位，再面一次，但面试时经过询问，似乎还是原来的岗位，也不太明白是怎么回事。面试都是通过手机的视频会议软件进行的。第一轮面试10分钟，有两个面试官，一个负责中文，一个负责英文，在面试开始前没多久，在群里看到了之前面试的学生提到有英文面试，虽然没多少时间准备，但最少不是措手不及。第一次线上面试，完全没有经验，拿着手机面试，光线也没有调好，幸好只有10分钟，否则手可能撑不住了（笑），后来有了经验就改为放在固定位置了。一面，面试官提的所有问题我都回答得磕磕绊绊的，如果我是面试官我估计都把自己刷了（笑）。英文面试中面试官提了几个很简单的问题，虽然都能听懂，但对于久没说英语的人来说，回答起来总找不到词汇，也是断断续续的。面试完非常忐忑地等待结果。一面完的第二天，收到通过和下一轮面试的通知。二面只有一个面试官，面试持续了40分钟，面试官相当随和，整个面试过程就像是平常在请教和探讨问题的氛围，主要是问简历上写到的内容和职业规划，开始时面试官问了能不能用英文面试，所以前半段面试也是英文，有了上次的经历，这一次英文回答就流利了一些，面试完总体感觉还好。后来又收到再次面试的通知有点惊讶，不过因为HR说了是换了岗位也就没在意。所以第三次面试时，自我介绍的时候有点不知道该往哪个方向靠了，就问了面试官，面试官给的回答是没有换岗更是惊讶，完全不知道是什么情况，甚至怀疑是不是又被打回第一轮了。这次的面试官有三个人。自我介绍后是几个简单的技术问题，有两个完全无法回答，只简单的听说过，没有多少了解，到底还是半路出家，计算机的基础知识仍有很大缺漏，还有一个问题回答得不全，至此我都差不多觉得自己的面试已经凉了。倒是面试官还很体贴地解释了为什么这么问。后来的问题就基本是关于简历上的内容、未来规划、自身性格了。整个面试过程大概30分钟，面试完觉得应该没戏了，但最后面试官在回答我提出的问题时倒非常细致也非常耐心，甚至还拖延了原定的时间，本来已有另一位学生进入了会议，面试官让其先退出，回答完了我的问题才结束了我的面试。今天收到邮件时相当惊喜，因为自己也对这个公司抱有好感，不过同时还收到了其他公司的拒信（笑）。</p>
<p>总体而言，与自己的求职经历相比照，故事中虽然有比吕氏这样因恐惧闭门不出而错过校招季的遗憾，但整个故事还是比较理想化的，对于公司选择，笔试，面试流程都描述得很详细，对于求职者多有帮助，但如果以为这就是现实，那可能会失望吧。听别人讲起求职的故事很简单，自己成为故事里的人可不一定那么有趣啦。我以为虽然求职的领域多有不同，但求职的过程应该是大多相似的，本书的故事虽然理想化，却也真实，也给了我面试过程中不少的帮助~大多数人应该都会多少有点共鸣吧！</p>
]]></content>
      <categories>
        <category>书籍相关</category>
        <category>工作</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-感受足矣</title>
    <url>/Bookcomment-just-feel/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名： 安野光雅的绘画人生</span><br><span class="line">作者： 【日】安野光雅</span><br><span class="line">译者： 方旭</span><br><span class="line">出版社：北京时代文华书局</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>第一次读安野光雅的书是在今年暑假，在小城图书馆上多次留意到那本书，因为书名很有趣《绘画是一个人的旅行》，
那是一本记录画家生活的随笔集，附有许多可爱的小插画。因此突然收到本书很是惊喜，巧的是，拿到的书的日子还正好是5月20号这个数字有点特别的日期。书的封面似乎是特殊的纸质，手感很好，去掉封套后是极简的黑色，颇为满足。书中谈到的范围很广，从看画，到解读画作，画家生平，不同画派的欣赏，到给喜欢画画的人的简易。作为一名工科学生，平常接触画的时间并不多，对美术史的了解也是少得可怜，斗胆谈谈自己的感受。</p>
<p>安野光雅在书中说日本的教育过于重视电脑培训之类的技能教育，对美的教育却不够上心。译者也在序文里提到：</p>
<blockquote>
<p>大概是因为，技能可以直接用于找工作，而对于美的感知，却很难火速变现。</p>
</blockquote>
<p>似乎是从初中起，美术课几乎就成为了我们争相完成作业的时刻，写下这行字的时候，费了好长时间才想起来高中美术课还是存在的。依稀记得老师曾在课上播放《故宫100》和讲述画家伦勃朗的纪录片。尔大部分人当然也包括自己也曾经漫不经心地听着纪录片赶着作业，借用安野光雅在《绘画是一个人的旅行》中的一句话来说便是：</p>
<blockquote>
<p>在这漫画般夸张的升学热潮前，再多的道理也苍白无力。</p>
</blockquote>
<p>欣赏画作的耐心在以一直试卷定输赢的升学考试前消磨殆尽。</p>
<p>到大城市时，惊讶于几乎遍地的小画廊、博物馆，数量之多，似乎无论是什么时候，都有展览在展出，只取决于你感不感兴趣，而不取决于是否有展览，似乎儿时的好奇心也被唤醒了起来。回忆起小时候，最早的艺术启蒙其实应该不是画而应该是石雕。在当时，小城并没有多少美术馆，而老家以石雕闻名，当地不少人以此为生，倒是很遗憾没有机会接触过这门手艺呢。幼年时每次坐班车回老家，都能透过窗子看到沿途堆放着石材和完工的石雕像，以佛像，观音像居多，也有关公，石狮，大都有一人多高，大概因为体积的缘故，大多数都摆在路边，隔不多远就又能看到。也许从那时起，就无意识地喜欢上了与此相关的事物了吧。在读书的地方喜欢一个人去逛各种各样的画展。会听到身边人调侃着说因为看不懂而不会去画展。怎么样才能算是看懂呢？安野光雅说：</p>
<blockquote>
<p>只要不是画家本人，就不知道作者是怀着什么心情来作画的。</p>
</blockquote>
<p>我以为感受就够了。尤其喜欢一个人在安静的展厅看画。书里说：</p>
<blockquote>
<p>画和文字是人们沉思默想时的「谈话对象」。</p>
</blockquote>
<blockquote>
<p>绘画，是画本身和看画的人共同完成的艺术。</p>
</blockquote>
<p>大概就是这种感受吧。我以为，感受的过程本身就很美好。当然，如果更了解背后的故事或者甚至是专业的技法，也许会有更不一样的感受。</p>
<p>书里的第4章标题是《让画回归淳朴》，谈及稚拙画派。巧的是前不久刚读完原田舞叶以此为背景创作的小说《画布下的乐园》，第一次认识到亨利·卢梭，也第一次看他的画作，伴随着书里的美术史介绍去查找画作，看到画作的第一反应是很特别。卢梭处于兴趣三十岁才开始作画，安野光雅这样评价道：</p>
<blockquote>
<p>他这一生虽然与金钱无缘，但是能够完成这么美好的作品，就算是被人说是业余的笨蛋，我想也是足够幸福了吧。</p>
</blockquote>
<p>我以为因兴趣而去完成某件事是再幸福不过的事。安野光雅也说：</p>
<blockquote>
<p>能够做着自己喜欢的事来生活，人生就很完满。</p>
</blockquote>
<p>人们普遍用文理科来给人分类。书里有这样一句话：</p>
<blockquote>
<p>实际上并不能以简单的标准来分类。比如说用「理科系」「文科系」来分类的话，就觉得不太对了。总之按这种标准分类，并不是说一个人从理科大学毕业就一定能有科学的思想，反之亦然。</p>
</blockquote>
<p>人们总是带着文理科的偏见来看待彼此，而我以为，这二者并不是完全对立的。《黑客与画家》中有就有这样一句话：</p>
<blockquote>
<p>我发现，黑客新想法的最佳来源，并非那些名字里有“计算机”三个字的领域，而是来自于其他创作领域。与其到“计算理论”寻找创意，你还不如在绘画中寻找创意。</p>
</blockquote>
<p>感受足矣，即使看着像是不务正业。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-学问是靠不住的</title>
    <url>/Bookcomment-knowledge-is-insecure/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：      冰冷密室与博士们</span><br><span class="line">作者：     【日】森博嗣</span><br><span class="line">译者：      五科</span><br><span class="line">出版社：    凤凰出版传媒集团/江苏文艺出版社</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在拜读过森博嗣的《全部成为F》后，就对森博嗣的书怀有特别大的期待，而这本书也没有让我失望。本书是S&amp;M即犀川&amp;萌绘系列的第二本，延续了森博嗣在的理工科风格，让我这个工科生读起来倍感亲切。</p>
<p>其实起这个标题是不太妥当的，它并不能概括这个故事或者说那个绝妙的诡计，但又觉得它很合适，读完整本书的时候我我以为这句话就是真相背后的故事的最好的概括。高学位的学者们的生死角逐，起因让人瞠目结舌，但想想近日多所高校曝出的丑闻，似乎文中的这个故事与现实相比，倒一点也并不夸张，也不知道，这个社会何时才能公平地对待每一位学者，每一位学者，何时才能先学会德行后深究学问。前几日和多年不见的朋友们见面，谈起即使是在我们这一代，品德教育仍是极为缺乏的，虽然小学就有一门课名曰思想品德教育，但真正讲入孩子们心里的又有多少呢？也许是我没有认真听讲，现在回想起来，除了这门课的名字，对它没有一点残留的印象。</p>
<blockquote>
<p>知道学问是不可靠的，这才是学问的开始。在考试中取得满分的时候，才知道学问是靠不住的……这正是学问的开始。</p>
</blockquote>
<p>因为读过《全部成为F》，心里总是不自觉地会做一个比较。与《全部成为F》（以下以《F》代称），《F》更具有故事性，从头到尾读完会有一种惊叹于整个故事设定而陷入一种我作为读者我并不能做出这样天马行空的想象，但却会为作者的整个讲述所折服。而本书我以为是更侧重诡计的，也就是“密室”，两具尸体几乎是同时被发现在相邻的房间，而房间的状态却令人匪夷所思，在场的聚会又没有任何一个人有时机完成犯罪，是的，又是聚会（笑），迷恋推理小说的读者们都熟悉这样一种模式，但凡聚会，必有死亡。不过这个聚会要更为特别一些，参加的人们本来就是朝夕相处在实验室，并且这样的聚会并不是偶然为之，也即几乎是一种习惯。而这个密室的独特之处在于，由于“极地研”这个研究所是在实验时时处于一种低温状态，对于犯案和判断尸体的死亡时间来说都是个考验，更进一步地是，在聚会前进行的实验完全是在众人的监视下进行，每一步操作都是通过教授们的指令完成，而整个实验过程也由其他人通过监视器进行监视，看起来似乎并没有人由作案的可能。因为以诡计为重，也就注定了这本书的很大一部分的描述是针对于这个密室，同时也针对于不同人在不同的线索发现的前后对这个密室的可能性的猜测，对于寻求答案心切的读者而言，这一部分可能略显枯燥，但对于热衷各种密室诡计的读者而言，恐怕是大饱眼福，自己的内心也在暗暗做一个假设，我的手法是不是可以实现这个密室呢？是不是我的手法可以完成这个诡计呢？</p>
<p>随着调查的展开，没想到又出现了一具尸体，让整个案情更加扑朔迷离，似乎密室的背后不是那么简单的故事。读到这时，心里也开始有了怀疑对象，但是没有想到的是，这个怀疑对象又成了下一个死者。一切似乎又回到了原点？真的是这样吗？这些在旁人眼里在研究室里做着实验的学者们到底经历了什么，上演着怎样的一出生死戏剧？</p>
<p>和《F》把故事背景设立在一个几乎是与世隔绝的研究所不同，本书的故事发生在大学的研究所里，这一点让我很自然地会有一种熟悉的感觉，里面的人物设定也容易在生活里找到影子。虽然我还只是个啥都不会的本科生，也没有真正见过研究生的实验和研究究竟是一种怎样的状态，但看到森博嗣对于研究生和教授们的状态的描写还是会有一种深深的共鸣，尤其是在后文作为一条较为关键的线索的UNIX系统ROOT权限归属这对于刚接触Linux系统不久的我来说，读到此处，真是会心一笑。惊讶于森博嗣能用理工科的笔调来描述案情，却同时又以哲学家的深度来揭露社会。而穿插于整个S&amp;M系列的犀川和萌绘二人的关系更是把不善言辞的学者心里的情感描绘得淋漓尽致。</p>
<p>冰冷的密室，冷却不了怒火中烧。学者们的生死戏剧，让人叹惋。</p>
<p>纵使千思万虑，以为万全之策，终难料所有。可亡人不再。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-跳出羊圈的羔羊</title>
    <url>/Bookcomment-lamb-jumping-out-of-the-sheepfold/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：      羔羊们的平安夜</span><br><span class="line">作者：     【日】西泽保彦</span><br><span class="line">译者：      夏木</span><br><span class="line">出版社：    新星出版社</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>几乎是用一个下午的时间就一口气读完了《羔羊们的平安夜》这本书，可能是因为西泽保彦讲述的故事太容易让我想到曾经的自己了吧。这本书算不上是传统意义上的本格推理小说，但对于其中的故事我还是非常喜欢的。</p>
<p>故事发生在平安夜，一行人在购买完准备用于互相交换的礼物后见证了一场死亡。看似自杀的事件里却好像又有着诸多的疑点，更不可思议的是五年前这里也上演了那么一出死亡的悲剧，同样看起来也是自杀。只是，让人心生疑虑的是，两人都处在人生中看起来应该是非常幸福的时刻，五年前的少年久作刚刚通过高中的考试，而此刻的女子华苗将要步入婚姻殿堂，无论旁人如何观察，都看不出他们有何自杀的理由。而这群见证了这场死亡的学生和老师在当初并没有发现其中有什么不对劲，也并不知道五年前极为相似的案件。直到一年后，发现他们当初意外地带走了现场的一件“礼物”物证，原本只是为了将这件过期了的礼物物归原主的众人却发现事情似乎并不是那么简单。</p>
<hr />
<p><strong>下文有轻微剧透</strong></p>
<hr />
<p>作为在这整个事件中扮演着侦探和助手角色的高千和匠仔，两人从死者的身边关系企图找到当年这件未送出的礼物可能的接收者。意外地了解到死亡的两人可以说都是在父母的期待下面顺顺利利成长的两人，换言之，就像是循着在羊圈里平安长大的羔羊，从出生到离开，一切都几乎是按照着长辈制定的规矩来行事。而在进一步调查中，二人发现无论是死去的少年的外婆，还是女子的父亲，都有一种对孩子偏执一般的强烈控制欲。高千一改平日的冷漠，因为这个发现对于这个事件尤为上心，读到最后会发现正是高千的热心是有原因的，像是把死者活到了自己身上。其实鄙人还挺喜欢高千的这个形象的塑造。</p>
<p>想想自己的成长经历，其实还是或多或少有些影子在这个故事里的。不知道作者是不是也曾经在这样的家庭环境中成长，所以对这样的家庭的描写直击人心。</p>
<blockquote>
<p>那么温柔的外婆，怎么就杀掉你了？你太不正常了。说什么讨厌被束缚？束缚本来就是保护人的义务啊，为了不让你走上邪路，认真地管好你的生活不是吗？应该感谢外婆啊你！结果却净说些不懂事的任性话——不要根据考试分数来决定零花钱的多少？不要对你的未来指手画脚？不要随便看你的东西？不要不打招呼就没收杂志？不要偷看日记！别跟我说那些无聊又任性的废话了！这些鸡毛蒜皮的小事！要不是有外婆一直好好地看着你，你的生活早就被那些脑袋空空的女人搅得一团糟了！</p>
</blockquote>
<p>我不知道其他读者看到这句话的感受是什么，我只知道那些连续的问号也是我曾经的疑问，数百次在心里问自己为什么？为什么似乎不能拥有自己的秘密呢？为什么我的一切都得由长辈来决定呢？我不明白。虽然我也明白这一切看起来都是为我好，但似乎还是有些拒绝的。记起自己的高中初中时代，真的是有很多很多的时光是在做一个看起来像好学生的坏孩子吧，这种感觉似乎到现在也还没有停止。好像从出生开始就被规划好了未来，这些真的都是鸡毛蒜皮的小事吗？对一个小孩来说，这些事情就好像在说，你还未长大，这些事不是你能决定的，对于一个一个正在成长的小孩来说，这真的很受伤。最令我不解的是，父母们不也是这样成长而来的吗，仅仅因为时代背景的不同，他们就不再能够理解小孩子们的无声的愤怒和无奈了吗？</p>
<blockquote>
<p>这是“报复”。
也就是说，自己曾经遭受的那些，要让自己的孩子也同样遭受一遍。或许，人只是为了这个目的，才选择成为父母的。</p>
</blockquote>
<p>书里的这句话，其实读起来觉得还蛮过分的，但也不是没有道理。特别是读到二人去拜访华苗的家属时，他的父亲那种暴跳如雷的态度，并不是因为女儿的死去而哀痛，而是完全不理解女儿怎么还似乎有瞒着自己的秘密，读起来觉得很难受。说句有些过分的话，父母们的洗脑太成功，以至于有一种做着自己的选择时会有愧疚感甚至是负罪感。像文中华苗的父亲一样，现在难道不也是许多的家长把公务员作为一个孩子的一个人生目标吗？我一直不太懂这是为什么，可能是因为工作稳定的缘故吗？中学时代一直特别羡慕那些和父母像是交朋友一般的同学们，渴望自由。所以文末这句话多多少少是我当时选择大学时的一个写照：</p>
<blockquote>
<p>我想选一个离得尽可能远的大学，所以来到了安槻。是出于一种随随便便的心态做出的选择，反正去哪里都是一样吧，类似这样的感觉。</p>
</blockquote>
<p>虽然读书的地方也并不算是太远，但也算是跳出了羊圈吧，当然多多少少还是会有些对家的不舍。明显地感觉到在学校和在家里的自己完全是两个人。大概有一种在羊圈里关了太久，栅栏突然被打开，跳了出去，面对的是广阔的草原，突然手足无措，迷茫不已，却也并不想回到羊圈。以一个孩子的心态来写这样的话不知道是不是有些太狂妄自大，当然也知道为了自己的成长父母们操心了多少个日日夜夜，但也许在羊圈里度过一个个平安夜并不是所有羔羊的归宿吧。不是有人说高考完，很多曾经志在四方的孩子留在了本省，倒是看起来安安分分的孩子们很多出了省，也许是这个理吗？总还是有想要跳出羊圈的时候吧，然后也就懂得在羊圈里父母创造出来的安逸和狭隘，在跳出来的那一瞬间，好像自己和父母都向对方妥协了，他们没有把羊圈撤掉，但也没有再筑起更大的羊圈，而自己，即使再迷茫，再不安，也不得不独自扛下一切，面对草原上所有的危机四伏。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-不见樱花不识樱树</title>
    <url>/Bookcomment-miss-you-when-sakura-sprout/</url>
    <content><![CDATA[<p><strong>泄底慎入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：      樱树抽芽时，想你</span><br><span class="line">作者：     【日】歌野晶午</span><br><span class="line">译者：      赵建勋</span><br><span class="line">出版社：    江苏凤凰文艺出版社</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>版权归作者所有，任何形式转载请联系作者。 作者：在逃的貓（来自豆瓣）
来源：https://book.douban.com/review/10220052/</p>
<p>如果不是看到友邻的年度榜单上多次出现这本书，大概不会去阅读。无论从书名还是封面的设计来看绝不会想到这是一本推理小说，先入为主地会以为应该是某些爱情故事。当然，说是一个爱情故事倒也似乎没有错。</p>
<p>书的第一章甚至第一页读下来一度让我以为是错拿了什么盗版翻印劣质书籍。满心疑惑这书到底是如何在友邻里得到极高的赞誉，又是如何斩获多个推理大奖的。耐着性子往下读，读了大半本书后仍不觉得故事有何出彩之处。既没有诡异的凶杀现场，也没有令人难以置信的不可能犯罪，看起来甚至和在今日说法里看到过的某些骗保案件追踪没什么两样。甚至觉得交错的故事线有点混乱，黑道与普通人的生活线怎么样也无法并行展开吧？完全带着不解继续阅读，直到终章，差点忍不住惊呼太强了。原来我一直都被从头骗到尾，所以才会觉得故事的某些地方不合理却无从寻解。</p>
<p>人们总是以先入为主的观念去看事物，于是作者就利用了这点，在开始部分就以「上学」，「读书」以及那些在我看来年轻人才会有的玩笑和兴趣成功地欺骗了我笃定地认为侦探是个刚出社会的小伙子。虽然作者并没有详细描述人物年纪，我却在整个阅读过程中一直深信不疑。阅读时并非完全没有疑惑，只是从未想过推理小说还可以这么玩。第一次觉得奇怪是在黑道线出现的时候，毕竟黑道与常人生活理应不该有交集，小伙子混黑道的同时又是如何保持常人的生活的百思不得其解。再后来是在侦探和妹妹前去蓬莱据点参与活动，再怎么说两个年轻人进入这全场老年人的活动无论如何都会很突兀，那时候给自己的解释是可能也有不少青年人抱着孝敬长辈的心态被骗进去，但这显然很牵强。更致命的一处是在阿清和侦探一起以掉包替代扫地老人的工作，两个年轻人代替老人就算员工再怎么忽视清洁工也不至于连年龄都分不清吧，怎么可能毫无察觉，一度以为是作者失误而造成的败笔。然而全书最后几页诡计猛然被呈现在眼前的时候，不合理的地方终于有了解释，天哪，竟然还可以这样！</p>
<p>因为人的行为举止描绘起来是个年轻人，于是便从头到尾被欺骗着。最后作者以几个主角间的对话来揭示年龄的玄妙，简直就像是在嘲笑着自以为是的读者，像是在说：看到了吧，不是只有年轻人才有活力，打着几份工，尝试着不同的新鲜事，也许你们年轻人都做不到呢。</p>
<p>人们总在樱树下聚集着赏樱花，樱花开过之后，樱树就被遗忘。因为只觉得樱花美丽而忽略成熟的樱树，所以才以为文中的侦探是个「青年」，猝不及防地被励志。</p>
<p>已是秋天了， 人们往来经过， 不见樱花不识樱树。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-无解，近似解</title>
    <url>/Bookcomment-no-resolution/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：    樱草忌</span><br><span class="line">作者：    【中】陆秋槎</span><br><span class="line">出版社：  新星出版社</span><br></pre></td></tr></table></figure>
<p><strong>本是無解方程，偏尋近似之解，解得滿紙傷悲。</strong></p>
<span id="more"></span>
<p>花了不长时间就读完了这本书，这是我第一次读陆秋槎的作品，昨晚纠结了很久读元年春还是樱草忌，冥冥之中可能就是那么巧合总能让我在相似的心境下选到一本相似的书。它的本格韵味并不浓
，但这并不妨碍它成为一本我喜欢的书，里面的故事却令我久久无法释怀。就像我在短评里写的，把故事里的人物各取一分就可以拼凑出一个相似的我。</p>
<p>可能，这说是一篇书籍相关并不合适，原谅我写下的更多的是我的回忆和书里的故事的重影，请别问我是谁，谢谢。</p>
<p>仅仅读着引子，看着叶荻口中描述的远江就让我爱上了这个故事。远江说「也许我真的跟小学生没什么区别把。」在我高中和初中的时候，如果不是穿着校服，身着便装上街，店员总是会以小学生的视角来推荐物品，可能我也真的和小学生没什么区别吧。依稀记得高中的时候回初中去看老师，因为高中和初中的校服一样，趴在栏杆上等着老师的时候，旁边一个初一的学生甚至以为我是他的同级同学，问我考得怎么样，哭笑不得。像远江一样，穿校服甚至会给她安全感，因为完全不懂得如何选择，高中的时光基本都在学校上课居多，校服也基本上是我的标配，而南方的短袖更是可以贯穿一整年，未及寒冬，我总是一件短袖校服，套着长袖校服，喜欢买大一号的校服，卷起袖子，松松垮垮的，那几乎是我整个中学时代最常出现的形象。甚至到了大学，仍有人初次见面觉得我应该是未成年的高中生。以至于看到对于远江的描述，我甚至觉得这个角色和我有几分相像。</p>
<p>随着阅读的深入，渐渐看到，远江的生活，那种受尽拘束的生活，虽然自己中学时代家里也管得很严，不过比起文中这个虚构的远江，大概还是幸福得许多的。看到发生在远江身上的故事，很自然地就会想起来曾经的时光，及至期末，无论是老师还是家长都很不满看到小孩子拿着所谓的课外书。曾记得不知是小学还是初中，偷偷借了一本书放在抽屉看，假装在备战期末考，最后被发现，那时候最怕的就是家长会不会一怒之下把书撕了。高三的时候更是因为回家吃晚饭完的时光在看所谓的「闲书」和家里大吵了一架，那阵子正是我成绩最糟糕的时候，也是最挣扎最迷茫的时候，书唯一能给我安慰，却总被排斥。于是我也学会了躲躲藏藏，像远江所做的那样。文里提到远江的并没有零用钱，这又像极了曾经的我，我的所有支出都是告知父母后支取，并不像同龄的孩子那样有一笔固定的零花钱，后来我甚至自己都不想要零花钱了，因为已经似乎没有那个必要，就像远江一样，那个年纪的我也一样想要拥有属于自己的故事和秘密，并不想事无巨细地告知父母，然后支取一笔零花钱，可能也是这样的原因，像远江一样，我也常常拒绝同学的邀请，一起看电影，一起出去玩，这些事情都离我很遥远，后来，我习惯了一个人，至今都习惯，不过，这也许怪不得当初，也许我生性如此，生来无解。</p>
<p>远江读了很多很多的书，常常去借书，常常在课上读书。我不记得从高中的哪一天开始，我的所有下课时间都被我用来看书，这个习惯一直保留到现在，现在我仍然惊讶短短的下课时间竟然让我读完了这么多的书。有时也会在课上看书，甚至在数学课上，不过和远江不同，我并不排斥数理，并且恰恰相反，我热爱，也许这在数学课上坐在第一排还悄悄看着书的我的罪孽总是要还的，所以最后在一向得意的数学上失手惨败。那些日子，在每个周六下午也就是这周的学校时光结束之后，我大都会飞奔向图书馆，借书，还书，享受图书馆的安静，我们当地的图书馆并不太多人，也不大，很是安静，那几乎是我高中最喜欢的去的角落，但我放学后的时间也接近它闭馆的时间，所以能待在那里的时光并不太长。那时候最喜欢的是推理小说，在那个不大的图书馆，几乎每一本推理小说我都清楚地知道它放在哪，数量也并不多，知道我这个习惯和喜好的基本上只有我的同桌，那时候她常常带着一本三毛，我读着推理，她读着三毛，我们可能是班里有些独特的一对同桌，后来读了大学，我竟也喜欢上了三毛，只是不知道同桌有没有喜欢上推理呢。因为零用钱的缘故，故事里的远江常常借书，自己却并没有拥有很多的书。虽然父母并不反对我买书，不过在中学时代我几乎没有买过书，到了大学，自己支配每一个月的生活费，才开始买书，甚至有些疯狂地买书，几乎大半生活费都被用来买书了，宿舍满是没有拆封的书，每次回家一定要带回一大摞读完的书，以至于我的舍友以为我的家里有个很大的书房，有很大的书柜，其实都并没有，我不得不清理掉从前的各种教科书来腾出空间，其实是有些不舍的，尽管是课本，也有我的痕迹。</p>
<p>故事里的很长篇幅是远江的日记。从某一天开始，我也写日记。远江的生活更像是我初中的生活，没有手机，所有人没法联系我，总喜欢独自一人。初三近中考的时候我写过日记，也写在本子上。后来中考完，假期并没有给我太多的印象，我也没有继续我的日记。直到高二的某一天，就像远江遇见了叶荻，我也遇见了我的
α，于是我也开始写日记，并一直到现在，只是，α 已经不再是我的
α，而我也没有再找到
β。和远江一样，一直想着希望有故事可以书写，所以直至现在，每天的任务让我应付得已是很疲惫，但却会庆幸还存在些许想让我记下来的时光。只不过，那时候的我，已经不敢再写在纸上，无论是放在学校还是家里都不安全，更何况能写日记的时间本来也就很少。我总是在黑夜里完全不开灯，凭着感觉在纸上写下日记，等到白天有机会再录入电脑，然后就将那张纸丢弃，为了防止偶然被发现，字迹潦草的经常连自己都看不清，甚至因为在黑暗中书写，字迹常常重叠，也常常忘记将纸张藏到了哪里去，我至今都没搞明白当初我是怎么做到的。因为想要拥有自己的秘密，和远江一样，我们都学会了躲躲藏藏，用了所有能想到的最好的办法。</p>
<p>想来，上了高中的我是有几分叶荻的样子的，虽然有手机，不过基本上也没几个人知道我的手机号。故事里的叶荻说自己的朋友除了远江，要么是因为坐得近一起吃午饭，要么是因为同路一起回家。这两者我都没有，但回忆起我当初的时光，最熟悉的似乎也大都是坐在附近的人，除了α
。当我看到其中几句话，完完整整地被戳到了痛处，秦虹怒吼着跟叶荻说「让我来教你怎么和人做朋友吧……」：</p>
<blockquote>
<p>朋友要一起吃午饭！ 朋友会上课传纸条…… 朋友要每天给对方打电话。
朋友还要一起拍照…… 朋友还要一起写作业。 朋友要一起去厕所。</p>
</blockquote>
<p>如果有任何人这样来对我怒吼，我也一样会愣在原地，无法反驳，可能，就真的是没有朋友吧，这些，我都不曾经历，所以，大概一直以来，也没有弄懂「朋友」的含义。对应着那每一句，中学时代我是走读生，我看着我的两个同桌传纸条，我害怕给任何人打电话，我的取景框里永远只有风景，我在文科的课写理科的作业，如果不是必要，我甚至不想去厕所。很长一段时间里，我也一直思考过这个问题，但始终没有解。很庆幸故事里荐瑶挺身而出，如果发生在我的生活里，大概没有人会为我声援吧。</p>
<p>故事里对姚老师的笔墨不算很多，但我很喜欢，同时隐隐觉得这个角色背后应该还有着什么故事吧。不喜与人交往，不善与人交往，这正是我的真实写照。很喜欢文中借姚老师之口说出来的那句话：</p>
<blockquote>
<p>只要活着，就不得不与人相处，就要去猜测别人的想法。明知道从理论上讲，确切地猜中是根本不可能的，却又不得不求出一个个「近似解」，以便待人接物时不要有什么闪失。</p>
</blockquote>
<p>可是，真的有解吗
，这个方程，真的可以解吗，无解的方程，再怎么去求它的近似解，不都是徒劳吗？</p>
<p>阅读的时候有一瞬间，觉得自己和远江，就像是活在冰封的湖面之下，只有在世界变得温暖的时候才有人不幸地从破裂的冰面下滑，若不幸世界马上冷了起来，他们便有机会伴我度过一些时光。可世界终有放晴的时日，他们便爬出了这个地窖，我也帮着他们离开。世界又开始变冷，冰面又封了起来，于是我再次隐匿于冰面之下，就像下面这几笔拙劣的画，像个不存在于社会的观察者。</p>
<figure>
<img src="../images/frozen_draw.jpg" alt="拙劣的畫，手稿" />
<figcaption aria-hidden="true">拙劣的畫，手稿</figcaption>
</figure>
<figure>
<img src="../images/frozen.png" alt="拙劣的畫，電子稿" />
<figcaption aria-hidden="true">拙劣的畫，電子稿</figcaption>
</figure>
<hr />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">鳳凰花開依然</span><br><span class="line"></span><br><span class="line">伊人已難尋覓</span><br><span class="line"></span><br><span class="line">過往終是虛幻</span><br><span class="line"></span><br><span class="line">可笑執迷追尋</span><br><span class="line"></span><br><span class="line">本是無解方程</span><br><span class="line"></span><br><span class="line">偏尋近似之解</span><br><span class="line"></span><br><span class="line">解得滿紙傷悲</span><br></pre></td></tr></table></figure>
<p>謹以此不成韻脚的句子獻給曾經走進我心裏的那個女孩 α 。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-一瞬的真实</title>
    <url>/Bookcomment-oblique-crime/</url>
    <content><![CDATA[<p>当凶手犯罪不仅仅为了杀人，甚至抱以一种塑造艺术品的庄重，我竟欣赏起这虚拟的罪犯。</p>
<p><strong>泄底慎入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：      斜屋犯罪</span><br><span class="line">作者：     【日】岛田庄司</span><br><span class="line">译者：      王鹏帆</span><br><span class="line">出版社：    新星出版社</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>倾斜的房屋，怪异的人偶，跳舞的尸体，接二连三的死亡，错综复杂，虚情假意的人际关系，死亡的阴霾在流冰馆内散布得淋漓尽致。</p>
<p>推理小说迷们总喜欢开玩笑说“聚会必有命案”，封闭的别墅，不可能的密室，无从探寻的动机，巧妙的排列组合，形成匪夷所思的犯罪，无论是创作者还是读者总是乐此不疲地对此津津乐道。</p>
<p>暴风雪的晚上，平庸的司机上田被杀，似乎没有人有动机。尸体在跳舞，雪地无痕，人偶格雷姆散落，难道是人偶作祟吗？人心惶惶，赶来的警察却毫无头绪。雪花纷飞，开个也许不太恰当的玩笑，斜屋的故事，拿来做应试教育的阅读考试怕是很合适，天气的陪衬，人物的言语，隐藏的心理，不起眼的伏笔，都让人喜爱。而第二夜在警察眼皮底下发生的命案更是不可思议，这是一个，看似无解的谜。</p>
<p>死亡的气息笼罩着整个流冰馆，我们的“厕所侦探”直到全书3/4处才缓缓出场，却像个疯癫的算卦先生，大言不惭不再会有命案，却不想不仅出现第三宗密室杀人，甚至还有一场好在被及时扑灭的小火灾。</p>
<p>但凡读推理小说，真相总是吸引人的。沿袭本格派的优良传统，虽说是新本格，也少不了挑战读者的设定。苦于自己哪有这般智慧，看着这流冰馆的建筑构造图已是眼花缭乱，更别说去破解斜屋命案的真相。看到精彩之处，倒忘了课堂，深陷其中。我们的“厕所侦探”并没有让我们失望，原来这一切不过是看破人心的引蛇出洞，只为击中凶手的软肋。大概每个人心里都有自己的软肋吧。真相的托出，侦探与凶手的对白，岛田的呈现让我觉得侦探和凶手似乎找到了彼此的灵魂，大有相见恨晚之憾。</p>
<p>惊叹于手法，更惊叹于真相，或者说真相背后的故事。这桩犯罪已经不是为了复仇吧。读者们对此书的评价不一，于我而言，很是喜欢。为了一宗犯罪，不惜斥巨资，为此量身定做，终于，等到天时，地利，人和。让人不得其解的无动机犯罪竟只是为了能亲手完成另一宗犯罪，或许称之为艺术更恰当些。读及真相，不自觉地会把凶手视为艺术家而不是罪犯。像是雕琢艺术品一样，斟酌犯罪，让我不得不惊叹出身设计专业的岛田老师的天马行空。本书前文附的褚盟一篇评论《病态中的建筑美学》，以这样一段文字来评价岛田老师，和《斜屋犯罪》这本书：</p>
<blockquote>
<p>读岛田庄司的书，总会情不自禁地为这位天才折服。如果他不写推理小说，一定是位出色的评论家；如果他不写评论，一定是位出色的音乐人；如果他不搞音乐，一定是位出色的建筑师。读过《斜屋犯罪》，相信没有人会对这样的断言表示怀疑。</p>
</blockquote>
<p>的确，这样一种“天上的谜题”并不是随手可得，随时可造，无论是“流冰馆”的建筑构造还是格雷姆的传说，读罢完全接纳这就是这个故事不可分割的一部分。有人笑称如此煞费苦心谋划犯罪消耗的财力心力都过于庞大，倒不如雇请职业杀手，何必多此一举。他们说的不无道理，这也就是为什么我一直认为岛田在《斜屋》中塑造的凶手更像是一名艺术家。这也就是为什么我尤其喜欢文末凶手的自白：</p>
<blockquote>
<p>我的周围充斥着谎言，那些虚伪的言语仿佛耳垢一样附着在我的耳道里，甩都甩不掉。身边的人只会说是是是和好好好，对于我说的话也只是一个劲儿地奉承。但我感觉自己成功地破坏了一部分这样的生活，年轻时存在于身体周围的真实感又回来了。</p>
</blockquote>
<blockquote>
<p>我想要变回原先的自己，哪怕只有一瞬，变回那个拥有知心朋友，单纯但充满朝气的年轻人……所以我才要遵守约定，遵守这个四十年前，我和自己定下的约定。</p>
</blockquote>
<p>喧嚣，重复，虚假的世间，让人沉溺，又让人厌恶。谢幕，终于回归自由。</p>
<p>“跳跃的人偶，一瞬的真实。”</p>
<p>Jumping Jack Flash!</p>
<p><em>写在最后</em>
很早就听说过岛田的这本书，不过一直没有机会读到。这次缘起<code>福尔摩斯侦探推理阁</code>5月的推理小说讨论会讨论此书，写此文的念头也是由本次讨论会产生，借鉴了不少主讲人无盐城的解析和整个推理讨论会中的思想碰撞。此书的最新版是新星出版社的2012版，似乎已经脱销，我翻遍若干个图书馆终于借到一本破旧不堪的2008版（个人还比较喜欢这个版本的封面）。还书日子在即，以后有机会也许会再读。时下是考试月，专业课考试在即，依旧无法抑制写下此文的冲动。或许,
这也是种"一瞬的真实"吧。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-无血腥的哀伤</title>
    <url>/Bookcomment-the-mystery-of-the-Swedish-pavilion/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：瑞典馆之谜</span><br><span class="line">作者：【日】有栖川有栖</span><br><span class="line">译者：王延庆</span><br><span class="line">出版社： 上海译文出版社</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>《瑞典馆之谜》时有栖川有栖国名系列的第二本作品，读及这本书纯属误打误撞。原只是想找本短篇集，以为和该系列的第一册《俄罗斯红茶之谜》一样时短篇，顺手借来一阅，却意外地发现时一部长篇。</p>
<p>和其它我所读过的推理长篇不同，本书开篇并无特别浓烈的火药味，我们常常在推理作品一开篇就能感受到其中暗示着凶杀案即将发生的强烈的人物矛盾冲突，而这个故事却反其道而行之，人物关系看起来极为融洽，那种人人皆有嫌疑，处处可寻动机的情况并不存在。</p>
<p>现场只留下三串脚印，颇有雪地密室的意味，故事并不咄咄逼人，很大一部分篇幅都在纠缠于这好似「雪地密室」的脚印之谜，虽然不显冗余，但读起来还是略觉拖沓。直至作为侦探的火村出场，故事才开始紧凑了起来。故事的凶手和动机并不出人意料，诡计颇为冒险，从而某种程度上来说略显牵强，但确实是一个很巧妙的想法，大有瞒天过海的可能。而对于构成整个谜团的小谜面：巧克力污点，烟囱断折，枕头套消失倒是解释得让人心服口服。</p>
<p>故事里让我在意的另一个地方大概时火村对于这桩犯罪的态度，或者说以有栖川有栖的角度所讲述的火村的态度「我也曾有过杀人的念头」。倒是很期待火村这个侦探角色的后续故事，这是我第一次看到推理作家在自己的推理作品中以侦探之口说出这样一句像是以一个企图犯罪的人所说出的话，却又觉得不无道理，尤其是对于火村的剖析：</p>
<blockquote>
<p>对于罪犯——特别是对于杀人犯——火村一方面表示出强烈的憎恨，另一方面却又抱着难以舍弃的同胞情意。</p>
</blockquote>
<p>看一则则案例，读一个个故事的时候，我也常常有这样的感觉，甚至有时候会为凶手惋惜不已。杀人者是否皆怀恶意？</p>
<p>如果心爱的人犯罪，你会保护她吗？无论是推理小说还是真实案例，这都是个很现实的问题，第一次思考这个问题是在读东野圭吾的《嫌疑人
X
的献身》时，现在再思考这个问题，似乎仍然无法给自己一个肯定的答案，也许会吧。也许有些时候，感情确实会是逻辑和理智的桎梏吧。</p>
<p>这个故事并没有激烈的矛盾，没有血腥的气息，似乎略显平淡，却仍然让人回味。不紧不慢的节奏甚至都没让人感觉所有的故事其实仅仅发生于一天之内。也许就像故事发生的背景，一片远离人世的雪域，从故事开始到故事结束，就只是散发着淡淡的悲伤。是非善恶，就像雪域里大雪纷飞时的瑞典馆，终是有些模糊不清。只是，沉睡于五色沼的那个孩子一定不愿意看到这抹哀伤吧。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-间断点</title>
    <url>/Bookcomment-touched-by-an-angle/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：    天使之触</span><br><span class="line">作者：    【英】乔纳森·莫里斯</span><br><span class="line">译者：    施然</span><br><span class="line">出版社：  新星出版社</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>也许与其他的读者有些不同，我读到这本书完全可以说是一种巧合，之前也从未接触过「神秘博士」系列任何形式的任何作品，但看到书封写着《天使之触》是有史以来读者评分最高的神秘博士小说之一，觉得还真是幸运，而读完这本书，我想，我可能入坑神秘博士了哈哈。收到书的时候正好是台风「山竹」强势登陆的前夜，原以为至少还需要花上几天的课间和闲暇时分才能读完，不想这故事让我沉迷，伴着「山竹」带来的风声和雨声，一日便读完了这个故事，沉醉。</p>
<p>在没有阅读和了解过这个故事前，书的封面其实是有些让人觉得有些面目狰狞的，像是一个狰狞的小鬼的石像。直到读完整个故事，凝视着封面，才明白这正是哭泣的天使，石像的眼里仿佛诉说着哀伤，也许，这是一只逃跑的哭泣天使，被困于纸上，等待着你的眨眼，下一瞬便可挣脱物理束缚，将你带回某个一直在你的回忆里盘旋不去循环上演的时刻。</p>
<p>「时间一直是一个迷人的议题。」这是未来事务管理局出品的 MOOK 1
《时间不存在》中卷首语的第一句话。人们总是在企图揣测时间的神秘。作为时间旅程的交通工具，博士的蓝色警亭我以为并不算得上是天马行空，但仍然让人着迷。像是博士对马克所说的那句话：</p>
<blockquote>
<p>没错！这种事有可能发生在任何人身上，它们只是碰巧挑中了你，因为每个人都有想要回去改变的事物。</p>
</blockquote>
<p>如果能回到过去，已知的未来已经告诉了你未来的遗憾，恐怕每个人都很难不去想修正自己犯下的哪怕只是一点点错误，很难不去想相遇自己曾经错过的美好。美国科幻作家罗伯特·富兰克林·杨就在作品《幽冥之饮》里面讲述了一个企图挽回过去的故事，不错，你回到了过去，可是，你还记得未来的你是因为过去犯下了什么错吗？你会知道在从过去到现在的这条函数中，哪一点才是间断点吗？在还没看到未来的函数前，你又如何知道当下就是那个间断点？</p>
<blockquote>
<p>在每个人的一生中，都有一些关键的时间点，必须在两个主要选项中选择。通常，人们不会意识到自己的这个选择有多重要，但不论知情与否，他做的选择，对未来人生的走向会有决定性的影响。假使这个选择导致了他的死亡，当他被留置在「过去」时，他就可以回到那个时间点，选择另一个选项，延后自己的死期。但要这么做，他必须清楚回到哪个时间点。</p>
</blockquote>
<p>时间旅程是一种诱惑。罗伯特·西尔弗伯格在他的作品《时海捞针》里这样描述故事里沉迷时间旅行的汉伯顿：</p>
<blockquote>
<p>他回到过去消除每次小小的尴尬或失态，去挽回失误，去利用后见之明提供的各种新机遇——去润色，去纠正，去改进。</p>
</blockquote>
<p>可过去的每一点曾经连成线，才创造了当下的现在。就像是一个时间悖论，如果能改变过去，那么现在还存在吗？过去不在了，现在会消失吗？会不会正是因为过去的函数上那个不圆满的间断点的存在才勾勒出了现在的可能呢？博士不停地使用着那蓝色警亭正是为了避免这个时间扰动，避免从过去生长出新的未来岔道。</p>
<p>马克的时间旅程说不上多么惊心动魄，像是按照着流程执行程序一般照着清单上的一个个指示给曾经的自己塑造未来的自己，不得不忍耐想要改变过去，想要修正过去的躁动，而那六尊哭泣天使更是不厌其烦地出现在每一个可能破坏未来的节点。书的封面上有这样一句话：</p>
<blockquote>
<p>用尽余生，守望的是重生还是死亡？</p>
</blockquote>
<p>马克小心地遵守着这趟旅程的规则，只想完成最后的救赎，给深爱的人以重生。这一个故事设定并不多么新颖独特，公平地说，每天在事故中丧生的人不计其数，事故受害者的亲人想要挽留逝者的心情更是无法描摹。但也许故事的迷人之处正在于，重新目睹过去，感受得失，却无从改变，为了未来的连续，只好放弃修正过去的间断。时间旅程细想起来其实极为诡异，你说，是过去塑造了未来，还是未来改变了过去，似乎望不到尽头，也找不到起点。像是克里斯托弗·普利斯特在《孤独地徘徊》里塑造的那个穿行在时间桥的男孩，不断地和过去，未来的自己相遇，恍然发现，似乎一切都像是一个无解的循环。如果不是时间清单上的一项项干预发生，未来的马克是否还是到达过去的这个马克？以未来人的身份观望过去的一点一滴，知晓身边的人将要逝去却不能挽救，那种心痛恐怕也只有真的感受过时间旅程的人才能说得清吧。</p>
<p>在故事的开头，在马克的时间旅程刚刚开始的时刻，他的第一站是去拜访了母亲，既不能让母亲生疑，却仍然想提醒母亲，想以此让父亲的存在延续哪怕一点点也好。作者并没有给马克这时候的状态给过多的描写，可仅仅是「泪流满面」简单的描写就足以让我心里一痛，作为一个在外地读书的学生，一年回家的次数寥寥无几，每一次从家回学校都满带着亲人的关爱和叮嘱，却在很快就在异乡没心没肺地忘得一干二净，自以为不想家，我，会不会因此也错过了什么。</p>
<p>不可干预未来的时间旅程是不是就像是在浏览一部记下了自己的所有过去的纪录片？那种感觉是不是和阅读日记的自己有些相似？也许应该更为心痛，真实的触摸，真实的感受，不会遗落于文字间的细节一点点展现在眼前，那种感觉应该更甚于观看电影时对于影视作品里的角色的命运看得一清二楚，却无力改变，这，可不仅仅是诱惑这么简单吧。</p>
<p>凝视着封面上的哭泣天使，你说，如果我眨了眼，能感受到天使之触吗，哭泣天使会将我拽回过去吗？我会看着曾经懦弱的自己，一次次地错过心爱的人，只敢小心翼翼地记录在自己的回忆里害怕遗失过去吗？我会去弥补那个挥之不去的间断点吗？我不知道。</p>
<p>眨眼，我仍处当下。</p>
<p>睁眼，天使哭泣依然。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Sci-Fi</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-看见深渊时</title>
    <url>/Bookcomment-the-well-of-loneliness/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：    孤寂深渊</span><br><span class="line">作者：    [英] 拉德克里夫·霍尔</span><br><span class="line">译者：    张玲 张扬</span><br><span class="line">出版社：  上海译文出版社</span><br></pre></td></tr></table></figure>
<p><strong>有情节透露</strong></p>
<span id="more"></span>
<p>在<a
href="https://mp.weixin.qq.com/s/BgHJSs7Cz65bAQnChKnB3w">书单</a>中看到这本书的介绍，据说是英语文学中的第一部女同性恋小说，感觉还挺好奇的，便找来一读，和其他曾经读过的女同性恋的小说不同，除了着墨于与恋人的生活，它还囊括了自我认知的童年和青少年时期，从出生一直到中年。前面的自我认知部分真有种相见恨晚的感觉了。</p>
<p>想先谈谈短评里大家提到的觉得实际是 Trans
的小说这一点。书里介绍作者的时候提到这样一点：</p>
<blockquote>
<p>而在日常生活中，她为自己取名为约翰——一个最普通的英国男性用名，她不是一个普通正常的女性，而是有男性生理、心理、意向和行为的女同性恋者，她早年即向社会公开宣称，自己是天生的性倒错者。</p>
</blockquote>
<p>我不知道这里的“性倒错者”是否指跨性别，因为全书中提到整个性少数群体的时候都是用此称谓，鉴于时代的局限性，我想不必纠结于这个名称本身的歧视性。但就从小说的全文来看，我并不认为书中的斯蒂芬是跨性别女同。对跨性别的了解不是太多，但之前看过一位跨性别网友的博客以及TA和TA的朋友们分享的日常，另外包括电影《女孩》里面也有类似的场面，我觉得对
Trans
来说，成为另一个性别的很大一部分包括性征的改变，觉得自己是那个性别的人。在大学的时候，曾经有人跟我说，欸你是不是有喉结，他说我看起来有喉结，我觉得非常不可思议，从来没有人这么说过，于是那些天每天我都在观察男生的喉结是怎样的，也观察我自己，就非常担心，啊，我怎么会有喉结呢，实际上我没看出自己有喉结，也没有再遇到过有人跟我说过这样的话。另外前段时间楼下有几个小男孩在我路过的时候小声起哄我有男性生殖器，我简直想冲过去打一顿了，真不知道家长们在家中都谈论了些什么。尽管从小到大经常被误认为男性，我也都觉得还可以忍受，但这两次简直是冒犯和侮辱了。
（有位友邻私聊我告诉了我实际上喉结是一块软骨组织，男女都有，男性较明显。我也去查了一下相关的资料，大概知道了是怎么回事，即女性也可能喉结明显，不必多担心。友邻还分享了去了解这个情况的原因。非常感谢TA告诉我！当时被问这个问题的时候我完全不敢和任何人说，很怕被证实，现在想起来的时候仍然会有想摸摸自己的喉咙去确认的举动。当然在当时这件事的语境之下是很冒犯的，对方是在问了一个性别相关的问题之后问的这个问题，我与对方并不认识，只是因为学校的某次活动共同在场而已。）</p>
<p>而对于故事中的斯蒂芬，我觉得并不是这样的，故事里没有任何线索指向性征困惑，她的困惑在于，她无法以女性的身份去光明正大地与女性相爱。就这么说吧，刚开始意识到自己喜欢女性的时候，我也会想，如果我是男性就好了，可以自由地去表白，去相爱。最早的认知发生在童年，斯蒂芬与他人有异并不在于想成为男性，而在于社会先对群体的样子有了一个模板化的定义，然后被对号入座，包括许许多多的我们现在仍可以见到的，男性应该如何如何，女性又应该如何如何。本身这个定义就很刻板，在这样的定义下，偏好通常鼓励男性去喜欢的事物的人便被归类为了”男性“，女性性征不那么明显的人们也常常遭遇这样的处境。比如故事中的斯蒂芬，喜欢骑马，击剑，体格比一般的女性更为健壮，不喜欢给女孩们的玩具，宴会，习俗。可以说，两个方面她都完美契合，她常常会得到的形容就是”像男孩一样“，这样的话我也听过很多，以至于曾经很多时候我也会这样形容自己。由于嗓音比较低沉，女性性征也不那么明显，又顶着短发，至少在毕业前我都一直遭遇过被误认为是男性的时刻，尽管我甚至没有剃寸头这样短的头发，但误认仍然一直存在。另一方面，又有社会对女性的刻板印象而造成对理工科的偏爱也成了男性特征。小时候的我，希望自己是男孩是因为，如果是男孩，就可以穿宽松的T恤，可以上蹿下跳，可以不必听”你是女孩子“这样的教诲，甚至连未必彬彬有礼都好像是可以原谅的，连成绩的不好都会有人帮你想好”后来居上“的借口，就好像故事中的斯蒂芬可以去赛马而不必被戏弄，可以去击剑而不必被嘲笑，可以不必在衣着问题上与母亲再三争吵。我们认同的是本该人人拥有但却仅为另一个性别的人所拥有的权利，而不是想成为另一个性别。</p>
<p>第二次认知觉醒我想是在斯蒂芬发现自己喜欢上女仆的时候，包括她后来被男仆与女仆的亲密行为所激怒，再到后来她与父亲的那种或明或暗的关系。可以说斯蒂芬的性意识觉醒相当早了，但我们看到她意识到自己喜欢女仆的时候也感到吃惊。这时候她并没有了解过任何关于同性恋的概念，我想这也就是我们在说同性恋是否天生的时候最关心的一面，实际上对于很多性少数群体来说，可能在并未了解这个词的时候Ta就会有这样的性意识体验了，只不过Ta很久之后才会知道这一点。</p>
<p>我第一次知道同性恋的概念是什么时候呢？在初中，我的某个英语老师提及了同性恋，并且我记得很清楚的是她提到了粉色裤子作为同性恋（查了一下好像这里其实是Gay）的标志，我想我的老师应该应该已经不记得自己说过这个了，她当时大概是因为讲到裤子的颜色而提到，颇带有些开玩笑的意味，我当时还没有意识到自己是同性恋，但我却对这个课堂细节印象深刻，也包括后面的其他老师提及同性恋的时候，我发现我都记得那些片段，但对其他的课堂细节却忘得一干二净，就好像我早知道它与我有联系似的。我印象中只有我的英语老师们提到过同性恋，或许因为他们接触更多异域的文化，但他们并没有为它正名，提及的时候班级里多有哄笑，是的，这我也记得，他们也只会因影响课堂秩序而阻止。第一次有性意识困惑的时候也是在初中，同班的女生问了我这样一个问题：你真的没有喜欢的男生吗？原话我不记得了，大概是这个意思。我当时非常困惑，因为我确实没有心动的男生，我确实毫不关心我身边的女生们在谈论的男女恋爱的桥段，或者校园里的那些谣传的流言，对文艺作品的那些描写也无动于衷，她的问题让我有些无所适从，就好像在问大家都会有这样的体验，这样的经历啊，为什么你没有，我甚至都能记得她问我问题时的那个画面。其实并非没有被传过流言，但后来因为我和那名男生都无所谓，也只是在大家说起的时候表示了一点愤怒以外，没有任何联系，不攻自破了。或许是因为这样的原因，好像大家都觉得我真是一心读书的家伙来着，以至于高中的时候我有次和一个男生聊天谈到另一个男生时，我以为他误会了我们之间的关系，便出言解释，他大笑道，根本就没有这样的想法，他觉得这样的事根本不会发生在我身上。于是，虽然初高中都和几个男生因为数理化的关系非常熟悉，但没有出现更多的流言。我第一次意识到自己喜欢女生是在高中的时候，刚开始记得自己还在日记中写，我并不是同性恋，只是和她相处愉快类似这样的话，后来我渐渐发现我似乎确实是同性恋，然后我开始会留意大家对同性恋的态度。这可能是这个故事没能涉及的一点，因为它的背景局限于大户人家独立的教育，独立的生活，而非我们这样的群体教学。实际上在大概高中的时候，同性恋这个概念就稍微普及了一些，这时候学生们之间开始有了这样的开玩笑，不过大多数时候是用Gay在调侃关系较为亲密的男生们，女生们的亲密关系好像更被大家所包容。说起这点，我从小还有一个很大的困惑，就是女孩们似乎总是能自然而然地手牵手走在一起，但我很排斥，又不知道是哪里不对劲。当然现在我会很期待能牵伴侣的手。女孩们也会用搞姬这样的词，我的一个率直的朋友上学时她常常就这么跟我说，也只有她会猝不及防地跑过来亲一下我的脸颊，抱一下我，这样的举动我的其他同学和朋友都不会做，如果不是我很清楚她有男友我几乎要当真了。现在想起来，我会觉得可能我很小的时候一些举动确实在我不知道的时候它就已经指向了同性恋这个事实。</p>
<p>故事中只有斯蒂芬的父亲察觉到了女儿的同性倾向，并且我们从后面的故事里知道她的父亲实际上一直在了解相关的知识。这父女俩谁也没有告诉对方自己知晓的事情，但又觉得可以相互理解，只有母亲一无所知，但母亲又并非真的一无所知，她不知道是因为她并不了解性少数这样的可能，但她察觉到了父女俩似乎拥有自己所无法介入的联系，尽管父女俩并没有真正建立这样的联系。这可能和我目前的处境最为相似的一部分了，我现在不知道我的父亲是否了解我，但我又在某种程度上相信他对这个群体可能有一定的了解，因此我也希望先和他出柜，而对于母亲，我很难相信她能接受。但这样就有个问题，当父女俩拥有一个秘密，而母亲不知情的时候，对母亲本身难道不是一种伤害吗？我不相信她会全然不知情，就像故事中的那样，其实仅就我目前未出柜的情况，我的母亲在与我单独交谈的时候就已经有了这样的察觉，她的话语中常常透露出很担心我和父亲孤立她，抛下她的意思。这样处境下的母亲和女儿在意外的情况下得知了女儿的性取向的时候，会不会更不可接受呢？故事中的母亲就是如此，以至于斯蒂芬几乎像是被驱逐一样离开了莫顿，另外还直接导致了后来的故事里斯蒂芬与恋人玛丽不能一起回故乡这样的处境，恋人在本该作为归宿的家成为了不被认可的存在，这不管是对斯蒂芬还是玛丽都无疑是巨大的痛苦。所以我也常常在想这个问题，我常常会觉得每次回家都有种最后一次回家的悲凉，在没有出柜前，我永远不知道我的父母是否会接纳，以何种程度接纳，如果我能找到伴侣，他们会不会接纳，他们会不会更担心被非议，毕竟我的母亲曾经对我说我选择不婚育有没有想过他们，尽管她并不知道我已想了许多年。故事中母亲得知斯蒂芬是同性恋的片段非常残酷，是通过与斯蒂芬相处的有夫之妇的丈夫发出的控告信，这样的信件往来之下，我想就算这位母亲多少知道，也不会原谅。我很怕被告发的场景出现，我希望我的父母在了解我的性取向时，我们是平等的，也是平和的。这也是为什么我发现有很多人讨论我的时候，我觉得相当恐慌。很遗憾，故事中的母女俩再没能和解，书中是这样描写的：</p>
<blockquote>
<p>她精神上丝毫也没有因为哭了一场而感觉松快，因为这火热、愤怒的泪水炙烤着她的精神。就这样安娜·戈登通过自己的孩子而受到了火的洗礼，终于使她们失去了相互拯救的机会。</p>
</blockquote>
<p>再后来斯蒂芬和玛丽相遇，相爱，这部分我没有谈过恋爱，就不多做评论了吧。但是她们的不对等关系无疑为后来的分裂早早地预设了隐患，故事的最后，斯蒂芬终于还是将玛丽推了出去。我想我们不能说是马丁的出现导致了这场分裂，毕竟斯蒂芬专注于自己的工作，而玛丽却无法找到自己的合适位置，如果这是一对异性恋，或许这种不平等就仅仅会演变成我们常见的女性操持家务，男性外出挣钱的模式了，很不幸，虽然我们知道这不平等，但这种不平等却可以长久地维持下去，而斯蒂芬和玛丽的不平等则几乎无法维系。年龄、阶级的差距本身就会导致生活经历、生活习惯的不同，这样的差异是否会成为一种隔阂？爱足以维系这样的关系吗？我不确定。</p>
<p>故事中可能还有一个最痛苦的部分就是描绘酒吧，描绘性少数群体几乎是自我放逐的那些片段。在此片段前有一个情节是一家本来欢迎斯蒂芬和玛丽的家人得知了两人的关系，对其下了逐客令，她们曾以为他人可以接纳，后来才发现这几乎是一种接近不可实现的奢望。这或许也是性少数群体一次又一次面对的问题，你永远不知道对方是否真的知情，你永远不知道对方是否真的接纳，如果你没有告知，你永远不知道当对方知道的时候会做出什么反应。另一方面，斯蒂芬的敏感又加剧了这种猜疑，每遇到一个人都要去辨识Ta会不会是你的”盟友“，同时又对旁人的反应非常敏感。就我自己而言，体现在我清楚地听见或察觉他人对我的议论，但我不知道他们是有意让我察觉还是我太敏感了所以才能够察觉。《掩饰》里这样刻画这种状态：</p>
<blockquote>
<p>在我还没出柜前，我总是在微处理我的同性恋身份，琢磨着谁知道了，谁还不知道，谁应该知道，谁又不应该知道。当我出柜时，我欣喜若狂，以为再也不用思考自己的性倾向了。后来我才知道，那种欣喜是幼稚的。我根本不可能一劳永逸地完成出柜，因为每个我新认识的人都在我的周围立起一个新的柜子。更为微妙的是，就算那些知道我是同性恋的人们也在强加给我一些新的要求，要我服从于异性恋。</p>
</blockquote>
<p>而公众对于性少数的生活模棱两可的猜忌又加剧了这种对立，受训于异性恋观念的人们第一反应是不洁，这甚至包括这个群体自身的第一反应，这样的反应促使我们不得不总是在否定自身，人们觉得这样的情况不应该出现在循规蹈矩的人身上，比如电影《爱的甘露》里面，那位母亲对作为英文教授的朋友和养女发生关系的指责，甚至将其赶出自己的屋子。曾经有个我教过的小朋友在我的手机响起来的时候凑过来看，当时我完全没留意我的音乐播放器的背景是两名女性依偎在一起的画面，仅仅是依偎在一起，并没有更多的亲密画面，小朋友凑过来的时候说了一句”恶心“，这让我大为震惊，但又很心虚，尽管我反问了回去，但我们双方都没有再提及这个问题，而我也不确由我来对她科普性少数是不是合适。我想了好久本来想去问这幅画的创作者，因为她本身也是老师，但还是不确定应该如何向她提出这个问题，最终也没有问。后来这就成为了我在教那些小朋友的时候非常小心翼翼的一面，有个更小的小朋友很喜欢和我聊班上的事情，跟我聊班上的八卦，老实说我对那样的事情知之甚少，只能是一边听着她讲，一边甚至都有些羡慕，异性恋可以如此自然而然地发生，好在她没有问起过我这位老师的感情经历。</p>
<p>酒吧里斯蒂芬与犹太人的对谈，斯蒂芬与犹太人看着那些沉沦的性少数们的对谈，让人心痛，可那似乎就是现实，群体的最真实面目只能由群体自身来完成。再到故事的最后对于马丁的重击，斯蒂芬的回应显得多么无力。</p>
<blockquote>
<p>他住口了，而她听到她自己十分镇定地说：”你不了解，我坚信我的写作，十分坚决地相信，有朝一日我会攀上顶峰，而且那就会迫使世人就按照我的样子接受我。这只是个时间问题，但是为了玛丽的缘故，我一定要成功。“</p>
<p>”上帝怜惜你！“他突然脱口而出，”你的成功如果会来，那么对玛丽来说，也会来的太迟。“</p>
</blockquote>
<p>这就好像性少数群体没有一番功绩就没了生存的权利似的，可是赤裸裸的现实就是高处更容易被看见。尽管当今时代的性少数的可见性有所提升，但我常常会觉得网络让我们有了一种社会已经很包容的错觉，当你面对现实中的独立的个体的时候，你会察觉这样的错觉某种程度上被网络放大了太多，其实我们在很多时候，仍然需要”掩饰“，甚至是”冒充“（这两个词的形容来源于《掩饰》一书）。</p>
<p>似乎从性少数们开始认识自己的那一刻，就已经可以看到无数个深渊，我们不停地在问，未来在哪里？我们在谈包容的时候在谈论些什么？</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Les</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-真假莫辨</title>
    <url>/Bookcomment-truth-cannot-distinguish/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：    独眼少女</span><br><span class="line">作者：    【日】麻耶雄嵩</span><br><span class="line">译者：    张舟</span><br><span class="line">出版社：  新星出版社</span><br></pre></td></tr></table></figure>
<p><strong>泄底慎入</strong> <strong>泄底慎入</strong>
<strong>泄底慎入</strong> <span id="more"></span></p>
<p>之前多有听过友邻推荐麻耶雄嵩的作品，不过因为书多绝版，也就没有特意去寻了，借着讨论会的机会一读，很是喜欢。</p>
<p>整个故事分为两部，读第一部的时候没有觉得很惊艳，读至第一部末尾发现还有厚厚的篇幅，颇为好奇剩下的故事展开，于是一口气读完，有些犯规的真相有点崩坏，但还是喜欢的。对于其中细节的推理相当喜欢，大概因为很本格，是久违的逻辑流，再加上少女侦探的独特人设，甚至希望有系列作呢。</p>
<p>最喜欢的推理点是对夏菜死亡现场的推理，横跨第一部和第二部，不断的但又非常合理的伪解释读的非常过瘾。首先是打火机焦痕的问题，手电筒触手可得，却使用麻烦的打火机作为照明工具。第一个解释是凶手眼镜掉落，所以不曾看到手电筒，而裸眼看不到手电筒。这个解释简单但却非常合理，而且是一个日常生活的小场景能接触到的，如果是高度近视的读者大概会很自然地联想到自己没戴眼镜时的茫然吧。而文中还更为严谨地排除了隐形眼镜的可能性。由此嫌疑人的范围迅速缩小，只剩下两人，非A即B的选择。接下来基于鞋子的推理更为精彩，从凶手的心理角度分析凶手并没有发现客用鞋被使用而对小社里有人毫不知情，由此确定凶手并没有打开鞋柜左侧的门，确定了一个伪凶手。而伪凶手却也自己认罪了，这大概是文中一个有些温情的地方，为了避免女儿遭受嫌疑，同时也是相信女儿吧。虽然登对于开发计划的野心让人并不喜欢，但却也有温情的一面呢。</p>
<p>而得知登是伪凶手后，对于这个现场又提出了第二重解答。而这个伪解答我认为并不算特别，如果说拉门是一个急中生智，但是打火机和眼镜这一点作为凶手完全没有接触过这个物件却基于此设计陷阱我想是有些难的，况且凶手到何处弄来打火机呢？</p>
<p>及至第三代御陵御影，重翻旧案，提出了和生君是凶手的伪解答，但其实只是为了解释手印而解释手印，也就是说，其实对于现场的其他疑点并没有在这一重作为诱饵的伪解答里提到。但第三代御陵御影抛出的最后直指母亲的解答最为精彩，虽然她自言此解释可以直指母亲，但逻辑薄弱。整个疑点在于，右侧局促，但凶手从右侧点燃了打火机，如果从右侧窥测只有左眼能看到情况，如果从左侧点燃，那么让人怀疑因左眼不好使而能使自己从右眼窥探，于是从右侧点燃了打火机，于是给第三代御陵御影留下了怀疑的基础。</p>
<p>从第二代御陵御影的推理及至第三代御陵御影的推翻，其中多有线索，但同时也多有伪线索，即陷阱，不停地提出多重解答，以及可爱的侦探本身竟然是凶手，而究其原因竟然是为了杀死父亲而杀掉与此无关的众人为了掩人耳目。而最后崩坏的解释，第二代御陵御影竟是一边想着杀人计划，一边进行着侦探推演，一边还物色着替罪羊，简直惊人。</p>
<blockquote>
<p>不能客观地看待自己，就当不了侦探了。</p>
</blockquote>
<p>也许在意识到父亲山科对母亲的盲目崇拜，意识到父亲因此而毁坏自己的左眼，那时候御陵御影就已经将自己置身事外，冷血以对旁人了吧。</p>
<blockquote>
<p>「破了案，侦探就会变成孤独的局外人，把余人的心伤治愈什么的，很遗憾，并不是侦探的职责。」</p>
</blockquote>
<p>但是，如果侦探只是逻辑推理的呈现者，那么，破案和作案，都会变成逻辑游戏而无黑白之分吧？</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>书籍相关-也渴望镜世界</title>
    <url>/Bookcomment-world-in-the-mirror/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">书名：鏡之孤城</span><br><span class="line">作者：辻村深月</span><br><span class="line">译者：劉愛夌</span><br><span class="line">出版社：皇冠</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>友邻看到我在读《鏡之孤城》，说是「请准备好眼泪」。虽然书腰上也写了『「直木賞」名家最撼動人心的催淚神作』，而我以为那不过是宣传噱头罢了，何况自己也几乎没有遇到会让自己看哭了的故事。听友邻说他看哭了的时候，还蛮好奇这会是怎样的一个故事。</p>
<p>故事更像是一个童话，夹杂着些许日常推理风和科幻设定。故事里的七个孩子，如果可以，我不想用「拒學族」来称呼他们。开头只能以小心的视角来得知小心的遭遇，不知道故事里的「國中」是不是相当于我们初中的年纪，但从小到大经历的那么多班级里，似乎确实，总会有那么一两个人不知为何会成为大家调侃的对象，至于是否到达「霸凌」的程度，我无法判断。印象最深的是四至六年级时班上有个非常消瘦的女孩，家境应该并不好，似乎家庭关系也有些紧张，常看到伤痕，在班上也总受欺负。记得我曾经有段时间座位在她前面，但似乎也从未站出来过，没帮上什么忙。我仍记得那个女孩的名字，不过不知道小学毕业后她是否仍受欺负，现在是否安好。想起来觉得很介意，就像故事里的「東條萌」一样有点难以释怀。毕竟，自己也算是个不合群的孩子。只不过儿时成绩好的孩子在班里总还是会受到老师潜意识里的偏爱，所以在班里才没有人欺负吧。出了班级，也是被欺负的对象呢。那种恐惧感明明我当时就懂，却仍只是旁观，想起来很介意。</p>
<p>但读这本书第一次哭的时候应该是读到小心躲在家里不敢出门，不敢上学，又不敢和父母坦言，一个人缩在房里失魂落魄的样子，把那些恐惧紧紧捂在心里，无可安放。怕出门，怕说话，怕街上的人都在讨论自己，这种恐惧我近一年来才完全明白，读着读着就泪眼模糊，有部分是在动车站和动车上读的，几次合上书不敢往下读。当年那些受欺负的同龄人，是不是和我如今的心情类似，其实每一天都很害怕新的一天的到来。毕竟大人们大都像故事里的「伊田老师」一样，从不把这些当一回事。不管怎么说，小孩子仍可以躲在自己的世界，而大孩子则必须咬牙吞下眼泪，悲从中来。</p>
<p>相泽沙呼在《废墟中的少女侦探》中也以短篇连作为这些校园个体做了特写。而《鏡之孤城》更像是用一整个群体，用不同性格的孩子们来显示着这个普遍的问题。读到七个孩子里的快乐时光，感到很欣慰，也向往那镜中的世界。看到几个孩子在不算太长的时间的交往里达成友谊，很是羡慕，也想要镜中的朋友。哪怕在现实世界里没法互相帮助也没关系。就像小心再心里所想的</p>
<blockquote>
<p>我不是沒有朋友，即便以後再也交不到朋友，我也曾經有過朋友。</p>
</blockquote>
<p>分明那么害怕去学校的七个孩子，分明那么害怕那里的回忆，却因为政宗的请求大家都努力前往，但未能相见，可七个孩子谁也不认为是其他人失信，始终相信一定是哪里出了问题。故事一直都以小心的视角进行，一直到最后，看到所有人的回忆才发现，对于其他人，不想上学的理由也都一样绝不仅仅是他们自己口中的轻描淡写。</p>
<p>我原以为早已猜到与时空旅行类似的设定不会让我对结局太过意外，但读过才发现时空的交织不过是谜底最简单的地方。读到那个穿着红裙子，戴着狼头面具的狼女孩的真面目，尤其是读到由此引出的城堡里与前文的许多细节的呼应，忍不住哭了。虽然觉得结尾仍然显得有些仓促，没能完整地把七个孩子再某个时间的所有关联相接，但晶子在时间里所一直存在着的心之教室的老师的身份让人感动不已，狼女孩所回答理音的请求时所说的：「我會妥善處理的。」大概就是这个意思吧，虽然大家都已认不出了彼此，可确实相见着，也互助着。理音在不断的叩问中喊着姐姐，想必狼女孩虽然转过身，戴着面具，也是早已泪流满面了吧。</p>
<p>全书近500页，读完仍觉意犹未尽，真希望也能穿入镜中，寻找同类。我也想和那七个孩子，噢不，应该算上狼女孩，我也想和那八个孩子做朋友。</p>
<blockquote>
<p>我很想當個普通人，卻一直無法如願以償。所以……你們願意像接納普通人一樣接受我，跟我當朋友，我真的很高興。</p>
</blockquote>
<p>这句我我也想对在豆瓣上认识的友邻们说，这大概也是我一个小小的镜世界。</p>
]]></content>
      <categories>
        <category>书籍相关</category>
      </categories>
      <tags>
        <tag>Reading</tag>
        <tag>Detective</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中的宏及与函数的比较</title>
    <url>/C-marco-and-function/</url>
    <content><![CDATA[<p>本文介绍C语言中的宏定义，并比较宏与函数的异同。</p>
<span id="more"></span>
<p>编译一个C程序的第一个步骤称为预处理(preprocessing)阶段。在此阶段下，由<code>#define</code>指令定义的符号将被替换。</p>
<h1 id="简单的宏">简单的宏</h1>
<p>简单的宏（对象式宏）的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> name stuff</span></span><br></pre></td></tr></table></figure>
<p>使用该指令，可以将任何文本替换到程序中，预处理器遇到一个宏定义时，会将<code>name</code>用<code>stuff</code>进行替换。<code>stuff</code>可以包括标识符、关键字、数值常量、字符常量、字符串字面量、操作符和排列。</p>
<p>通常，我们会在以下两种情况下用宏来为常量命名，替代字符或字符串字面量：</p>
<ul>
<li>常量被不止一次地使用</li>
<li>常量日后可能需要修改</li>
</ul>
<p>可以用<code>#undef name</code>指令移除一个宏定义。</p>
<h2
id="使用define为常量命名的优点">使用<code>#define</code>为常量命名的优点</h2>
<ul>
<li><p><strong>程序更易读</strong></p>
<p>帮助读者理解常量的意义，免于受大量「魔法数」的困惑。</p></li>
<li><p><strong>程序更易修改</strong></p>
<p>仅需要改变一个宏定义，就可以改变程序中出现的所有常量值。对比「硬编码」常量，若在大型程序中多处出现，修改时很可能漏掉某处。</p></li>
<li><p><strong>避免前后不一致或键盘输入错误</strong></p>
<p>例如数值常量<span class="math inline">\(\pi\)</span>的值。</p></li>
<li><p><strong>可以对C语法进行修改</strong></p>
<p>对于习惯使用其他编程语言的程序员可以使用宏定义来修改语法。但，修改语法并不是个好主意，会使程序难被其他程序员理解，并且可能造成混淆，使可读性下降。<em>避免用<code>#define</code>创建新语言。</em></p></li>
<li><p><strong>对类型重命名</strong></p></li>
<li><p><strong>控制条件编译</strong></p></li>
</ul>
<h2 id="指令的规则">指令的规则</h2>
<p>以下规则也适用于其他预处理指令。</p>
<ul>
<li><p><strong>指令以<code>#</code>开始</strong></p>
<p><code>#</code>符号不需要出现在一行的行首，只要之前有空白字符就行。在<code>#</code>后是指令名，接着是指令所需要的其他信息。</p></li>
<li><p><strong>指令总是在第一个换行符处结束，除非明确指明要延续</strong></p>
<p>如果想要在下一行延续指令，必须在当前行末尾使用<code>\</code>字符。</p>
<p>利用相邻字符串常量被自动链接为一个字符串的特性，可以使用如下声明来调试一个存在许多涉及一组变量的不同计算过程的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PRINT printf(<span class="string">&quot;File %s line %d:&quot;</span> \ </span></span><br><span class="line">						<span class="string">&quot;x = %d, y = %d, z = %d&quot;</span>, \ </span><br><span class="line">						__FILE__, __LINE__, \ </span><br><span class="line">						x, y, z)</span><br></pre></td></tr></table></figure>
<p><em>注意</em>：为避免出错，不要在末尾放置分号。</p>
<p>使用此调试语句示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x *= <span class="number">2</span>;</span><br><span class="line">y += x; </span><br><span class="line">z = x * y;</span><br><span class="line">DEBUG_PRINT;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>指令可以出现在程序中的任何地方</strong></p>
<p>我们常将<code>#define</code>指令放在文件的开始。</p></li>
<li><p><strong>注释可以与指令放在同一行</strong></p>
<p>在宏定义后面加一个注释来解释宏的含义是一种好习惯。</p></li>
</ul>
<h1 id="带参数的宏">带参数的宏</h1>
<p><code>#define</code>机制允许将参数替换到文本中，称为带参数的宏/函数式宏/定义宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> name(paramter-list) stuff</span></span><br></pre></td></tr></table></figure>
<p>为了区分带参数宏和函数，通常使用大写来命名宏。</p>
<p>带参数宏常用于执行简单的函数，如：</p>
<ol type="1">
<li><p>求两数最大值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x)&gt;(y)?(x):(y)</span></span><br></pre></td></tr></table></figure></li>
<li><p>判断奇偶性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_EVEN(n) ((n) % 2 == 0）</span></span><br></pre></td></tr></table></figure></li>
<li><p>交换两个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAP(x, y, t) ((t) = (x), (x) = (y), (y) = (t)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>带参数的宏不仅适用于模拟函数调用，也经常用作需要重复书写的代码段，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC(n, type)\</span></span><br><span class="line"><span class="meta">		((type *)malloc((n) * sizeof(type)))</span></span><br></pre></td></tr></table></figure>
<h2 id="带参数宏与函数的比较">带参数宏与函数的比较</h2>
<h3 id="执行速度">执行速度</h3>
<p>程序执行时调用/返回函数通常会有额外开销，包括存储上下文信息、复制参数值等。</p>
<p>调用宏则没有这些运行开销。</p>
<h3 id="代码长度">代码长度</h3>
<p>每一处宏调用都会导致插入宏的替换列表，由此导致程序源代码增加，编译后的代码也变大。</p>
<p>函数调用的函数代码仅出现于一个地方：每次使用函数，调用同一份代码。</p>
<p><em>如果相同的代码需要出现在程序的几个地方，更好的方法是实现为一个函数。避免用<code>#define</code>指令定义可以用函数实现的长序列代码。</em></p>
<h3 id="参数求值">参数求值</h3>
<p>参数每次用于宏定义时，都将重新求值。因此宏可能会不止一次地计算它的参数，由于多次求值，具有副作用的参数可能会产生不可预料的结果。</p>
<p>参数在函数被调用前只求值一次，在函数中多次使用参数不会导致多种求值过程。</p>
<p>考虑上面的求两数最值的一种使用情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">5</span>;</span><br><span class="line">y = <span class="number">8</span>;</span><br><span class="line">z = MAX(x++, y++);</span><br></pre></td></tr></table></figure>
<p>宏替换后产生以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">z = ((x++) &gt; (y++) ? (x++) : (y++));</span><br></pre></td></tr></table></figure>
<p>较小的值增加了一次，而较大的值却增加了两次，第一次在比较时，第二次在执行后面的表达式时，因此此时得到的结果是<code>x = 6, y = 10, z = 9</code>。</p>
<h3 id="操作符优先级">操作符优先级</h3>
<p>宏参数的求值是在所有周围表达式的上下文环境里，邻近操作符的优先级可能会产生不可预料的结果</p>
<p>函数只在函数调用时求值一次，结果值传递给函数，表达式的求值结果更容易预测。</p>
<p>考虑以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SQUARE(a + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>宏定义后产生的代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + <span class="number">1</span> * a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>表达式没有按照预想的次序求值。</p>
<p><strong>注意</strong>：<em>所有用于对数值表达式进行的宏定义都应该在宏定义每个参数周围加上括号，且在整个宏定义的两边也加上括号。</em></p>
<h3 id="参数类型">参数类型</h3>
<p>宏与类型无关，只要对参数的操作何发，可以用于任何类型参数。</p>
<p>函数与类型有关，函数类型不同，需要使用不同函数，即使执行任务相同。</p>
<p>例如上面举例的<code>MAX</code>宏，可以接受多种类型数：<code>int</code>,
<code>long</code>, <code>float</code>, <code>double</code>等。</p>
<p>例如上面举例的<code>MALLOC</code>宏，<code>type</code>参数是一种类型，无法作为函数参数进行传递。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《C语言程序设计现代方法（第2版）》</li>
<li>《C和指针》</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>Program</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中的转义序列</title>
    <url>/C-program-escape-sequence/</url>
    <content><![CDATA[<p>前些天有师弟问起关于C语言中转义序列的问题，尤其提到了<code>\?</code>这个转义字符，因为记得<code>??</code>似乎是三元字符集的开头，应该也算是特殊字符，但记得并不太清楚，于是搜寻了些资料，和转义序列的问题一并作整理和记录。
<span id="more"></span> # 转义序列 (escape sequence)</p>
<p>首先，我们知道，在C语言中，字符常量使用单引号括起来表示，但并不是所有的字符都可以直接由键盘输入而表示出来，比如换行符，也就无法用这样的方式来书写。通常来说有这样两种无法用这种方式表示的字符，一是非打印字符，如换行符，一是特殊字符，键盘上并没有直接的键位可以录入。这时候就需要用到转义序列来表示，字符转义序列和数字转义序列。</p>
<h2 id="字符转义序列-charatcter-escape">字符转义序列 (charatcter
escape)</h2>
<p>字符转义序列即我们常见的如<code>\n</code>表示换行符这样，下面给出字符转义序列表：</p>
<table>
<thead>
<tr class="header">
<th>转义序列</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\'</code></td>
<td style="text-align: left;">单引号</td>
</tr>
<tr class="even">
<td><code>\"</code></td>
<td style="text-align: left;">双引号</td>
</tr>
<tr class="odd">
<td><code>\?</code></td>
<td style="text-align: left;">问号</td>
</tr>
<tr class="even">
<td><code>\</code></td>
<td style="text-align: left;">反斜杠</td>
</tr>
<tr class="odd">
<td><code>\a</code></td>
<td style="text-align: left;">响铃</td>
</tr>
<tr class="even">
<td><code>\b</code></td>
<td style="text-align: left;">退格</td>
</tr>
<tr class="odd">
<td><code>\f</code></td>
<td style="text-align: left;">换页</td>
</tr>
<tr class="even">
<td><code>\n</code></td>
<td style="text-align: left;">换行</td>
</tr>
<tr class="odd">
<td><code>\r</code></td>
<td style="text-align: left;">回车</td>
</tr>
<tr class="even">
<td><code>\t</code></td>
<td style="text-align: left;">水平制表符</td>
</tr>
<tr class="odd">
<td><code>\v</code></td>
<td style="text-align: left;">垂直制表符</td>
</tr>
</tbody>
</table>
<p>这里我们看到前四个都是符号，而除了问号以外，其他三个符号因为在C语言中有其他的作用，为了避免两者混淆，我们需要用转义序列来表示，那么为什么问号也需要呢，这就是我们后面要提到的三元字符序列，这里先按下不表。</p>
<h2 id="数字转义序列-numberic-escape">数字转义序列 (numberic
escape)</h2>
<p>虽然字符转义序列已经可以表示出一些无法打印的字符，但并仍然没法包含所有无法打印的
ASCII 字符，而我们通过查阅 <a href="http://www.asciitable.com/">ASCII
字符集</a>中字符编号，就可以使用数字转义序列来表示这些字符，就好比我们每个人都有一个身份证号，用身份证号就可以表示我们这个人的身份一样。</p>
<h3 id="八进制转义序列">八进制转义序列</h3>
<p><span class="math inline">\(\verb|\|NUMBER_{(8)}\)</span> * NUMBER
为一不超过三位数字的八进制数; * NUMBER
需表示为无符号字符，最大值通常是<span
class="math inline">\(337_{(8)}\)</span>; *
转义序列中的八进制数不一定要用 0 开头.</p>
<h3 id="十六进制转义序列">十六进制转义序列</h3>
<p><span class="math inline">\(\verb|\x|NUMBER_{(16)}\)</span> * NUMBER
为一十六进制数; * NUBMBER 需表示为无符号字符（若字符长度为 8
位，则不能超过 FF）; * 字符 x 必须为小写; * NUMBER 不限大小写;
当作为字符常量使用时，转义序列必须用一对单引号括起来，而采用数字转义序列的方式来表示某个字符常量可能会使代码的可读性降低，可以使用<code>#define</code>宏定义的方式进行命名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ESC <span class="string">&#x27;\33&#x27;</span> <span class="comment">/* ASCII escape character */</span></span></span><br></pre></td></tr></table></figure>
<h1 id="三字符序列-trigraph-sequence">三字符序列 (trigraph
sequence)</h1>
<p>前面我们提到了问号这个特殊字符也需要一个转义序列是由于三字符序列的存在。在欧洲的某些老式键盘提供的使欧洲语言所使用的古老字符，键盘上缺少
C 语言需要的字符，因此引入了三字符来解决这一问题。</p>
<p>三字符序列是一种三字符码，所有的三字符都以<code>??</code>开始，下面是三字符序列表：</p>
<table>
<thead>
<tr class="header">
<th>三字符序列</th>
<th style="text-align: left;">等价的 ASCII码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>??=</code></td>
<td style="text-align: left;">#</td>
</tr>
<tr class="even">
<td><code>??(</code></td>
<td style="text-align: left;">[</td>
</tr>
<tr class="odd">
<td><code>??/</code></td>
<td style="text-align: left;">\</td>
</tr>
<tr class="even">
<td><code>??'</code></td>
<td style="text-align: left;">^</td>
</tr>
<tr class="odd">
<td><code>??&lt;</code></td>
<td style="text-align: left;">{</td>
</tr>
<tr class="even">
<td><code>??!</code></td>
<td style="text-align: left;">}</td>
</tr>
<tr class="odd">
<td><code>??&gt;</code></td>
<td style="text-align: left;">~</td>
</tr>
</tbody>
</table>
<p>例如，我们在学习编程时学习的第一个程序 Hello, world
就可以用三字符写成下面的形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">??=include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">void</span>)</span><br><span class="line">??&lt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world??/n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> ??&gt;</span><br></pre></td></tr></table></figure>
<p>遵循 C89 或 C99
标准的编译器都必须能接受三字符，所以上面这段程序是能够通过编译并执行的，混杂三字符和正常字符表示也是可以的。这也就是说，我们在字符串中放置<code>??</code>，有一定几率会因为三字符而导致问题，因为编译器可能会将其视为三字符的开始标志。如果发生这种情况，我们可以在第二个<code>?</code>字符前面放置<code>\</code>把第二个字符<code>?</code>变成转义序列，即<code>?\?</code>，这样就不会被看作是三字符的开始了，这也是为什么在字符串中直接使用<code>?</code>是可以输出的，但转义序列中却包含<code>\?</code>。不过在我的几次尝试中，发现，编译器通常会在碰到疑似三字符出现的情况下出现
warning，提示你三字符被忽略，如果需要启用三字符，需要添加<code>-trigraphs</code>编译选项，添加了编译选项后就可以正常使用三字符了，虽然通常我们很少用及。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《C语言程序设计现代方法（第 2 版）》</li>
<li><a href="https://zh.cppreference.com/w/c/language/escape">转义序列 -
cppreference.com</a></li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>Program</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-邻接数组存储的图</title>
    <url>/Data-structures-MGraph/</url>
    <content><![CDATA[<ul>
<li>邻接数组存储的图的表示</li>
<li>邻接数组存储的图的操作接口定义</li>
<li>邻接数组存储的图的操作实现</li>
</ul>
<span id="more"></span>
<h1 id="邻接数组存储的图的表示">邻接数组存储的图的表示</h1>
<p>由于图的任意两个顶点之间都可能存在边（弧），因此在图的存储与表示中，关键是如何表示边（弧）集。
用邻接矩阵也就是一个二维数组存储图的边集，也即关系数组，用一个一维数组存储图的顶点，也即顶点数组。</p>
<p>邻接数组的存储结构类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用于标记是否已访问 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNVISITED	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VISITED		1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY INT_MAX	<span class="comment">// 计算机中允许的最大整数值</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG, DN, UDG, UDN&#125; GraphKind;	<span class="comment">// 图的四种类型：有向图、有向带权图、无向图、无向带权图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接数组类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	VexType * vexs; <span class="comment">// 顶点数组</span></span><br><span class="line">	<span class="type">int</span>** arcs;	<span class="comment">// 关系数组，无权图用0或1表示是否相邻，带权图则为权值或INFINITY</span></span><br><span class="line">	<span class="type">int</span> n;		<span class="comment">// 顶点数</span></span><br><span class="line">	<span class="type">int</span> e; 		<span class="comment">// 边（弧）数</span></span><br><span class="line">	GraphKind kind;	<span class="comment">// 图的类型</span></span><br><span class="line">	<span class="type">int</span> * tags;	<span class="comment">// 标志数组，用于标记顶点访问与否</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 边（弧）信息 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	VexType v, w; <span class="comment">// 边（弧）端点</span></span><br><span class="line">	<span class="type">int</span> info; <span class="comment">// 对于带权图为权值</span></span><br><span class="line">&#125;ArcInfo;</span><br></pre></td></tr></table></figure>
<h2 id="本文中预定义的说明">本文中预定义的说明</h2>
<h3 id="预定义常量和类型">预定义常量和类型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">// 用作函数值类型，表示函数结果状态</span></span><br></pre></td></tr></table></figure>
<h3 id="数据结构存储结构的表示">数据结构（存储结构）的表示</h3>
<p>数据结构的表示用类型定义(<code>typedef</code>)描述。数据元素类型约定为ElemType，读者在使用该数据类型时自行定义，如<code>int</code>、<code>char</code>等简单类型。</p>
<h3 id="扩展引用调用">扩展引用调用</h3>
<p>为了便于算法描述，我们使用了 C++ 语言中的引用调用参数传递方式。</p>
<h1
id="邻接数组存储的图的操作接口定义">邻接数组存储的图的操作接口定义</h1>
<p>图G的顶点<code>v</code>在顶点数组中的下标<code>k</code>称为<code>k</code>在G中的位序，也称<code>v</code>为G的
<strong>第<code>k</code>顶点</strong>， 简称
<strong>k顶点</strong>。基于邻接数组的图的接口定义如下：</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化含n个顶点且无边的kind类的图G</span></span><br><span class="line"><span class="function">Status <span class="title">InitGraph_M</span><span class="params">(MGraph &amp;G, GraphKind kind, VexType *vexs, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 创建n个顶点和e条边的kind类的图G，vexs为顶点信息，arcs为边信息</span></span><br><span class="line"><span class="function">Status <span class="title">CreateGraph_M</span><span class="params">(MGraph &amp;G, GraphKind kind, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span>;</span><br><span class="line"><span class="comment">// 销毁图G</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyGraph_M</span><span class="params">(MGraph &amp;G)</span></span>;</span><br><span class="line"><span class="comment">// 查找顶点v在图G中的位序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex_M</span><span class="params">(MGraph G, VexType v)</span></span>;</span><br><span class="line"><span class="comment">// 取图G的k顶点的值到w</span></span><br><span class="line"><span class="function">Status <span class="title">GetVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k, VexType &amp;w)</span></span>;</span><br><span class="line"><span class="comment">// 对图G的k顶点赋值w</span></span><br><span class="line"><span class="function">Status <span class="title">PutVex_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, VexType w)</span></span>;</span><br><span class="line"><span class="comment">// 求图G中k顶点的第一个邻接顶点位序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FirstAdjVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k)</span></span>;</span><br><span class="line"><span class="comment">// m顶点为k顶点的邻接顶点，求图G中k顶点相对于m顶点的下一个邻接顶点的位序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NextAdjVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k, <span class="type">int</span> m)</span></span>;</span><br><span class="line"><span class="comment">// 在图G中增加k顶点到m顶点的边或弧，若为带权图，info为权值，否则为1</span></span><br><span class="line"><span class="function">Status <span class="title">AddArc_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, <span class="type">int</span> m, <span class="type">int</span> info)</span></span>;</span><br><span class="line"><span class="comment">// 在图G中删除k顶点到m顶点的边或弧</span></span><br><span class="line"><span class="function">Status <span class="title">RemoveArc_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, <span class="type">int</span> m)</span></span>;</span><br><span class="line"><span class="comment">// 深度优先遍历图G</span></span><br><span class="line"><span class="function">Status <span class="title">DfsTraverse_M</span><span class="params">(MGraph G, Status(* visit)(<span class="type">int</span>))</span></span>;</span><br><span class="line"><span class="comment">// 广度优先遍历图G</span></span><br><span class="line"><span class="function">Status <span class="title">BFSTraverse_M</span><span class="params">(MGraph G, Status(*visit)(<span class="type">int</span>))</span></span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="邻接数组存储的图的操作实现">邻接数组存储的图的操作实现</h1>
<h2 id="初始化图">初始化图</h2>
<p>初始化图的过程如下： 1. 按顶点数分配顶点、边集和标志3个数组空间； 2.
将顶点依次存入顶点数组； 3. 初始化标志数组和关系数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitGraph_M</span><span class="params">(MGraph &amp;G, GraphKind kind, VexType *vexs, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, info;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || (n &gt; <span class="number">0</span> &amp;&amp; <span class="literal">NULL</span> == vexs))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*根据图的类型赋权值*/</span></span><br><span class="line">	<span class="keyword">if</span> (DG == kind || UDG == kind) 		<span class="comment">// 无权图</span></span><br><span class="line">		info  = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (DN == kind || UDN == kind) <span class="comment">// 有权图</span></span><br><span class="line">		info = INFINITY;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.n = n;  <span class="comment">// 顶点数</span></span><br><span class="line">	G.e = <span class="number">0</span>;  <span class="comment">// 边数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*若为空图，则已初始化完成*/</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">	G.vexs = (VexType*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(VexType));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == G.vexs)</span><br><span class="line">		<span class="keyword">return</span> OVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*建立顶点数组*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">		G.vexs[i] = vexs[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*分配关系数组的指针数组*/</span></span><br><span class="line">	G.arcs = (<span class="type">int</span>**)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == G.arcs)</span><br><span class="line">		<span class="keyword">return</span> OVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*分配关系数组的指针数组指向的数组*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		G.arcs[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == G.arcs[i])</span><br><span class="line">			<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*分配标志数组*/</span></span><br><span class="line">	G.tags = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == G.tags)</span><br><span class="line">		<span class="keyword">return</span> OVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化标志数组和关系数组*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		G.tags[i] = UNVISITED;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			G.arcs[i][j] = info;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建图">创建图</h2>
<p>在图已初始化的情况下根据图的类型和边关系数组创建图。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateGraph_M</span><span class="params">(MGraph &amp;G, GraphKind kind, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || e &lt; <span class="number">0</span> || (n &gt; <span class="number">0</span> &amp;&amp; <span class="literal">NULL</span> == vexs) || (e &gt; <span class="number">0</span> &amp;&amp; <span class="literal">NULL</span> == arcs))</span><br><span class="line">	       <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.kind = kind; <span class="comment">// 图的类型</span></span><br><span class="line">	<span class="keyword">switch</span> (G.kind) &#123;</span><br><span class="line">		<span class="keyword">case</span> UDG : <span class="keyword">return</span> <span class="built_in">CreateUDG_M</span>(G, vexs, n, arcs, e);	<span class="comment">// 创建无向无权图</span></span><br><span class="line">		<span class="keyword">case</span> DG : <span class="keyword">return</span> <span class="built_in">CreateDG_M</span>(G, vexs, n, arcs, e);	<span class="comment">// 创建有向无权图</span></span><br><span class="line">		<span class="keyword">case</span> UDN : <span class="keyword">return</span> <span class="built_in">CreateUDN_M</span>(G, vexs, n, arcs, e);	<span class="comment">// 创建无向带权图</span></span><br><span class="line">		<span class="keyword">case</span> DN : <span class="keyword">return</span> <span class="built_in">CreateDN_M</span>(G, vexs, n, arcs, e);   	<span class="comment">// 创建有向带权图</span></span><br><span class="line">		<span class="keyword">default</span>:  <span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建无向无权图">创建无向无权图</h3>
<p>对每条边分别求得顶点<code>v</code>和<code>w</code>在顶点数组中的下标<code>i</code>和<code>j</code>，然后置<code>G.arcs[i][j]</code>和<code>G.arcs[j][i]</code>的值为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateUDG_M</span><span class="params">(MGraph &amp;G, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	VexType v, w;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化*/</span></span><br><span class="line">	<span class="keyword">if</span> (OK != InitGraph_M(G, G.kind, vexs, n))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.e = e; <span class="comment">// 边数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.e; k++) &#123;</span><br><span class="line">		<span class="comment">/*读入边(v,w)*/</span></span><br><span class="line">		v = arcs[k].v;</span><br><span class="line">		w = arcs[k].w;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*确定v和w在顶点数组中的位序i和j*/</span></span><br><span class="line">		i = LocateVex_M(G, v);</span><br><span class="line">		j = LocateVex_M(G, w);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">		G.arcs[i][j] = G.arcs[j][i] = <span class="number">1</span>;	<span class="comment">// 对关系数组赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建有向无权图">创建有向无权图</h3>
<p>对每条边分别求得顶点<code>v</code>和<code>w</code>在顶点数组中的下标<code>i</code>和<code>j</code>，然后置<code>G.arcs[i][j]</code>的值为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateDG_M</span><span class="params">(MGraph &amp;G, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	VexType v, w;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化*/</span></span><br><span class="line">	<span class="keyword">if</span> (OK != InitGraph_M(G, G.kind, vexs, n))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.e = e; <span class="comment">// 边数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.e; k++) &#123;</span><br><span class="line">		<span class="comment">/*读入边(v,w)*/</span></span><br><span class="line">		v = arcs[k].v;</span><br><span class="line">		w = arcs[k].w;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*确定v和w在顶点数组中的位序i和j*/</span></span><br><span class="line">		i = LocateVex_M(G, v);</span><br><span class="line">		j = LocateVex_M(G, w);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">		G.arcs[i][j] = <span class="number">1</span>;	<span class="comment">// 对关系数组赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无向带权图">无向带权图</h3>
<p>对每条边分别求得顶点<code>v</code>和<code>w</code>在顶点数组中的下标<code>i</code>和<code>j</code>，然后置<code>G.arcs[i][j]</code>和<code>G.arcs[j][i]</code>的值为权值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateUDN_M</span><span class="params">(MGraph &amp;G, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	VexType v, w;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化*/</span></span><br><span class="line">	<span class="keyword">if</span> (OK != InitGraph_M(G, G.kind, vexs, n))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.e = e; <span class="comment">// 边数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.e; k++) &#123;</span><br><span class="line">		<span class="comment">/*读入边(v,w)*/</span></span><br><span class="line">		v = arcs[k].v;</span><br><span class="line">		w = arcs[k].w;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*确定v和w在顶点数组中的位序i和j*/</span></span><br><span class="line">		i = LocateVex_M(G, v);</span><br><span class="line">		j = LocateVex_M(G, w);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">		G.arcs[i][j] = G.arcs[j][i] = arcs[k].info;	<span class="comment">// 对关系数组赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建有向带权图">创建有向带权图</h3>
<p>对每条边分别求得顶点<code>v</code>和<code>w</code>在顶点数组中的下标<code>i</code>和<code>j</code>，然后置<code>G.arcs[i][j]</code>的值为权值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateDN_M</span><span class="params">(MGraph &amp;G, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	VexType v, w;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化*/</span></span><br><span class="line">	<span class="keyword">if</span> (OK != InitGraph_M(G, G.kind, vexs, n))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.e = e; <span class="comment">// 边数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.e; k++) &#123;</span><br><span class="line">		<span class="comment">/*读入边(v,w)*/</span></span><br><span class="line">		v = arcs[k].v;</span><br><span class="line">		w = arcs[k].w;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*确定v和w在顶点数组中的位序i和j*/</span></span><br><span class="line">		i = LocateVex_M(G, v);</span><br><span class="line">		j = LocateVex_M(G, w);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">		G.arcs[i][j] = arcs[k].info;	<span class="comment">// 对关系数组赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁图">销毁图</h2>
<p>需要销毁顶点数组，指向关系数组的指针数组，关系数组，标志数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyGraph_M</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">		<span class="built_in">free</span>(G.arcs[i]);</span><br><span class="line">	<span class="built_in">free</span>(G.arcs);</span><br><span class="line">	<span class="built_in">free</span>(G.vexs);</span><br><span class="line">	<span class="built_in">free</span>(G.tags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找顶点位序">查找顶点位序</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateVex_M</span><span class="params">(MGraph G, VexType v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">		<span class="keyword">if</span> (G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取顶点值">取顶点值</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k, VexType &amp;w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (G.n &lt;= <span class="number">0</span> || k &gt; G.n || k &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	w = G.vexs[k];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="置顶点值">置顶点值</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PutVex_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, VexType w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (G.n &lt;= <span class="number">0</span> || k &gt; G.n || k &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	G.vexs[k] = w;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求k顶点第一个邻接顶点">求k顶点第一个邻接顶点</h2>
<p>对于无权图，查找关系数组中的第<code>k</code>行第一个非零元素列号；
对于带权图，查找关系数组中的第<code>k</code>行第一个非<span
class="math inline">\(\infty\)</span>元素列号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FirstAdjVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt;= G.n)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((G.kind == UDG || G.kind == DG) &amp;&amp; G.arcs[k][i] != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((G.kind == UDN || G.kind == DN) &amp;&amp; G.arcs[k][i] != INFINITY)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="求k顶点某邻接顶点的下一个邻接顶点">求k顶点某邻接顶点的下一个邻接顶点</h2>
<p>将上一个操作的从第0列开始查找改为从第m+1列开始查找即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NextAdjVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (G.n &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = m + <span class="number">1</span>; i &lt; G.n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((G.kind == UDG || G.kind == DG) &amp;&amp; G.arcs[k][i] != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((G.kind == UDN || G.kind == DN) &amp;&amp; G.arcs[k][i] != INFINITY)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增加边或弧">增加边或弧</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">AddArc_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, <span class="type">int</span> m, <span class="type">int</span> info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; G.n || m &lt; <span class="number">0</span> || m &gt; G.n)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (G.kind) &#123;</span><br><span class="line">		<span class="keyword">case</span> UDG : <span class="comment">// 无向无权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] != <span class="number">0</span> || G.arcs[m][k] != <span class="number">0</span>) <span class="comment">// 边已存在</span></span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = G.arcs[m][k] = info;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DG : <span class="comment">// 有向无权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = info;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> UDN : <span class="comment">// 无向带权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] != INFINITY || G.arcs[m][k] != INFINITY)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = G.arcs[m][k] = info;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DN : <span class="comment">// 有向带权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] != INFINITY)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = info;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		deault :</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除边或弧">删除边或弧</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">RemoveArc_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; G.n || m &lt; <span class="number">0</span> || m &gt; G.n)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (G.kind) &#123;</span><br><span class="line">		<span class="keyword">case</span> UDG : <span class="comment">// 无向无权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] == <span class="number">0</span> || G.arcs[m][k] == <span class="number">0</span>) <span class="comment">// 边已存在</span></span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = G.arcs[m][k] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DG : <span class="comment">// 有向无权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> UDN : <span class="comment">// 无向带权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] == INFINITY || G.arcs[m][k] == INFINITY)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = G.arcs[m][k] = INFINITY;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DN : <span class="comment">// 有向带权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] == INFINITY)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = INFINITY;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		deault :</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深度优先遍历">深度优先遍历</h2>
<p>对于连通图： 1. 从指定顶点<span
class="math inline">\(v\)</span>出发，先访问该顶点； 2. 对<span
class="math inline">\(v\)</span>顶点的所有邻接顶点<span
class="math inline">\(w_i\)</span>依次检查； 3. 若<span
class="math inline">\(w_i\)</span>未被访问，则以<span
class="math inline">\(w_i\)</span>为新起点递归进行深度优先遍历。</p>
<p>对于非连通图，这样的过程仅能访问到开始顶点所在的连通分量，故需要依次检查图中的所有顶点，若未访问，则以其为新起点进行深度优先遍历，直到所有顶点都被访问为止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DFS_M</span><span class="params">(MGraph G, <span class="type">int</span> k, Status (*visit)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ERROR == <span class="built_in">visit</span>(k))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.tags[k] = VISITED;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="built_in">FirstAdjVex_M</span>(G, k); i &gt;= <span class="number">0</span>; i = <span class="built_in">NextAdjVex_M</span>(G, k, i)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (UNVISITED == G.tags[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ERROR == <span class="built_in">DFS_M</span>(G, i, visit))</span><br><span class="line">					<span class="keyword">return</span> ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DFSTraverse_M</span><span class="params">(MGraph G, Status (*visit)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化标志数组*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">		G.tags[i] = UNVISITED;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (UNVISITED == G.tags[i])</span><br><span class="line">			<span class="keyword">if</span> (ERROR == <span class="built_in">DFS_M</span>(G, i, visit))</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先遍历图">广度优先遍历图</h2>
<ol type="1">
<li>将所有顶点的访问标志初始化为<code>UNVISITED</code>；</li>
<li>依次检查所有顶点，若未被访问过，则：
<ul>
<li>访问该顶点，入队；</li>
<li>队列非空，队头元素出队，判断其所有邻接顶点是否被访问过；</li>
<li>若未被访问过，访问该顶点，入队；</li>
<li>重复以上操作直至队列为空。</li>
</ul></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BFSTraverse_M</span><span class="params">(MGraph G, Status (*visit)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	SqQueue Q;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">InitQueue_Sq</span>(Q, G.n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">		G.tags[i] = UNVISITED;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (UNVISITED == G.tags[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ERROR == <span class="built_in">visit</span>(i))</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			G.tags[i] = VISITED;</span><br><span class="line">			<span class="built_in">EnQueue_Sq</span>(Q, i);</span><br><span class="line">			<span class="keyword">while</span> (OK == <span class="built_in">DeQueue_Sq</span>(Q, k)) &#123;</span><br><span class="line">				<span class="keyword">for</span> (j = <span class="built_in">FirstAdjVex_M</span>(G, k); j &gt;= <span class="number">0</span>; j = <span class="built_in">NextAdjVex_M</span>(G, k, j)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (UNVISITED == G.tags[j]) &#123;</span><br><span class="line">						<span class="keyword">if</span> (ERROR == <span class="built_in">visit</span>(j))</span><br><span class="line">							<span class="keyword">return</span> ERROR;</span><br><span class="line">						G.tags[j] = VISITED;</span><br><span class="line">						<span class="built_in">EnQueue_Sq</span>(Q, j);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《数据结构》（高教版，吴伟民，李小妹）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机中的浮点数表示</title>
    <url>/Computer-Organization-single-precision-float/</url>
    <content><![CDATA[<p>本文介绍小数在计算机中的表现形式，基于IEEE标准。</p>
<span id="more"></span>
<h1 id="浮点数表示">浮点数表示</h1>
<p>浮点数(floating point)：二进制小数点不固定的表达数的记数法。</p>
<p>在许多编程语言中，都提供了一种或者多种浮点数类型。例如 C
语言中提供了双精度浮点类型<code>double</code>，单精度浮点类型<code>float</code>，这两种数据类型都采用浮点数来表示。<strong>浮点数</strong>
<span class="math inline">\(\pm m \times n^e\)</span> 是指由符号 (sign)
、指数 (exponent) 、尾数 (fraction) 、基数 (cardinal number)
四部分来表示的小数，数被表示为二进制小数点左边只有一位非零数的形式。在计算机中使用二进制表示数据，因此基数为2。因此计算机中的浮点数可以分成三个部分，符号，尾数和指数。</p>
<ul>
<li>双精度浮点数（64位）</li>
</ul>
<table>
<thead>
<tr class="header">
<th>1位</th>
<th>8位</th>
<th>52位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>符号部分</td>
<td>指数部分</td>
<td>尾数部分</td>
</tr>
</tbody>
</table>
<ul>
<li>单精度浮点数（32位）</li>
</ul>
<table>
<thead>
<tr class="header">
<th>1位</th>
<th>8位</th>
<th>23位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>符号部分</td>
<td>指数部分</td>
<td>尾数部分</td>
</tr>
</tbody>
</table>
<p>下面以单精度浮点数为例，双精度浮点数表示类似。</p>
<h2 id="符号部分">符号部分</h2>
<p>符号部分的表示使用1-bit
，和二进制整数的符号位表示法类似，符号位在最高位，0为正数，1为负数。</p>
<p>将符号放在最高为，可以快速测试出大于、小于、等于0的情况。</p>
<h2 id="尾数部分">尾数部分</h2>
<p>尾数：位于小数点的位数字段，值在0和1之间。</p>
<p>单精度浮点数中尾数长度是23个二进制数字。尾数部分是被正则化的，即小数点左边有且仅有一位非0数字，在二进制表示方式下，非0即1，因此这个数字只能为1，IEEE
754隐藏了规格化二进制数的前导位1，这样，23-bit 的尾数部分实际上可以表示
24-bit 的精度。</p>
<h2 id="指数部分">指数部分</h2>
<p>指数：位于浮点数的指数字段，表示小数点的位置。</p>
<p>但制数部分如果为负数，使用补码，可能会使得一个负指数显得像是一个大数，因此指数部分使用的是
EXCESS
系统，将中间数字设置为0，负数不需要负号来表示，将最小的负指数表示为<span
class="math inline">\(00\cdots00_2\)</span> ，最大的正指数表示为<span
class="math inline">\(11\cdots11_2\)</span>，这种记数法称为带偏阶的记数法(biased
notation)，要从带偏阶的指数中减去偏阶，才能获得真实的值。8-bit
的指数字段可以表示 256 个不同的指数值，但 0000 0000 和 1111 1111
有特殊含义，稍后再提。剩下的 254 个数值，即
1~254，实际的指数值等于该无符号整数减单精度偏阶127所得的值。</p>
<p>这样单精度浮点数表示为： <span class="math display">\[
N =(-1)^s \times （1+Fraction) \times 2 ^{Exponent-Bias}，\quad 1 \le
Exponent \le 254, Bias = 127
\]</span></p>
<h3 id="的情况">0000 0000 的情况</h3>
<p>如果指数字段是0000
0000，则代表指数值-126，且尾数中小数点左边默认数字是0（而不是1），这种情况下，浮点数值为：
<span class="math display">\[
N = (-1)^s \times 0.尾数 \times 2 ^{-126}
\]</span> 若指数与尾数均为0，则根据符号位表示 <span
class="math inline">\(\pm 0​\)</span>。</p>
<p>但为什么不是用$1.尾数 ^{-127} $呢？考虑以下情况，<span
class="math inline">\(1.11\cdots11\times 2^{-127}\)</span> 与 <span
class="math inline">\(1.11\cdots 10 \times 2 ^{-127}\)</span>
两个数相减的情况，差为<span class="math inline">\(0.00\cdots 01 \times 2
^{-127}\)</span>
，这个差值将无法使用这种表示法来表示。为了解决这种情况，在表示比<span
class="math inline">\(1.00\cdots 00\times 2
^{-126}\)</span>小的数时，我们用0取代被我们忽略的默认小数点左边的1。</p>
<h3 id="的情况-1">1111 1111 的情况</h3>
<ul>
<li><strong>尾数为0</strong> ：根据符号位表示 <span
class="math inline">\(\pm \infty\)</span></li>
<li><strong>尾数非0</strong>：表示 <code>NaN</code> 非数字， (Not a
Number)</li>
</ul>
<h2 id="ieee-754-浮点数的编码">IEEE 754 浮点数的编码</h2>
<table>
<thead>
<tr class="header">
<th>单精度</th>
<th></th>
<th>双精度</th>
<th></th>
<th>表示对象</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>指数</td>
<td>尾数</td>
<td>指数</td>
<td>尾数</td>
<td></td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>非0</td>
<td>0</td>
<td>非0</td>
<td><span class="math inline">\(\pm\)</span> 非规格化数</td>
</tr>
<tr class="even">
<td>1-254</td>
<td>任何值</td>
<td>1-2046</td>
<td>任何值</td>
<td><span class="math inline">\(\pm\)</span>浮点数</td>
</tr>
<tr class="odd">
<td>255</td>
<td>0</td>
<td>2047</td>
<td>0</td>
<td><span class="math inline">\(\pm \infty\)</span></td>
</tr>
<tr class="even">
<td>255</td>
<td>非0</td>
<td>2047</td>
<td>非0</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<h1 id="十进制小数转ieee浮点数">十进制小数转IEEE浮点数</h1>
<h2 id="方法">方法</h2>
<ol type="1">
<li>将十进制小数表示为二进制小数</li>
<li>正则化处理</li>
<li>根据符号确定符号位</li>
<li>计算指数部分</li>
<li>计算尾数部分</li>
</ol>
<h2 id="举例">举例</h2>
<p>下面我们将<span class="math inline">\(-6 \frac{5}{8}\)</span>
表示为IEEE浮点数：</p>
<ol type="1">
<li><p>首先将<span class="math inline">\(-6 \frac{5}{8}\)</span>
表示为二进制数: <span class="math display">\[
-6 \frac{5}{8} = -(1\times 2^2 + 1 \times 2^1 + 0 \times 2^0 + 1\times
2^{-1} + 0 \times 2^{-2} + 1\times 2^{-3}
\]</span></p></li>
<li><p>正则化处理得到 <span class="math inline">\(-1.10101 \times 2
^2\)</span></p></li>
<li><p>负数，符号位为1</p></li>
<li><p>计算指数部分：实际指数为2，加上127得到129，二进制表示指数部分为1000
0001</p></li>
<li><p>计算尾数部分，忽略小数点左边的1，得到尾数部分为 1010 1000 0000
0000 0000 000 。</p></li>
</ol>
<h2 id="c语言实现-1">C语言实现 <a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用于确认单精度浮点数表示方法的C语言程序（摘自《程序是怎样跑起来的》），做了一点小改动 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> data;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> buff;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">34</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;data);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把数据复制到 4 字节长度的整数变量 buff 中以逐个提取出每一位</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;buff, &amp;data, <span class="number">4</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 逐一提取出每一位</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">33</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">10</span>) </span><br><span class="line">          <span class="comment">// 加入破折号来区分符号部分、指数部分和尾数部分</span></span><br><span class="line">          s[i] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (buff % <span class="number">2</span> == <span class="number">1</span>) </span><br><span class="line">            s[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">         <span class="keyword">else</span> </span><br><span class="line">            s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">          buff /= <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s[<span class="number">33</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ieee-浮点数转十进制数">IEEE 浮点数转十进制数</h1>
<h2 id="方法-1">方法</h2>
<ol type="1">
<li>由第一位判断符号</li>
<li>由第二位至第九位计算十进制值减去127得到指数值</li>
<li>后23位为尾数值</li>
</ol>
<h2 id="举例-1">举例</h2>
<p>将浮点数 0 1000 0011 0010 1000 0000 0000 0000 000 转为十进制数：</p>
<ol type="1">
<li>符号位为0，该数为正数</li>
<li>指数字段 1000 0011 转为十进制数为 131，得到实际指数值为4</li>
<li>尾数部分为 0010 1000 0000 0000 0000 000，在小数点左边补1，得到1.0010
1</li>
<li>因为实际指数值为4，故将小数点右移4位，得到10010.1</li>
<li>转为十进制得到18.5</li>
</ol>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《计算机系统概论》</li>
<li>《程序是怎样跑起来的》</li>
<li>《计算机组成与设计——硬件/软件接口》</li>
<li><a
href="https://zh.wikipedia.org/wiki/IEEE_754#%E7%89%B9%E6%AE%8A%E5%80%BC">IEEE
754 - 维基百科，自由的百科全书</a></li>
<li><a
href="https://stackoverflow.com/questions/52141648/understanding-exponent-00000000-and-11111111-in-ieee">floating
point - Understanding exponent 00000000 and 11111111 in IEEE - Stack
Overflow</a></li>
</ul>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://gist.github.com/fish-404/a0b438ef508941dfe66fc0c712129a3a#file-expression_float-c">Source
Code - Gits</a><a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-顺序表</title>
    <url>/Data-structures-SqList/</url>
    <content><![CDATA[<ul>
<li>顺序表的描述与表示</li>
<li>顺序表的操作接口定义</li>
<li>顺序表的操作实现</li>
</ul>
<span id="more"></span>
<h1 id="顺序表的描述与表示">顺序表的描述与表示</h1>
<p>首先介绍线性表（Linear
List），线性表是一种允许在序列任意位置进行操作的数据结构。采用顺序存储结构表示的线性表称为顺序表。用一组地址连续的存储单元依次存放线性表的数据元素，以存储位置相邻表示位序相继的两个元素之间的前驱和后继关系。</p>
<p>顺序表的类型定义： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ElemType* base;     <span class="comment">// 顺序表存储空间的基址</span></span><br><span class="line">  <span class="type">int</span> length;         <span class="comment">// 顺序表当前长度</span></span><br><span class="line">  <span class="type">int</span> size;           <span class="comment">// 顺序表的存储容量</span></span><br><span class="line">  <span class="type">int</span> increment;      <span class="comment">// 顺序表扩容时的增量</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure></p>
<h2 id="本文中预定义的说明">本文中预定义的说明</h2>
<h3 id="预定义常量和类型">预定义常量和类型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">// 用作函数值类型，表示函数结果状态</span></span><br></pre></td></tr></table></figure>
<h3 id="数据结构存储结构的表示">数据结构（存储结构）的表示</h3>
<p>数据结构的表示用类型定义(<code>typedef</code>)描述。数据元素类型约定为ElemType，读者在使用该数据类型时自行定义，如<code>int</code>、<code>char</code>等简单类型。</p>
<h3 id="扩展引用调用">扩展引用调用</h3>
<p>为了便于算法描述，我们使用了 C++ 语言中的引用调用参数传递方式。</p>
<h1 id="顺序表的操作接口定义">顺序表的操作接口定义</h1>
<p>由于采用了顺序存储结构，如果在顺序表中插入或删除元素，则需要移动操作位置之后的所有元素。实际上，如果需要频繁地插入和删除数据，选择顺序表作为抽象数据结构是一个极大的错误。虽然下面给出了删除和插入接口的定义，但在这种情况下应该竭力避免使用顺序表存储结构。</p>
<p>顺序表的接口定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化顺序表L</span></span><br><span class="line">Status <span class="title function_">InitList_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> size, <span class="type">int</span> inc)</span>;</span><br><span class="line"><span class="comment">// 销毁顺序表L</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList_Sq</span><span class="params">(SqList &amp;L)</span>;</span><br><span class="line"><span class="comment">// 将顺序表L清空</span></span><br><span class="line">Status <span class="title function_">ClearList_Sq</span><span class="params">(SqList &amp;L)</span>;</span><br><span class="line"><span class="comment">// 判断顺序表是否为空，是返回 TRUE, 否则返回 FALSE</span></span><br><span class="line">Status <span class="title function_">ListEmpty_Sq</span><span class="params">(SqList L)</span>;</span><br><span class="line"><span class="comment">// 返回顺序表L中元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength_Sq</span><span class="params">(SqList L)</span>;</span><br><span class="line"><span class="comment">// 用e返回顺序表L中第i个元素的值</span></span><br><span class="line">Status <span class="title function_">GetElem_Sq</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span>;</span><br><span class="line"><span class="comment">// 在顺序表L中查找元素e，查找成功返回该元素在表中第一次出现位置，否则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Sq</span><span class="params">(SqList, ElemType e)</span>;</span><br><span class="line"><span class="comment">// 遍历顺序表L， 依次对每个元素调用visit()</span></span><br><span class="line">Status <span class="title function_">ListTraverse_Sq</span><span class="params">(SqList L, Status( *visit)(ElemType e))</span>;</span><br><span class="line"><span class="comment">// 将顺序表L中第i个元素赋值为e</span></span><br><span class="line">Status <span class="title function_">PutElem_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span>;</span><br><span class="line"><span class="comment">// 在顺序表L表尾添加元素e</span></span><br><span class="line">Status <span class="title function_">Append_Sq</span><span class="params">(SqList &amp;L, ElemType e)</span>;</span><br><span class="line"><span class="comment">// 删除顺序表L表尾元素，并用e返回</span></span><br><span class="line">Status <span class="title function_">DeleteLast_Sq</span><span class="params">(SqList &amp;L, ElemType &amp;e)</span>;</span><br><span class="line"><span class="comment">// 在顺序表第i个元素之前插入新的元素e，表长加1</span></span><br><span class="line">Status <span class="title function_">InsertList_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span>;</span><br><span class="line"><span class="comment">// 删除顺序表的第i个元素，返回到e，表长减1</span></span><br><span class="line">Status <span class="title function_">DelElem_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="顺序表接口实现">顺序表接口实现</h1>
<h2 id="初始化顺序表">初始化顺序表</h2>
<ul>
<li>分配存储空间</li>
<li>给定顺序表容量</li>
<li>给定扩容增量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> size, <span class="type">int</span> inc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  L.base = (ElemType*)<span class="built_in">malloc</span>(size * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == L.base)</span><br><span class="line">    <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">  L.size = size;</span><br><span class="line">  L.increment = inc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁顺序表">销毁顺序表</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList_Sq</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(L.base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将顺序表清空">将顺序表清空</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearList_Sq</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断顺序表是否为空">判断顺序表是否为空</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListEmpty_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求顺序表元素个数">求顺序表元素个数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求第-i-个元素值">求第 i 个元素值</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_Sq</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L.length)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  e = L.base[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序查找">顺序查找</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Sq</span><span class="params">(SqList L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; L.length &amp;&amp; L.elem[i] != e)</span><br><span class="line">    i++;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; L.length)</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问每个元素">访问每个元素</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">status <span class="title">ListTraverse_Sq</span><span class="params">(SqList L, Status(*visit)(ElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (L == <span class="literal">NULL</span> || L.length &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">      <span class="built_in">visit</span>(L.base[i]);</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值指定位序元素">赋值指定位序元素</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PutElem_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; L.length || L == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">  L.base[i - <span class="number">1</span>] = e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加表尾元素">添加表尾元素</h2>
<ul>
<li>判断表是否已满
<ul>
<li>若已满，扩容</li>
</ul></li>
<li>添加元素</li>
<li>表长 + 1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Append_Sq</span><span class="params">(SqList &amp;L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ElemType *newbase;</span><br><span class="line">  <span class="keyword">if</span> (L.length == L.size) &#123;</span><br><span class="line">  	 newbase = (ElemType*)<span class="built_in">realloc</span>(L.base, (L.size + L.increcement) * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">     <span class="keyword">if</span> (<span class="literal">NULL</span> == newbase)</span><br><span class="line">         <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">      L.base = newbase;</span><br><span class="line">      L.size += L.increcement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  L.base[L.length] = e;</span><br><span class="line">  L.length++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除表尾元素">删除表尾元素</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteLast_Sq</span><span class="params">(SqList &amp;L, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == L.length || <span class="literal">NULL</span> == L)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">  e = L.base[L.length - <span class="number">1</span>];</span><br><span class="line">  L.length--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入元素">插入元素</h2>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span></p>
<ul>
<li>判断参数<code>i</code>是否合法，不合法则返回异常</li>
<li>判断表是否已满，已满则扩容</li>
<li>从最后一个元素遍历至第<code>i</code>个元素位置，全部后移一位</li>
<li>赋值，表长加1</li>
</ul>
<p><em>由于插入元素需要移动数组元素位置，算法效率不高，因此在频繁需要进行插入操作的问题中，应避免使用此结构</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InsertList_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="type">int</span> k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; (L.length + <span class="number">1</span>)) </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (L.&gt;length == L.&gt;size) &#123;</span><br><span class="line">    	 newbase = (ElemType*)<span class="built_in">realloc</span>(L.base, (L.size + L.increcement) * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">         <span class="keyword">if</span> (<span class="literal">NULL</span> == newbase)</span><br><span class="line">             <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">          L.base = newbase;</span><br><span class="line">          L.size += L.increcement;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (i &lt; L.length + <span class="number">1</span>)   </span><br><span class="line">        <span class="keyword">for</span> (k = L.length - <span class="number">1</span>; k &gt; i - <span class="number">1</span>; k--)</span><br><span class="line">            L.base[k] = L.base[k - <span class="number">1</span>];</span><br><span class="line">    L.base[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.lenght++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除元素">删除元素</h2>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span></p>
<ul>
<li>判断参数<code>i</code>是否合法</li>
<li>判断表是否非空</li>
<li>取出删除元素</li>
<li>从被删元素位置开始向后遍历至最后一个元素，往前挪动一位</li>
<li>表长 - 1
<em>同样地，删除元素也需要移动数组元素，故如需频繁删除元素，也应避免考虑顺序表</em></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DelElem_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; L.lengh) </span><br><span class="line">    	<span class="keyword">for</span> (k = i - <span class="number">1</span>; k &lt; L.length - <span class="number">1</span>; k++) </span><br><span class="line">         	L.base[k] = L.base[k + <span class="number">1</span>];   </span><br><span class="line">        </span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="顺序表的优缺点">顺序表的优缺点</h1>
<h2 id="优点">优点</h2>
<ul>
<li>无需为表示表中元素之间的逻辑关系而增加额外的存储空间</li>
<li>可以快速地存取表中任一位置的元素</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>插入和删除操作需要移动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间的容量</li>
<li>造成存储空间的“碎片”</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《数据结构》（吴伟民，李小妹）</li>
<li>《大话数据结构》</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-循环顺序队列</title>
    <url>/Data-structures-SqQueue/</url>
    <content><![CDATA[<ul>
<li>循环顺序队列的描述与表示</li>
<li>循环顺序队列的操作接口定义</li>
<li>循环顺序队列的操作实现</li>
</ul>
<span id="more"></span>
<h1 id="循环顺序队列的描述与表示">循环顺序队列的描述与表示</h1>
<h2 id="队列">队列</h2>
<p>队列(Queue)是一种只允许在序列两端进行操作的线性结构。和日常生活中排队等待买票的法则相似，排在队头的人先买到票并离开队列，而新来的人则加入队尾等候。因此很容易理解队列仅允许在队头出队，在队尾入队。</p>
<h2 id="循环顺序队列">循环顺序队列</h2>
<p>采用顺序存储结构的队列成为顺序队列，和顺序栈相同，我们也采用动态分配空间的方式来获取这个存储空间。那么何为循环队列呢？为什么我们需要循环队列呢？试想，我们在排队等候买票的时候是不是有这样的场景，前面的人买完票就离开队列，而这时后面的人是不是每个人都要往前挪动一个位置呢？那么如果我们以同样的方法来处理我们的队列，每当一个元素出队的时候，就必须把后面所有的元素往前挪动一个位置，这样必然导致算法效率变低。因此，我们想到了将队列的首位相连，构成了一个循环队列。</p>
<p>循环队列类型定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ElemType* base;   <span class="comment">// 循环队列存储空间的基址</span></span><br><span class="line">  <span class="type">int</span> front;        <span class="comment">// 队头位标（指向队头元素的位置）</span></span><br><span class="line">  <span class="type">int</span> rear;         <span class="comment">// 队尾位标（指向队尾元素的下一个位置）</span></span><br><span class="line">  <span class="type">int</span> maxSize;      <span class="comment">// 队列的最大长度</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>
我们采用循环队列解决了元素出队时需要移动全部元素的问题，但是出现了一个新问题，在我们判空的时候我们采用的是判断队头位标和队尾位标是否一致的方式，而放在循环队列里，因为队列已经首尾相接，于是我们会发现这时候如果队列满了，队头位标和队尾位标也是一致的，解决方式有很多，比如：
1. 设置标志域标识队列的空或满，使用标志域数组同步记录 2.
设置长度域记录队列中元素个数，判断长度域即可 3.
少用一个元素空间，采用循环加一的方式，如果发现<code>Q.front == (Q.rear + 1) % Q.maxSize</code>则认为队满。</p>
<p>以下的实现中我们采用了第三种方式。</p>
<h2 id="本文中预定义的说明">本文中预定义的说明</h2>
<h3 id="预定义常量和类型">预定义常量和类型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">// 用作函数值类型，表示函数结果状态</span></span><br></pre></td></tr></table></figure>
<h3 id="数据结构存储结构的表示">数据结构（存储结构）的表示</h3>
<p>数据结构的表示用类型定义(<code>typedef</code>)描述。数据元素类型约定为ElemType，读者在使用该数据类型时自行定义，如<code>int</code>、<code>char</code>等简单类型。</p>
<h3 id="扩展引用调用">扩展引用调用</h3>
<p>为了便于算法描述，我们使用了 C++ 语言中的引用调用参数传递方式。</p>
<h1 id="循环队列操作接口定义">循环队列操作接口定义</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空队列 Q，最大队列长度为 size</span></span><br><span class="line">Status <span class="title function_">InitQueue_Sq</span><span class="params">(SqQueue &amp;Q, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 销毁队列 Q，Q不再存在</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span>;</span><br><span class="line"><span class="comment">// 将队列置空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span>;</span><br><span class="line"><span class="comment">// 判断队列是否为空，是返回 TRUE，否则返回 FALSE;</span></span><br><span class="line">Status <span class="title function_">QueueEmpty_Sq</span><span class="params">(Squeue Q)</span>;</span><br><span class="line"><span class="comment">// 返回队列 Q 中元素个数，即队列长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength_Sq</span><span class="params">(SqQueue Q)</span>;</span><br><span class="line"><span class="comment">// 取队头元素，用 e 返回，并返回 OK，若队列为空，返回 ERROR</span></span><br><span class="line">Status <span class="title function_">GetHead_Sq</span><span class="params">(SqQueue Q, ElemType &amp;e)</span>;</span><br><span class="line"><span class="comment">// 元素 e 入队，即在队尾插入元素 e</span></span><br><span class="line">Status <span class="title function_">EnQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span>;</span><br><span class="line"><span class="comment">// 队头元素出队，并用 e 返回</span></span><br><span class="line">Status <span class="title function_">DeQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="循环队列接口实现">循环队列接口实现</h1>
<h2 id="初始化循环队列">初始化循环队列</h2>
<ul>
<li>分配存储空间</li>
<li>置队列为空</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitQueue_Sq</span><span class="params">(SqQueue &amp;Q, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  Q.base = (ElemType*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == Q.base)</span><br><span class="line">    <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">  Q.maxSize = size;</span><br><span class="line">  Q.front = <span class="number">0</span>;</span><br><span class="line">  Q.rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁队列">销毁队列</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(Q.base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将队列置空">将队列置空</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">  Q.front = <span class="number">0</span>;</span><br><span class="line">  Q.rear = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断队列是否为空">判断队列是否为空</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">QueueEmpty_Sq</span><span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回队列长度">返回队列长度</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">QueueLength_Sq</span><span class="params">(Squeue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Q.rear - Q.front + Q.maxSize) % Q.maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取队头元素">取队头元素</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetHead_Sq</span><span class="params">(SqQueue Q, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (QueueEmpty_Sq(Q))</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  e = Q.base[Q.front];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入队">入队</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % Q.maxSize == Q.front)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  Q.base[Q.rear] = e;</span><br><span class="line">  Q.rear = (Q.rear + <span class="number">1</span>) % Q.maxSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出队">出队</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  e = Q.base[Q.front];</span><br><span class="line">  Q.front = (Q.front + <span class="number">1</span>) % Q.maxSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结">小结</h1>
<p>队列的方式也成为排队。我们前面举例了排队排票的例子，而队列的产生实际上是由于随机前来的购票乘客数量和售票处的处理速度不相符，通过排队起到缓冲作用。程序中也是类似的，为了协调好数据输入和处理时间的关系，采用类似于排队的机制。再内从上，实现这种机制的方式就是队列。当我们需要处理通讯中发送的数据时，或由同时运行的多个程序所发送过来的数据时，会使用这种对队列中存储的不规则数据进行处理的方法。队列一般以环状缓冲区(ring
buffer)也就是我们说的循环队列的方式来实现。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><p>《数据结构》（吴伟民，李小妹）</p></li>
<li><p>《程序是怎样跑起来的》</p></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-顺序栈</title>
    <url>/Data-structures-SqStack/</url>
    <content><![CDATA[<ul>
<li>顺序栈的描述与表示</li>
<li>顺序栈的操作接口定义</li>
<li>顺序栈的操作实现</li>
</ul>
<span id="more"></span>
<h1 id="顺序栈的描述与表示">顺序栈的描述与表示</h1>
<h2 id="栈">栈</h2>
<p>栈(Stack)是一种只允许在序列末端进行操作的线性结构。栈实现的是一种后进先出(Last
In First Out, LIFO)策略或称先进后出（First In Last Out,
FILO)，被删除的是最近插入的元素。栈与手枪中使用弹夹相似。在向弹夹装填子弹时，只能逐颗将子弹压入弹夹，最后压入的子弹位于弹夹顶部；射击时，弹夹顶部的子弹将最先被射出。</p>
<h3 id="顺序栈">顺序栈</h3>
<p>采用顺序存储结构的栈称为顺序栈，需要用一片地址连续的存储空间来存储栈的元素。根据这个特性，我们很容易想到通过一个简单的一维数组来实现这种结构，并指定栈顶位于序列末端。当有新元素入栈或栈顶元素出栈我们只需要改变栈顶位标即可。
C语言中一维数组的大小是预先确定的，存满后无法继续插入新元素，所以我们将采用动态分配连续一块连续空间来存储栈元素，栈满时，通过重新分配更大空间进行扩容。</p>
<p>顺序栈类型定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ElemType * base; <span class="comment">// 存储空间的基址</span></span><br><span class="line">  <span class="type">int</span> top; <span class="comment">// 栈顶元素的下一个位置，简称栈顶位标</span></span><br><span class="line">  <span class="type">int</span> size; <span class="comment">// 当前分配的存储容量</span></span><br><span class="line">  <span class="type">int</span> increment; <span class="comment">// 扩容时，增加的存储容量</span></span><br><span class="line">&#125; SqStack; <span class="comment">//顺序栈</span></span><br></pre></td></tr></table></figure> <strong>说明：</strong>
这里我们将栈顶位标<code>top</code>设置为栈顶元素的下一个位置，也有些做法是将栈顶位标设置为栈顶元素的位置，或者将其设置为指向栈顶元素位置的指针。本人查阅了一些资料，似乎没有看到关于这一点孰优孰劣的评论或分析，如有读者知晓，望指教。
## 本文中预定义的说明 ### 预定义常量和类型 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">// 用作函数值类型，表示函数结果状态</span></span><br></pre></td></tr></table></figure> ###
数据结构（存储结构）的表示
数据结构的表示用类型定义(<code>typedef</code>)描述。数据元素类型约定为ElemType，读者在使用该数据类型时自行定义，如<code>int</code>、<code>char</code>等简单类型。</p>
<h3 id="扩展引用调用">扩展引用调用</h3>
<p>为了便于算法描述，我们使用了 C++ 语言中的引用调用参数传递方式。</p>
<h1 id="顺序栈操作接口定义">顺序栈操作接口定义</h1>
<p>作为一个存储结构，自然需要关心元素的存取问题。栈上的 INSERT
操作称为压入(PUSH)，而无元素参数的 DELETE
操作称为弹出(POP)。除了入栈、出栈操作，栈的操作还有初始化，销毁，判空等常用操作，我们定义如下：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化顺序栈 S</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack_Sq</span><span class="params">(SqStack &amp;S, <span class="type">int</span> size, <span class="type">int</span> inc)</span></span>;</span><br><span class="line"><span class="comment">// 销毁顺序栈</span></span><br><span class="line"><span class="function">Status <span class="title">DestoryStack_Sq</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="comment">// 判断顺序栈 S 是否为空，若为空则返回 TURE，否则返回 FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty_Sq</span><span class="params">(SqStack S)</span></span>;</span><br><span class="line"><span class="comment">// 清空顺序栈 S （无元素，空栈，注意与 销毁顺序栈区别）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearStack_Sq</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="comment">// 元素压入顺序栈 S</span></span><br><span class="line"><span class="function">Status <span class="title">Push_Sq</span><span class="params">(SqStack &amp;S, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">// 顺序栈 S 栈顶元素出栈，并用 e 返回</span></span><br><span class="line"><span class="function">Status <span class="title">Pop_Sq</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="comment">// 取栈 S 的栈顶元素，并用 e 返回（与出栈区别）</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop_Sq</span><span class="params">(SqStack S, ElemType &amp;e)</span></span>;</span><br></pre></td></tr></table></figure> # 顺序栈操作的实现 ## 初始化顺序栈
根据顺序栈的类型定义，在顺序栈的初始化中，我们需要进行以下操作： *
分配存储空间 * 置栈为空栈 * 初始化栈的大小 * 初始化栈满时的增量
时间复杂度为<span class="math inline">\(O(1)\)</span>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitStack_Sq</span><span class="params">(SqStack &amp;S, <span class="type">int</span> size, <span class="type">int</span> inc)</span></span><br><span class="line">&#123;</span><br><span class="line">  S.base = (ElemType*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == S.base)</span><br><span class="line">  <span class="comment">/*allocation failed*/</span></span><br><span class="line">    <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">  S.top = <span class="number">0</span>;</span><br><span class="line">  S.size = size;</span><br><span class="line">  S.increment = inc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>
当调用内存分配函数时，存在找不到足够大小的内存块的可能性，这时函数将返回空指针。因此在我们分配顺序栈基址时应当测试内存分配函数的返回值，并在返回空指针时采取相应操作，试图通过空指针访问内存的效果是未定义的，程序可能会崩溃或者出现不可预测的行为。</p>
<h2 id="销毁顺序栈">销毁顺序栈</h2>
<p>通过调用 <code>free</code> 函数来释放 <code>InitStack_Sq</code>
中分配的空间。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryStack_Sq</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(S.base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>注意：</strong> <code>free</code>
函数的实际参数必须是先前由内存分配函数返回的指针，如果这个指针已经被修改，可能将导致未定义的行为。而若参数为空指针，函数<code>free</code>的调用将不起到任何作用。</p>
<h2 id="顺序栈判空">顺序栈判空</h2>
<p>我们在顺序栈的类型定义中定义了栈顶位标，因此判断顺序栈是否为空，只需要判断栈顶位标是否为
0 即可。 时间复杂度为<span class="math inline">\(O(1)\)</span>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">StackEmpty_Sq</span><span class="params">(SqStack S)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (S.top &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> TURE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="清空顺序栈">清空顺序栈</h2>
<p>清空顺序栈 S 即将 S
置为空栈，只要对栈顶位标进行修改即可，原来的元素仍在数组里，但已经不在栈里了。
时间复杂度为<span class="math inline">\(O(1)\)</span>. <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ClearStack_Sq</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">  S.top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##
入栈
首先应检查此时是否已经栈满，若栈满，则应该扩容。由于栈顶位标指向的是栈顶元素的下一个位置，因此只需要将新的元素放入栈顶位标
<code>S.top</code> 所指示的位置，并将栈顶位标加一即可。
时间复杂度为<span class="math inline">\(O(1)\)</span>. <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Push_Sq</span><span class="params">(SqStack &amp;S, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">  ElemType* newbase;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (S.top &gt;= S.size) &#123;</span><br><span class="line">    newbase = (ElemType*)<span class="built_in">realloc</span>(S.base, (S.size + S.increment) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> ==  newbase)</span><br><span class="line">      <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    S.base = newbase;</span><br><span class="line">    S.size += S.increment;</span><br><span class="line">  &#125;</span><br><span class="line">  S.base[S.top] = e;</span><br><span class="line">  S.top++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>注意：</strong> *
判断是否栈满实际上只需要使用<code>==</code>即可，这里使用<code>&gt;=</code>是为了防止误操作使栈顶位标大于<code>S.size</code>的情况。
*
如果<code>realloc</code>函数不能按要求扩大内存块，那么它将会返回空指针，而原有的内存块中的数据不会发生改变。
*
一旦<code>realloc</code>函数返回，一定要对内存块的所有指针进行更新，因为<code>realloc</code>函数可能会使内存块移动到了其他地方。在要求扩大内存块大小时，<code>realloc</code>会在「原先的内存块」上直接进行缩减，而不需要移动存储在内存块中的数据。如果无法扩大内存块（内存块后面的字节已经用于其他目的），<code>realloc</code>函数会在别处分配新的内存块，然后将旧的内存块中的内容复制到新的内存块中。</p>
<h2 id="出栈">出栈</h2>
<p>出栈前应该先检查栈是否非空，如果为空栈，则报错，否则用元素 e
返回，并对栈顶位标减一。 时间复杂度<span
class="math inline">\(O(1)\)</span>. <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Pop_Sq</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (S.top &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  S.top--;</span><br><span class="line">  e = S.base[S.top];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 取栈顶元素
同样地，在取栈顶元素之前，我们需要先判断栈是否非空，若空则报错，否则用元素
e 返回栈顶元素的值，此时不需要改动栈顶位标。 时间复杂度<span
class="math inline">\(O(1)\)</span>. <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetTop_Sq</span><span class="params">(SqStack S, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (S.top &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  e = S.base[S.top - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 小结</p>
<p>“栈”的原意是”干草堆积如山“。干草堆时用来临时保存家禽饲料的方式，在取用时，最后堆的干草会被最先取出来。而在程序中也是类似的，为了实现临时保存数据的目的，使用类似于干草推的机制，这种机制体现在内存上，就是栈。当我们需要暂时舍弃当前的数据，随后再原貌还原时，就会使用栈。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《数据结构》（高教版，吴伟民，李小妹）</li>
<li>《算法导论》（第三版）</li>
<li>《C语言程序设计现代方法》（第二版）</li>
<li>《程序是怎样跑起来的》</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-图的相关定义</title>
    <url>/Data-structures-graph/</url>
    <content><![CDATA[<p>图是一种比树形结构更复杂的非线性结构。在图结构中，允许多个结点之间相关，称为「多对多」关系。本文整理关于图的基本定义以及图的相关术语。</p>
<span id="more"></span>
<h1 id="图的定义">图的定义</h1>
<p>在图中，通常将数据元素称为<strong>顶点</strong>(Vertex)，顶点之间的关系称为<strong>边</strong>(Edge)。</p>
<p><strong>图</strong>(Graph)由有限点集<span
class="math inline">\(V\)</span>和有限边集<span
class="math inline">\(E\)</span>组成，记为 <span class="math display">\[
G = (V, E)
\]</span></p>
<p>顶点总数<span class="math inline">\(|V|\)</span>记为<span
class="math inline">\(n\)</span>，边的总数<span
class="math inline">\(E\)</span>记为<span
class="math inline">\(e\)</span>。</p>
<ol type="1">
<li>有向图</li>
</ol>
<p>用<span class="math inline">\(&lt;v, w&gt;\)</span>表示从顶点<span
class="math inline">\(v\)</span>指向顶点<span
class="math inline">\(w\)</span>的<strong>有向边</strong>，也称为<strong>弧</strong>(Arc)，<span
class="math inline">\(v\)</span>为<strong>起点</strong>，<span
class="math inline">\(w\)</span>为<strong>终点</strong>，起点与终点次序不能颠倒。当图中的边均为有向边，则称图为<strong>有向图</strong>(Digraph)。</p>
<ol start="2" type="1">
<li>无向图</li>
</ol>
<p>若边集<span class="math inline">\(E\)</span>是对称的，即当<span
class="math inline">\(&lt;v,w&gt;\in E\)</span> ，有<span
class="math inline">\(&lt;w,v&gt;\in
E\)</span>，则称为<strong>无向图</strong>。此时用无序对<span
class="math inline">\((v,w)\)</span>代替有序对<span
class="math inline">\(&lt;v,w&gt;\)</span>和<span
class="math inline">\(&lt;w,v&gt;\)</span>，称为<strong>无向边</strong>，简称<strong>边</strong>。</p>
<ol start="3" type="1">
<li>子图</li>
</ol>
<p>若图<span class="math inline">\(G = (V, E), G&#39; = (V&#39;,
E&#39;)\)</span>，当<span class="math inline">\(V&#39;\subseteq V,
E&#39; \subseteq E\)</span>，则称<span
class="math inline">\(G&#39;\)</span>为<span
class="math inline">\(G\)</span>的子图。</p>
<ol start="4" type="1">
<li><p>完全图</p>
<p>包含所有可能的边的图称为<strong>完全图</strong>。</p>
<ul>
<li>无向完全图包含<span
class="math inline">\(n(n-1)/2\)</span>条边。</li>
<li>有向完全图包含<span class="math inline">\(n(n -
1)\)</span>条弧。</li>
</ul></li>
<li><p>邻接顶点</p>
<ul>
<li>在无向图中，若存在边<span class="math inline">\((v,
w)\)</span>，则称<span class="math inline">\(v\)</span>和<span
class="math inline">\(w\)</span>互为<strong>邻接顶点</strong>(Adjacent
Verices)，或称<span class="math inline">\(v\)</span>和<span
class="math inline">\(w\)</span>相邻接。</li>
<li>在有向图中，若存在弧<span class="math inline">\(&lt;v,
w&gt;\)</span>，则称<span class="math inline">\(w\)</span>是<span
class="math inline">\(v\)</span>的邻接顶点，但<span
class="math inline">\(v\)</span>未必是<span
class="math inline">\(w\)</span>的邻接顶点。</li>
</ul></li>
<li><p>度</p>
<p>在图中，顶点的<strong>度</strong>(Degree)指依附于该顶点的边数。</p>
<p>对于有向图，又分为<strong>出度</strong>(OutDegree)和<strong>入度</strong>(InDegree)。</p>
<ul>
<li>出度：以该顶点为起点的弧的数目。</li>
<li>入度：以该顶点为终点的弧的数目。</li>
<li>有向图顶点的度为出度和入度之和。</li>
</ul></li>
<li><p>权</p>
<p>当图中的边或弧具有附加属性信息时，将此信息称为<strong>权</strong>(Weight)。</p>
<p>带权的图称为<strong>带权图</strong>，简称为<strong>网</strong>(Network)。</p></li>
<li><p>路径</p>
<p>如果顶点序列<span class="math inline">\((v_1, v_2, \cdots,
v_n)\)</span>从<span class="math inline">\(v_i\)</span>到<span
class="math inline">\(v_{i+1}(1 \le i
&lt;n)\)</span>的边（弧）均存在，则称顶点序列<span
class="math inline">\((v_1, v_2, \cdots,
v_n)\)</span>构成一条长度为<span
class="math inline">\(n-1\)</span>的<strong>路径</strong>。</p>
<ul>
<li><strong>路径长度</strong>：路径包含的边数。</li>
<li><strong>简单路径</strong>：路径上的顶点各不相同。</li>
<li><strong>回路</strong>：一条路径将某个顶点连接到自身。</li>
</ul></li>
<li><p>连通图和强连通图</p>
<ul>
<li><p><strong>连通图</strong></p>
<p>在无向图中，若顶点<span class="math inline">\(v\)</span>到顶点<span
class="math inline">\(w\)</span>有路径，则称<span
class="math inline">\(v\)</span>和<span
class="math inline">\(w\)</span>是连通的。若图中任意两个顶点都是连通的，则称该图为<strong>连通图</strong>(Connected
Graph)。</p>
<ul>
<li><strong>连通分量</strong>(Connected
Component)：无向图中的极大连通子图。</li>
</ul></li>
<li><p><strong>强连通图</strong></p>
<p>在有向图中，若图中任意两个顶点<span
class="math inline">\(v\)</span>和<span
class="math inline">\(w\)</span>，既有<span
class="math inline">\(v\)</span>到<span
class="math inline">\(w\)</span>的路径，又有<span
class="math inline">\(w\)</span>到<span
class="math inline">\(v\)</span>的路径，则称该图为<strong>强连通图</strong>(Strongly
Connected Graph)。</p>
<ul>
<li><strong>强连通分量</strong>(Strongly Connected
Component)：有向图中的极大强连通子图。</li>
</ul></li>
</ul></li>
<li><p>生成树</p>
<p>连通图的<strong>生成树</strong>(Spanning
Tree)是含有所有顶点且只有<span
class="math inline">\(n-1\)</span>条边的连通子图。</p></li>
</ol>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《数据结构》（高教版，吴伟民，李小妹）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型选择</title>
    <url>/Data-type-choose/</url>
    <content><![CDATA[<p>偶然发现关于数据类型选择之前没注意到的点，做此记录。</p>
<ul>
<li>整型</li>
<li>浮点型</li>
<li>字符型（字符型实际上属于整型的一种，但这里分开讨论）</li>
</ul>
<span id="more"></span>
<h1 id="整型">整型</h1>
<h2 id="取值范围">取值范围</h2>
<p>整型类型的取值范围会根据机器的不同而不同，但规定了如下最小值：</p>
<blockquote>
<ul>
<li><code>short int</code> 至少 16 位</li>
<li><code>int</code> 至少 16 位</li>
<li><code>long int</code> 至少 32 位</li>
<li><code>long long int</code> 至少 64 位</li>
</ul>
</blockquote>
<p>听上去长整型应该比短整型所能表示的值要大，但是这个假设并不一定正确。整型值之间相互的大小规则如下：</p>
<blockquote>
<ul>
<li><code>int</code>类型不能比<code>short int</code>类型短</li>
<li><code>long int</code>类型不能比<code>int</code>类型短</li>
</ul>
</blockquote>
<p>而标准并没有规定3个数值必须不同，因此基于上述规则，如果某机器的环境字长是32位，且没有指令能更有效处理更短的整型值时，可能上述提到的3个整型值都为32位。</p>
<p>当数值超过<code>int</code>表示的范围时，选用<code>long long int</code>。</p>
<p>对于特定的实现，确定整数类型范围的一种方法是检查<code>&lt;limits.h&gt;</code>。</p>
<h2 id="浮点型">浮点型</h2>
<ul>
<li>浮点数字面值在缺省情况下是<code>double</code>类型。</li>
<li>执行浮点数运算时选用<code>double</code>类型，精度高于<code>float</code>类型，而实际上单精度和双精度的计算代价相差无几，甚至有些机器运算双精度浮点数更快。</li>
<li><code>long double</code>提供扩展精度，但一般情况下没有必要，且会带来运行消耗。</li>
</ul>
<h2 id="字符型">字符型</h2>
<p>字符在本质上是小整型值。标准中没有规定<code>char</code>类型缺省是无符号型还是有符号型，取决于编译器，有些编译器将其作为有符号数来处理，有些编译器作为无符号数来处理，而另有一些编译器提供编译选项来选择<code>char</code>的类型。</p>
<ul>
<li><p>为了保持最佳的可移植性，把字符的值限制在有符号和无符号范围的交集之间</p></li>
<li><p>显示地将这类变量声明为<code>signed</code>或<code>unsigned</code>，可以提高可移植性，确保在不同的机器中在字符是否有符号方面保持一致。</p></li>
<li><p>只有当<code>char</code>类型显示声明了符号类型时才对其进行算术运算。</p></li>
<li><p>许多处理字符的库函数将参数声明为<code>char</code>，而若将参数显示声明为<code>signed</code>或<code>unsigned</code>时可能会带来兼容性问题。</p></li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《C++ Primer 中文版 （第5版）》</li>
<li>《C 和指针》</li>
<li>《C语言程序设计现代方法 第2版》</li>
<li><a href = "https://stackoverflow.com/questions/1074474/should-i-use-double-or-float">c++
- Sholud I usedoble or float? - Stack Overflow</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>空白</title>
    <url>/Essay-2019-blank/</url>
    <content><![CDATA[<p>本来想等到整个学期结束，最起码等到考完研究生的考试，再来写这些文字。然而对于无处不在的来自陌生人的笑声、议论声，我实在是招架不住了，既然已经意识到绝不可能通过初试，不如就写出来罢，也许会招来更多的非议也未尝可知。</p>
<span id="more"></span>
<p>上个月和小伙伴看电影的时候，曾经的组长问起现在在做些什么，草草地回答实习、准备考研，可自己知道那不过是为了掩盖自己碌碌无为的借口罢了。被问起那大三一年都在干些什么的时候，我所能想起的只有一片空白，只有听着别人议论自己的绝望和悲伤，仅此而已。</p>
<p>我并不清楚地知道事情是从什么时候开始的。不知道从什么时候起，就开始能听到议论自己的声音，但约莫是一年前的这时候，进而人们发现我是性少数群体后更加议论纷纷。再之后，是豆瓣账号，也许是从个人简介里看到了我的日常，于是就连兴趣爱好也成了大家议论的话题。这也是后来我删去了那段介绍的原因。刚开始我也并未觉得有什么大不了的，觉得大家也许讨论几天也就过去了，寒假回家就可以松口气了。</p>
<p>可事与愿违，独自一人走在家乡的街道的时候，也渐渐地会听到大家的议论声，开始时我还觉得大概是自己多疑，可慢慢地我终于发现人们在议论的确实是我。于是开始也不怎么出门了。</p>
<p>以为过了个寒假大家应该不至于再讨论我的事情，可事实上却是变本加厉。我不知道，是不是很多时候大家觉得我听不到，怎么议论也无所谓，觉得怎么议论我也不知道他们是谁。走在很多很多个地方，人们的议论声都无孔不入。即使在暑假在湖南的那段日子也未能幸免。有些时候，人们的笑声和议论声甚至有刻意为之的意味，唯恐我听不到。我始终不明白，我到底做错了什么？始终不明白，为什么过了这么久，大家还是不放过我呢？当然我也偶然能听到站在我的立场的人们，略有点欣慰，不过他们的力量终究太薄弱了。就像我曾经以为我总能应付过去一样，随着崩溃的次数和程度越来越超出自己的想象，我放弃抵抗了。</p>
<p>我不明白为什么大家为何能日复一日地重复着对我的议论，如果换做是你，每天这样都被人议论着，笑着，你会有什么感觉呢？你有没有想象过？</p>
<p>小时候很爱哭，父母总说因为这个原因所以声音沙哑。但打记事起，我曾经几乎不哭泣，而就在这一年里，大概过去十几年里也不曾如此伤心过吧。</p>
<p>我没有大家想象的那么好，也没有另一些人说的那么坏。我不知道大家在羡慕什么，大家好像总喜欢拿我会弹琴说事，可事实上，我所会弹的那些曲目，最少都练习过上百遍。大家到底都了解些什么呢？有些人甚至觉得我是在刻意引起大家的注意，可事实上，我最讨厌的，就是被大家关注着了，事实上，我觉得自己一无所长，被人们这样注视着，无时不刻感到非常惶恐。</p>
<p>我唯一感到抱歉的就是，在事情刚刚开始的时候，那段时间里我几乎每天都半夜才上床睡觉，无论多晚，总能看到对面的某间宿舍的灯还亮着，也许是我自作多情。但自打从经过了一段实习期后，连轴转地处理那么简单的工作都让自己感到疲惫不已，突然感到也许还是早点休息罢，尽管随之而来的可能是纠缠不清的许多噩梦，半夜惊醒，无法入睡，但仅仅是那么轻微的一个跌倒都竟然因为没有好好处理伤口到最后竟然要一点点地忍痛刮掉腐肉，敷上一星期的药物，越发地感到脆弱不已。实习的唯一好处，大概是终于可以独立，也许会再试着考一次，但也许明年还是先找个工作罢，如果能找到的话，也许自己已经不适合做研究了。</p>
<p>我不知道大家对我有什么误会，我想说的也就这么多了。</p>
<p>在今年的广美毕业展上的那些诗句里，看到过几个字，写着「天气或许晴」。我将其写在了日记本的第一页。</p>
<p>但后来随着时间的推移，我又在后面加上了这么几句。天气不会晴，天气一直阴，天气只有雨。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 1</title>
    <url>/Essay-2019-nCoV-personal-record-1/</url>
    <content><![CDATA[<p>自从疫情被公布以来，各类疫情资讯几乎占据了大部分消息流，甚至连平时以书影音为主要内容的豆瓣都充斥着疫情的点点滴滴。我所在的福建是疫情相对轻的地区，但就在今日也未能幸免进入百人疫情行列，想写写这段时间来，及至将来疫情结束自己的感受。仅作以自己的视角进行的记录，一次大概写个千来字吧。</p>
<span id="more"></span>
<p>翻了翻自己的日记，第一次写到疫情是1.20，那时候已经回家两个礼拜，对于疫情只略微的听说过，但在这时候已经可以看到在朋友圈和微信群里同学和家人在传播相关的信息了。这时候已经开始有人警惕，并呼吁戴起口罩。我并未多做关注，对自己活着这件事没什么执念，因此，也就对于病情，对于死亡，没有多在乎。</p>
<p>后来渐渐在朋友圈里看到了为父母不戴口罩而着急的同龄人，看到了为家人不以为然而心急如焚的哥哥姐姐，我只是旁观。哥哥姐姐将抢购口罩的状况发到了家庭群，家人也并未多做关注，一方面大概因为忙于生计，家务繁忙，一方面也是打心里不相信会有什么疫情的存在，相信那是距离自己很遥远的事情。大概因为当年SARS病毒没有入侵福建。当然这时候也有另一群人，笑着争相购买口罩的他人，以「福岛核事故的盐吃完了吗？」作讽。我仍不属于任何一方，只是旁观。这时候各个社交平台开始充斥起了真假难辨的各类疫情信息，疫情动态、官方公告、研究进展、物资告急、救援请求……</p>
<p>通过电报播报和友邻转发的消息窥探疫情，这期间我极少转发消息，一是不知道真假，二是有些疲惫，但其实感谢友邻的转发，才得以窥探到人性的恶在这场灾难前的千姿百态。在最开始开始关注疫情时，福建尚处于未发现确诊病例的状况，大家也都还不以为然。网上的疫情地图里福建被周围「沦陷」的省份包围着，大家纷纷调侃着福建以及相似省份的处境，这时候，大家的紧张还大多处于隔岸观火，互相调侃的境地，因为那是离自己很遥远的地方呢，那时候疫情的恐慌，也许只有身处险地的武汉人才懂吧。</p>
<p>在疫情蔓延的日子里，疫情地图的变化和曾经玩过的游戏瘟疫公司非常相像。在家里的台式机上安装过瘟疫公司的盗版游戏，时不时玩上一局，那时候玩着这个游戏看着红点增加，疫情不可控，直至最后游戏弹出世界所有人都被自己一手操纵的病毒消灭是很有些快感的。看着疫情播报里接连不断的消息流，像是曾经在游戏里看着世界地图里一片片地区亮起一个个小红点，看着红色区域一点点覆盖上地图，渐渐布满接近死亡的血色，像是在游戏里看到小小的通告栏里不断滚动的何处交通受阻，何处开始控制疫情，何处开始研发药物。不同的是，那时候的自己是怀着一种毁灭世界的心态玩着游戏，看着各地不断沦陷，巴不得早点达成游戏成就，从未想过这幅地图竟然会以这样的形式在现实里演绎，而自己，只是无奈看着，说句可能会招骂的话，极端地想来倒也想过世界毁灭算了吧，像电影，动画里演绎的那样。在疫情开始引起大家注意的那些天里，正好发生了同样惹人关注的医闹事件，网友戏称现实世界就是瘟疫公司的白痴模式，一幅漫画将其描绘得极为贴切，医生一手挥刀与魔鬼病毒战斗，一面侧身拿盾防着病人身后袭击。医生的无奈处境被那副漫画刻画得淋漓尽致。</p>
<p>突然地就思考起这样一个问题，医学的存在是因为人类对于生存的执念吗？</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 11</title>
    <url>/Essay-2019-nCoV-personal-record-11/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>2月4日，家人在群内转发了晋江市英林镇发现一例确诊病例此前曾参加宗族宴席的消息。很快这则消息传遍整个网络，网友戏称「晋江毒王」。在网络传播的消息中称当事人从武汉归来却谎称来自菲律宾，1月22日前后参加了几场酒席，并在酒席上与人喝酒划拳。划拳是泉州地区酒席上较为常见的风俗，就在年初时我还听到楼里传来嘈杂的划拳声。当事人一时间遭到各个网络平台网友的痛骂。与此前各类事件传播不同，此次当事人或其亲友在这事件发酵期间并未露面做出表态，也正因如此，再加上网传的一份英林镇在当事人确诊后下发的文件《致嘉排村广大村民的一封信》中的描述与传言基本一致，于是人们也就自然而然地将此事认定为事实，认定泉州即将成为重灾区，认定福建夹在广东浙江重灾省份间，此事一出恐怕在劫难逃。但仅以网传信息来看，当事人回来时当局并未发布疫情严重的消息，全国各地的紧张大多是从武汉封城那一天开始，对新闻关注较少的人们在此前很难关注到这个事件，很难说其有多少责任，况且即使是在武汉的人们，也并没有引起多大的重视。只是谎称归来地就有些过分了，后来看到报道称事实似乎并不是这样。</p>
<p>晋江市的病例统计计入泉州市统计数字中，与泉州市区也很近，有公交车可以到达，也多有曾经的同学是来自晋江，不禁还有点担心起曾经的同桌，但也并没有问问同桌的近况。泉州市民甚至包括整个福建各地的市民都有些担心此事可能引发大规模传染，同时看到有近日打算前往泉州或周边地区的人们也大多表示恐慌。豆瓣友邻次日发来询问，但其实，我们知道的，也并不比网友们知道的更多些。唯一知道的是，从2月5日起，晋江通往各地的路普遍被封，当天泉州市公安局也发布通报，对当事人以涉嫌危害公共安全罪立案侦查并采取强制措施。受此事件影响，泉州市各地防疫措施开始加强，气氛也紧张了许多。外婆家所在的村子决定于2月6日开始封村，镇上也决定商店歇业10日。同时当天传出另一则消息称，家附近的乌洲村据说有不少人参加了晋江的宴席，又引发了恐慌。尽管后来参加宴席的人出面澄清并不是同一个时间的宴席，并没有任何接触，但乌洲村的路口还是封上了，焊上了栏杆禁止出入。菜市场也仅开放半天，并且有人巡逻，同时家附近的部分路口也有不同程度的封锁。当晚，网传泉州当地的关岳庙关帝爷出巡，引得民众热情燃放烟花爆竹，说是「驱瘟」。但这特殊时期，不要说关帝爷出巡了，关岳庙也是没有开放的，次日果然看到官方辟谣。</p>
<p>尽管晋江事件引发了网友强烈的愤懑，但却少有看到后续报道，仅发现一篇采访报道<a href = "https://archive.li/Wc9Ns">《被声讨的“晋江毒王”：感到很抱歉，可我没撒谎》</a>（本文关于本事件的后续消息均出自此文）
，现在该文已经被删除。报道中记者采访了当事人的家人及当地村民。当事人家人表示他们从未谎称行程，在登记返乡人员时也是如实上报，酒桌上也并未参与划拳。从菲律宾归来的谣言可能出自当事人的父亲是从菲律宾归来，而告知当事人归来地是武汉和具体的返乡日期上从未瞒报，也有村民表示知道这一情况，而当记者联系登记人员求证时却被告知不便回应，这样看来大概村里也对谣传有着一定责任。1月31日，当事人的奶奶去世，不明原因，但因为在这期间当事人的家人陆续被确诊，人们质疑是因为传染。但其实老人家身体本就不好，当事人的家人们此次回家就是因为这个缘故。而当事人的手机在2月4日被警方取走，也许这也是人们一直未能看到当事人出面解释的原因吧。在记者的采访中，看到村委会悬挂的横幅「带病回乡不孝儿郎，传染爹娘丧尽天良。」，当事人的家人曾联系村里负责人表示不妥，但没有看到后续，不知道这横幅是不是被取下了，同时，也有多名村民对当事人表示谅解。所幸截止今日，没有出现大规模传染，但也许也是如此，后来就没有再看到过相关报道，不知道当事人及其染病的家人近况如何。</p>
<p>灾难面前，人人都是被害者，但谁又能说我们不是那加害者中的一员呢？</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 10</title>
    <url>/Essay-2019-nCoV-personal-record-10/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>2月2日前后，全国工厂、企业、学校普遍已发布最早复工返校时间，根据当地疫情的严重程度而多有差别。广东教育厅发布大中小学最早不早于2月28日开学。原定2月15日返校，之前车票开售的时候完全抢不到一天一班的直达车票，担心没票提前买了换乘车票。虽然学校还未通知，但那也势必晚于2月28日了，于是在2月2日退了提前买的车票，乐观地认为也许2月底就能开学，买了张3月1日的直达车票，大概很多人也是这么想的，那时候买票竟已经余票无几。然而依照现在的情况，恐怕是过于乐观了，就这几日的学校通知来看，开学仍是遥遥无期。本专业课已完结，倒无多大影响，只是本来计划开学后和导师面谈商量毕设的事情就只能设法线上请教了。双专业的授课老师在近日陆续发布了各自的QQ群，以教务系统的通知来看，3月能否开学还是未知。原本这个时期将要发布的春招也转为由辅导员在微信群内发布各个企业的春招消息，各类招聘会看来将会被线上面试取代，或许很快就将被待业求职的处境所吞噬。没想过，大学的最后一个学期会是如此残缺，想起上半学期的不堪，更是遗憾不已
。也许这学期就是回校答辩论文，收拾行李，打包回家，就是毕业了。以开玩笑的心态来说这句话，却理智地认为成为现实的可能性还要大些。</p>
<p>那天，此前在网络上掀起轩然大波的武汉红十相关报道和质疑遭到删除，进了<a href = "t.me/wuhancensored">2019肺炎疫情新闻赛博坟场</a>
。但同时，无论是武汉当局还是中央，都陆续派出支援红会的团队，而其他省市则公布为防止此类事件的措施。尽管官方不肯认错，可这事实摆在这，如果没有问题何来支援调查一说？同期进入坟场的另一张图片，是如何分辨官员和医护人员，看口罩便是。虽然图片造假的可能性也存在，但似乎并没有看到辟谣，而是一删了之。倒不知是谁更心虚？而《财经》当日的文章<a href = "https://telegra.ph/2019-nCoV-02-01">《统计数字之外的人：他人死于“普通肺炎”》</a>
也未能幸免，假设官方的数据并没有瞒报，但医疗资源有限，也就意味着也许很多人还来不及确诊，甚至还未计入疑似便不幸染病去世，这些「统计数字之外的人」很难估计，也不是空穴来风的胡乱猜测，在各类社交平台上急切求助的个体在各方努力联系下尚且很难得到一席床位，埋没在信息流里的呼救又有多少呢？尤其是对于网络并不怎么熟悉的群体，想必很是艰难。我无法想象如果我的长辈们这一代人被困这样的事件中，能发出多少求助。</p>
<p>2月3日，父亲开始上班，因为在同事中算是年长的，因而没有被调配到乡县援助疫情防控。而母亲的上班的店铺在这一天暂时性地复工，小姨当班，并无顾客，又开始停业，直至今日开始复工。虽然泉州的疫情并不严重，但直到今日，沿街店铺仍是极少开张，饮食店据说不许堂食，超市、企业、小区等入口大多需要测量体温。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 12</title>
    <url>/Essay-2019-nCoV-personal-record-12/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>2月5日，湖北一则口罩销售涉嫌哄抬价格被重罚的新闻引发网友质疑，以1元定价销售0.6元进价的口罩超出文件规定的15%标准，涉嫌价格哄抬，没收所得并处罚金。乍一听似乎还十分有理，也有人称挣国难财该罚，但大多数人觉得这简直是小题大做。当前物资紧张，网络上的口罩供应长时间断货，这药房有货可供该算是好事，即使售价稍稍上涨，也还在普通人所能支付的范围，难不成还要让本就难求口罩的人们反而倒网络上寻求各种来路不明的高价口罩么，如此一罚，岂不是逼着卖家只敢将口罩藏于私门，还是说，想借此重罚强势道德绑架，非要捐出才是？更可笑的是，更略高一些的口罩售价在同时期的政府销售中，却是为民谋福。近期我们当地的政府摇号口罩售价也略高于此。倒是同期看到不少疫区传来的菜价高涨消息，部分区域卖出的各种天价蔬菜比起这口罩是有过之而无不及，却不见有此重罚。</p>
<p>此时民众基本上已不是抢口罩，已几乎没有口罩可抢了，更多的是攒口罩。尽管各类媒体频频发布口罩正确使用方法，但看着防疫形势仍旧严峻，谁也不知道这口罩要戴到何时，都担心着不足以使用，多数人都是尽可能地节省着自家的口罩，水洗再用基本上是普遍现象。尤其是在我们这里，戴口罩现在更像是一个心理安慰，聊胜于无。家人们担心到时候小孩子上学没有口罩可用，大多攒着来自各方为数不多的口罩，父亲的单位在那几日发过一次口罩，回家时很是欣喜，但仍戴着布面口罩出门，留着一次性口罩生怕开学时的消耗不及防疫令的撤离。民众抢着口罩也就算了，大理征用口罩一事让人更觉稀奇，并且振振有词。这场景简直像是策略游戏里的劫掠，巧的是，还真有一游戏，其中有一个情节就是古代瘟疫爆发，大理小官念及物资不足，私自下令截下沿路镖车物资，备齐防疫物料。后来关于此事的讨论部分被屏蔽，最后终于难敌舆论，出面表态。又一细想，此事人们大呼奇闻，但实际上网友们在网上预定的各类防疫物品迟不发货，不也都是被当地征用了么？但这样的征用竟显得合情合理，称颂有佳，似乎也有种难辨是非的怪异。</p>
<p>2月6日，豆瓣日记停用，一直到前些天（2月20日）才恢复。本来借着豆瓣日记发布疫区日记和相关记录的人们被迫中止，别求他地。网络上最常看到的倒不是何处疫情如何如何，而是哪一条广播又被禁评，哪一个话题又被禁止，哪一则新闻禁止转发，哪一篇文章已被删除，哪一个账户已被封号，如此这般，不能一一列举。原文链接的分享此时倒成了最差的分享渠道，长图保存备受青睐，最好还能将其原文加入坟场和档案馆。网友们和删帖员竞速，看谁更早一步看到，甚至为此而刻意在深夜发帖，即使如此，也难逃被删。从前广播被删被移除还会有豆邮通知，现在倒是一声不响，你不去查看自己的动态流，甚至可能都不知道曾经发布的消息已不再留存，豆列里的收藏常常不可查看。这几天偶然读到一位身处武汉的诗人每天发布的日记，评论里的人们留言道半夜等着更新，怕清晨起来就看不到了，读过这两日的几篇，再去看时果然已不可查看。而在其公众号的历史消息里看到按照编号数字留存下来的文章不足一半。</p>
<p>「居庙堂之高」，曰，请讲，请诉民之疾苦；「处江湖之远」，道，无言，多言唯恐引灾。又见九州闭户，街头巷尾，罕见闲谈，坊间碎语，难觅踪迹。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 13</title>
    <url>/Essay-2019-nCoV-personal-record-13/</url>
    <content><![CDATA[<p>以自己角度写的疫情记录。</p>
<span id="more"></span>
<p>2月7日凌晨，看到李文亮医生去世的消息，各个平台、频道都发出了许多悼念消息，没过几分钟，又说仍在抢救，分不清真假，疲倦睡去，早晨起来时，再次看到报道抢救无效病逝。同时看到各个平台发出的悼念消息，看到民众自发的各种悼念方式：</p>
<p>频道各类疫情消息停止播报一天；</p>
<p>许多人换上黑白头像或医生头像；</p>
<p>丁香园将疫情实时统计变为黑白；</p>
<p>雪地里压雪痕书写大字以示悼念；</p>
<p>区块链上为医生刻不灭数字墓碑；</p>
<p>武汉市民夜里亮灯吹哨自发悼念；</p>
<p>世界各地华人自发举行悼念活动；</p>
<p>……</p>
<p>不能一一言尽。</p>
<p>与民众的自发悼念相比，尽管武汉市政府表示了悼念，却鲜见其他官方媒体的报道。世卫组织曾发推表示悼念，后来推文又被删除，现已不可访问，不知道是不是因为中间有报道仍在抢救中的缘故。当日人民日报在推特上也发表了相关推文，但后来被删除，账号也销声匿迹。大型官方媒体几乎是集体噤声。</p>
<p>李医生的去世直接引爆自疫情以来就已被人们质疑的「八人造谣」事件的声讨。但与此同时，李医生去世所引发的舆论和各类艺术创作却有很大部分进了坟场，被掩埋，被吞噬，更激起了民众对言论自由的诉求。从那一天起，网络信息的审查似乎进入了一个新阶段，更迅速也更广泛，就连最普通的日常记录也可能随时触发你所不知道的敏感词。</p>
<p>从后来的多方报道来看，李医生自身并非发现者，也是从其他医护中得到的消息，仅仅是因为将消息发到群内，甚至都不是直接发表到公开网络平台，就遭到警方训诫，这听起来甚至就像是你在日常的生活里发现了什么危险，本能告知亲友，却被告知属于造谣。近日读完财新第一期专题杂志和三联的两期专题杂志，都提到了早在12月官方就已经得知疫情，甚至对想要传播消息的医护人员予以批驳，但12月底的「八人造谣」事件却也是官方披露，央视多个频道对此事都做出了相关新闻报道，截图微博被删除，与训诫书摆在一起，更是讽刺。</p>
<p>2月13日，《经济学人》发表<a href="https://www.economist.com/obituary/2020/02/13/li-wenliang-died-on-february-7th">文章</a>哀悼李医生。这一天正是李医生的头七，许多网友自发换上悼念头像或是带着训诫词反语「不能，不明白」的角标头像，据传部分平台在当日禁止换头像操作，豆瓣爆出部分友邻收到系统豆邮通知头像被移除。但总体上，这一天的舆论不如2月7日那么疯狂，与其说是人们逐渐淡忘，更让人怀疑是强行「被」淡去。</p>
<p>距离李医生去世已过去近一个月，李医生的同事也在近日染病去世，3月5日国家卫健委将其追授为「全国卫生健康系统新冠肺炎疫情防控工作先进个人」，名单中出现了很多已逝医护人员的标识。此前国家监察委派出的调查组却是杳无音讯，大概需要再派一个调查组去调查？更有商人消费死者，打着李医生的名字卖书，抢注医生名字做商标。只剩下网友们在李医生的微博下方的温情回复作为事件后续黑洞里稀薄的微光。截止今日，疫情仍在世界各地疯狂蔓延，中国这个「吹哨人」也并没有能让其他国家采取更好的防护，大抵人类都相似罢。</p>
<p align="center">
医者焚心吹长哨，得来一纸训诫书。签字画押认造谣，九州闭户终成灾。
</p>
<p align="center">
花冠肆虐楚地封，听闻京城禁鄂人。鸟鸣春至芳菲时，愿君得闲入樱林。
</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 14</title>
    <url>/Essay-2019-nCoV-personal-record-14/</url>
    <content><![CDATA[<p>以自己角度写的疫情记录。</p>
<span id="more"></span>
<p>2月8日，国家卫健委新闻发言人发布引发疫情的病毒的命名通知，统一称谓为「新型冠状病毒肺炎」，简称「新冠肺炎」，英文名为“Novel
coronavirus pneumonia”，简称“NCP”。</p>
<p>此时距离武汉封城已过去了半个月，迟来的命名并不能改变民间的「武汉肺炎」称谓早已进入公众视野的事实，甚至曾经在BBC中文的网站上也看到过报道的大字标题写着这么几个字，而这个标签更是被广为使用。台当局在世卫组织发布明明后甚至建议媒体仍采用「武汉肺炎」的称呼，在BBC
News中文发推征集看法的评论区更是布满借此命名风波的嘲讽，并且举例历史上曾有的地名命名的疾病名称做为此称呼的支撑，截止今日，推特的搜索趋势上还能看到<code>Wuhan Virus</code>这个标签，卫健委公布的英文简称也几乎没有看到过使用的场所。</p>
<p>曾经在一个频道看到发布者以「武汉肺炎」作为消息标签，进讨论组提出标签不妥的想法，得来的却是以过往疾病也都这样命名的答复，甚至还创作成了一张类似海报的宣传图。不解于这种观点，分明武汉人受到的迫害已经有目共睹，就在那一天还看到有报道称湖北司机被困高速路，因为鄂字牌照寸步难行，「在高速上『流浪』」。因为有以地名相称的先例，即便不合理，也要守旧么？实际上曾有的先例，诸如「中东呼吸道综合征」「西班牙流感」「埃博拉出血热」等命名就曾造成地名污名化，尤以「中东呼吸道综合征」为甚，给世卫组织带来了不少批评。2015年5月8日，世卫组织就发布了<a
href="https://www.who.int/mediacentre/news/notes/2015/naming-new-diseases/zh/">新型人类传染病命名最佳实践</a>，呼吁科学家、国家当局和媒体减少地名污名化带来的负面影响。怎么倒有人高举昨日犯下的错，反批今日想挽救的局，还振振有词了？只是这疾病名称一经命名，人们口口相传，再加上当今网络媒体的传播，几乎是深入潜意识的存在，想要扭转就相当困难了。</p>
<p>这一天是正月十五，元宵节。</p>
<p>往年，元宵节大多都已开学，高中时会盼着这少有的假，即便仅仅是一个晚自习。上大学后大抵元宵后才开学，基本每年都会去看花灯。在泉州，元宵节比起春节要热闹许多，赏花灯是一个古老的传统，花灯展上用摩肩接踵一点也不为过。儿时灯展设在文庙，依稀记得父母排着长队买张票带着我进去游玩，整个庙宇，连同外面的广场都十分拥挤，幸运的话还能在街上看到游街队伍。后来，灯展改到城区的另一头，但人潮丝毫不减，可以说更为夸张了，几百米的街道上满是行人，会看到调动了大量警力以维持秩序。而今年，灯展不消说自然是取消了，街上几乎空无一人，往年店面门口都会挂上一个小花灯，整条街本身也是一处灯展，今年开展的店铺不多，大概也没有再布置小花灯了吧。</p>
<p>往年的元宵节大多有元宵晚会，今年因为疫情的缘故，不可能现场直播的各类晚会和电视节目纷纷想方设法改变形式。偶然看到湖南台元宵晚会主持人面对着空空的观众席，投放着网络上的弹幕，简直像是小说里刻意安置的另类剧情。后来看到的《歌手》节目则采取了让歌手们异地演唱，观众们异地投票的形式，不知道会不会成为未来综艺节目可能的新模式。央视的许多电视节目则特意在画面角落标注录制时间以防误会。</p>
<p>昔年华灯高悬，尤怨无暇细赏；今朝困于陋室，闲居难载欢歌。</p>
<ul>
<li>参考资料 <a
href="https://www.dw.com/zh/%E6%AD%A6%E6%B1%89%E8%82%BA%E7%82%8E%E9%82%A3%E4%BA%9B%E6%9B%BE%E5%9B%A0%E4%BC%A0%E6%9F%93%E7%97%85%E8%80%8C%E9%81%AD%E5%88%B0%E6%B1%A1%E5%90%8D%E5%8C%96%E7%9A%84%E5%9C%B0%E5%90%8D/a-52382120">武汉肺炎？那些曾因传染病而遭到“污名化”的地名</a></li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 15</title>
    <url>/Essay-2019-nCoV-personal-record-15/</url>
    <content><![CDATA[<p>以自己角度写的疫情记录。</p>
<span id="more"></span>
<p>2月9日，网传武汉软件工程职业学院被紧急征用作为新冠肺炎隔离点，学生私人物品被随意丢弃，当日23时官方发布致歉信。2月11日，网传武汉商学院出现隔离医疗点的志愿安保人员（男性）入住女生宿舍，翻动私人物品，传播私人信息，校方后来回应该安保人员已接受派出所处理。虽然在网络平台上曾看到过相关的照片和零零散散的揭露，但这两件事很快就淡出了人们的视线，几乎没有引发太大的舆论。大概因为更多生死攸关的事件需要报道，几乎也没有再看到过关于上述事件的跟踪报道，后来也极少能看到对于学生宿舍征用情况的公开消息。我对武汉的学校并不了解，但不免会假想如果疫情爆发在广州，在没能被有效控制下来的情况下，大学城是不是势必成为隔离的最佳场所？隔断出岛路径后就是孤岛一座了。基本上学生除非是当地人，假期离校时大部分私人物品都留在校内，仅带走少量行李回家。而疫情事发突然，蔓延程度超出预计，宿舍被征用作隔离点几乎是反抗无门，即使官方对此事做出致歉，却很让人怀疑事后学生宿舍是否还能恢复如初，相关的消毒工作是否完善几乎是无从知晓。截至目前，暂未看到相关信息披露，官方虽无报道但已落实估计会是个奢侈的期望。</p>
<p>2月10日前后，外公身体有些不适，但并未就医。当时正是疫情相对严重的时候，尽管整个泉州市的处境相对良好，但家人仍不放心让外公到城里来看病。后来几天症状加重，还是到镇上的医院做了检查，怀疑腰部骨折，当时泉州市确诊病例还未完全治愈，因此仍然选择了在家里静养。家人带着镇上医院的拍片材料和诊断单到市里开了点药带回家。昨日外公的身体情况更差，家人赶忙带着外公来到医院诊断，除了腰部的病症，肠胃状况也很成问题，晚上九点半进了手术室，手术情况并不乐观，比预计的结束时间迟了大概半小时，凌晨一点，手术结束，进了ICU观察。我第一次知道，即使得知手术结果也无能为力，却仍然等着外公病情情况的那种焦灼心情。医生说好在还不算太晚，再迟一些很可能就来不及了。幸好这段时间泉州地区疫情已基本处于防备状态了，如果是前阵子病发，也许顾虑着疫情，就很难及时送医了。</p>
<p>在众多疫情记录的文章中，也看到过几则对于其他病症患者无法就医的报道。读到的时候也只是觉得有这样一种情况存在，但离自己很远，尤其是我到目前为止几乎只有在体检的时候才会去医院，对于医院几乎是毫无概念，即使听说这样的情况，并不能产生多大的感受。在泉州这里疫情很轻的地方我们都如此担心，以至尽量避免前往医院。不能想象，在疫情严重的地区，医护资源和医院资源都基本倾斜于新冠肺炎的救治，突发疾病的人该向谁求助，长期患病在床的人又会面临怎样的困境。除了没等到确诊的新冠病人，这些因其他疾病而陷入两难的病人也是统计数字之外的现实，也许更多更无从记录。</p>
<ul>
<li>参考资料：<a
href="https://github.com/Pratitya/wuhan2020-timeline/blob/master/%E6%97%B6%E9%97%B4%E7%BA%BFTIMELINE.md">疫情与舆情：武汉新冠肺炎时间线TIMELINE</a></li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 16</title>
    <url>/Essay-2019-nCoV-personal-record-16/</url>
    <content><![CDATA[<p>以自己角度写的疫情记录。没想到过了两年，疫情对于生活的影响仍然会让我想要记录。</p>
<span id="more"></span>
<p>2翻了一下上一篇记录时间是2020年3月下旬，正好差不多是两年前，后来外公病重离世，自己也在找工作做毕设中断了记录。现在还记得的影响比较大的大概就是6月份无法返校开毕业典礼和拍毕业照吧。虽说原本就对毕业典礼和拍毕业照并没有太多的期待，但真正落空的时候还是会觉得好像大学生活没有一个终结点。当时学校限制了每个宿舍的四个学生分批返校收拾东西，也就是宿舍同一时间只有一个人，每个人只有最多3天的时间去收拾自己的东西。对于外省的学生来说，几乎是一个相当不友好的决定，学生们都只收拾了度过寒假的行囊回家，多半都还有很多东西留在学校，我的一些外省同学们便没有再回过学校，直接让舍友帮忙打包邮寄。我本人因为找了在广东的工作，另外宿舍里有非常多的书籍托舍友也很难收拾，便自己去了学校。3天时间，第一天到达几乎没什么时间了，用了第二天一整天的时间来收拾我的东西，大部分是书籍和一些小设备小装置，除此之外的衣服被褥生活用品倒是比较容易。大概从六楼分了六七趟搬了上百本书，一部分寄回家，一部分寄往工作的单位，一部分卖给了多抓鱼，还有很多放在宿舍没有搬出。也是这一次“搬家”，让我感到没有一个稳定的居所我可能不该买太多的书，很大程度上也影响了我目前购书的决定。</p>
<p>再后来2020年-2021年间日常生活并没有受到疫情的太大影响，深圳偶尔的散发病例也只是偶尔会出现检测核酸的要求，可能某一天出车站会意外地发现需要测核酸，但人们的出行并没有受到太大的影响，虽然仅仅准备短暂停留的人可能还是会担心因为偶发事件而滞留。值得一提的是，21年偶然看到的钢琴比赛，因为深圳的偶发疫情推迟了比赛时间，我也得以稍作准备报名参赛并进入了决赛。但非常不凑巧的是，决赛的地点厦门分别在暑期和国庆这两个赛委原计划预定的时间节点上都爆发了疫情，被迫两次改期，延期至了春节，我也因为疫情国庆害怕回家后可能滞留没能够回家。</p>
<p>时间线辗转到今年初，元旦后，我紧张地联系着自己的参赛曲目，准备着行程，预计多请几天假比赛后正好早点回家。不想，此时深圳爆发小规模疫情，从1月7日起，测核酸几乎成为了生活中一个无法被忽视掉的活动。而对于早已登记好请假信息，甚至已经准备买票或者买好票的游子，几乎是每天都在关注疫情的最新进展，担心无法正常回家，或者说，担心回家需要隔离不如不回去了。整整半个多月的时间，每天大家最关心的就是有没有可能回不了家，讨论各个不同地方返乡的政策，计算着还有几天连续0新增才可能赶上过年。当时泉州的政策是中风险返乡居家隔离，据说还要装设监控，听着这个政策，我几乎都打消了回家的念头。另外，截至比赛日，深圳尚未解除中风险，不便出行，也不方便录制视频参赛，于是这个参赛名额被保留至下届。但几乎是比赛当天晚上，深圳我所在的区域解除了中风险，同事们也有好些尚未退票回了家。由于泉州当时的返乡政策是全市低风险才不需要隔离，监测等措施，我仍在观望，买了两张车票，一张日期早一些，一张晚一些，等着看深圳是否有机会降为低风险。很幸运地，在预定回家前的两日深圳终于全市低风险，我也顺利回家。听说老家的人们都在担心我是不是无法回去过年。很戏剧性地，在回家后两天，到了正月初一，深圳再次爆发疫情，我们这批踩着中间空挡的几天低风险回家的人们算是最幸运的一批，在深小卫的公众号下看到了很多在返程途中不得不打道重返深圳的人们。</p>
<p>从那时起至今，深圳的疫情似乎就没有中断过了。回到深圳开工后，我也不像往常一样会独自跑到一些地方溜达。而深圳的疫情似乎却愈发严重了，从看到地铁需要出示48小时核酸，到公交也需要48小时核酸，到小区门口需要精准打卡进入，最后公司上班也需要48小时核酸了，这一切都让人觉得不可思议，不过有一点好处，楼下的工地终于不再没日没夜地大声敲打，终于有了片刻宁静。不过我没有想到，时隔两年，居然会遇到这种近似于事实封城的情况。3-13日晚，各种官方账号发布静默通知，不允许大多数企业开工。公司也在当晚宣布3-14日为调休。与此同时，泉州爆发疫情，看着我的家人们在群里转发泉州的状况，连夜做核酸。当夜，深圳各大超市菜场都挤满了人，甚至看到网上流传的视频，买菜的人和排队做核酸的人，两条队伍混杂在一起。直至第二天3-14日，我早早地下楼，以为前夜已经抢空了菜场的人们大概不会再进行抢购，但却看到楼下大大小小几个超市，凡是有卖果蔬生鲜的地方都人满为患。</p>
<p>3-14日突然多出来的一天，小区也其实没有什么出入限制，感觉就像是无故放假了一样。多出来的时间也让我终于让我有时间和契机去思考犹豫了很久也困惑了很久该不该去做的一些事情。尽管这一天的空白后面仍是需要补回来的，但从某种程度上来讲，我非常感激这一天，让我能有这一段空白时间，做了一些对自己来说我想是很重要的决定。但我在泉州的家人们就没有那么轻松了，有的亲戚在发现确诊病例的工业区工作，有的亲戚在发现确诊病例的小区居住，而我家则列为管控区域。当天我意外地发现虽然我远在深圳，闽政通的健康码却也和我的父母一样变为了黄码，而我的几个更接近疫情的亲戚却仍是绿码，一时间被这个赋码规则搞得哭笑不得，怀疑它是以户籍地作作为优先判断标准。不过，当时我没有想到，福建码会影响到粤康码，也没有理会那个变黄的福建码。</p>
<p>3-15日公司继续调休。这一天，我意外地发现自己的粤康码由于同步了福建码的信息变黄。泉州其实对于黄码人群并没有特别多的管控和限制，但深圳的黄码人员却要到医院去测核酸。这整一天的很多时间里，我都在和别人解释我的黄码，同时也在想各种办法看看是否能赶紧让它变绿。当日，深圳的小区大多开启了近乎封闭的管理，进出需要凭借同行条，每户限制一周内的采购次数。我从医院做完核酸回来，因为黄码被暂时挡在了小区门外，解释了很久自己为何是黄码，但对方大多觉得很不可信，而现实却又真的这么荒谬，最后他们还是放我进了小区，后来我每一次跟被人解释我的黄码几乎都会遭到对方的质疑，对方并不真的认为是户籍地的原因，总更相信一定是我自己接触了什么人员或者偷懒未做核酸，但我所在的区域仅规定了3天2检，本来就不需要每天检测。另一边福建的客服人员估计也是忙不开了，大多数电话都很难打通，也没有在官方渠道上看到什么可以申诉赋码错误的入口。后来，老爸找到一个录入外省核酸的入口，我上传了两条信息等待审核。过了很久，审核通过后，我的福建码变绿。3-16凌晨，我的粤康码同步变绿，数据大抵是零点更新罢。</p>
<p>3-16日，开启居家办公，通过自己的电脑远程登录到公司的电脑。
作为一个程序员，我倒觉得这样的工作方式很不错，如果不需要去追那些迟迟未决的需求，仅仅作为单纯的开发人员，我甚至觉得远程是更好的工作方式，更自由，也更能专注。此前也看过一些远程开发的程序员手记，我对那样的生活和工作非常痴迷，虽然当然不是想以疫情被困这样的方式去接触（笑）。同日，我的父母也都停工了，父亲虽然是公务员，但由于他的黄码，倒免于去轮换倒班。</p>
<p>3-16日晚，物业在群里接龙统计核酸检测情况，按户接龙，包括户号，居住人数，核酸检测人数。此前在1月份物业就已经使用过这样的方式统计，当时我没有接龙，也指出居住人数这种信息对着户号发出来到群里并不合适，不如采用问卷，但物业并没有理睬。而这个接龙其实也是不告而终，当时整个小区有好几个群，住户完全混杂，几百人的群想通过接龙去统计，除非物业打算每条信息仔细看仔细登记，否则根本就不可能完成。后来物业就拆分了楼栋群，群人数规模稍微缩减，住户也不再那么混杂，但我没有想到，时隔两个月，他们又企图以同样的方式去统计信息，当然我也没有参与接龙，提出反对意见依然没有被理睬。稍微计算了一下，一栋楼，每层8户，34层，扣掉1层，33层，一共有264户，而群里有多少人呢，不到230人，也就是说，这个群甚至都不可能有所有的住户，另外还要扣掉可能并不住在这栋楼的物业人员自身，以及可能有住户多个家庭成员都在群内。</p>
<p>令我没有想到的是，3-16日这一天下午晚些时候，我无意间打开福建码，发现它不知何时又黄了回去。以前一天观测到的行为来看，第二天我的粤康码又该变黄了，而以广东地区的标准，从码变黄起算第一天，3天2检后才能变为绿码。想着如果有24小时的核酸检测记录会不会就不变黄了，跑下楼问了社区的工作人员，我怀疑他们根本觉得我在编故事，只是怂恿我赶紧去做核酸，尽管我前一天已经做过了，无奈之下，我又排队做了一次核酸。很不幸地是，这个核酸检测中的记录并不能阻止我的粤康码变黄，3-17日我眼睁睁地看着它再次变黄，又开启了新一轮黄码。这一天，我再次打了多个电话，但似乎无论是福建还是广东，都没有办法去解决这样一个情况，似乎只有福建码的开发维护人员可以处理，而他们的电话不管你打几次几乎都是忙线，按了十次继续等待就被挂断。这次去医院检测还很不幸地被门口的社区工作者划掉了一次物资采购机会，当晚有人在群里抗议这样的处理，今天看小区似乎已不再扣减去医院的人员的次数，但也并没有要求出示更多的证据，可以这么说，只要你有底气，你甚至可以回回说是去医院。这一天，核酸检测点搬到了小区内部，人们再也无法借着测核酸的借口外出溜达，买菜和采购了。</p>
<p>3-18日，福建码崩溃，我突然无法预测自己第二天的粤康码了。其实我一直很好奇，已经过了两年，这些项目却没有什么长进，无论是它的并发量还是它的算法似乎都存在着各种漏洞，官方推出了一个小程序救急。那看看广东地区，1月份测核酸的时候大家就发现多出了123456这样的字样，这到底是有多无奈才拆分出了这么多个部署，甚至还有人辩护可能是为了区分地区，如果真的是区分地区，我不相信它会以数字命名。更何况，这种123456的命名方式几乎是只有写练手程序时的程序员才会进行的操作，它几乎是一种类似于临时变量的存在。但我也并不惊讶，实习的阶段就是跟着参与设计政府项目，那之后我完全明白了为何政府的系统很多都很难用。我也不再跟别人解释我的粤康码情况，他们也无能为力，除了增加他们对我的质疑，并没有什么更多的作用了。与此同时，据说由于福建码的崩溃，泉州地区的那些超市实际上都已经无法通过赋码颜色来控制人的出入了。我仍然看着家庭群内的讨论，泉州地区也开始逐步封闭街道。这可能是疫情爆发以来，泉州人面对疫情最近的一次，代价也很惨重。此前无论是刚刚爆发疫情，还是福建省多点散发，其实泉州都没有受到太多的波及，大家几乎都处在防范可有可无的状态，路上不戴口罩的人其实很多，有时候也包括我自己，大家更接近于疫情爆发前的生活状态，甚至我的父亲在公共交通工具上都还要我去提醒他。当然，泉州的封城根本不可能做到像深圳的封城一般在保障民生供应不受影响的情况下进行封控和管控，更不要说深圳的集体隔离时隔两年又重蹈征用学生宿舍的风波了。当晚福建码恢复使用，我想，他们可能改进了算法，发布了新的版本，我的码终于不再黄绿反复横跳，但我家人的码仍然存在反复横跳的情况。这一周以来，我竟然不是因为所处的深圳被赋黄码，而是因为一个户籍所在地被赋黄码，真是让人匪夷所思。</p>
<p>截至目前，我家所在街道已经变成了高风险地区。两年前，我看到网上的各种无助的信息时，曾经想过，如果是我的父母，他们会不会连这样的信息都无法扩散出来，后来，我并未再去思考这个问题。而今日，我确实感到，他们对于网络世界的陌生，无法得到更多信息，无法发出更多声音，好在我的同龄亲戚们还多少能告知他们一些信息。</p>
<p>大概因为太久没有记录了，一口气写到了半夜。早晨起来，又看到了泉州的物资求助信息，担忧的同时也发现那条信息几乎没有留下更有效的联络方式，外界的人们几乎很难去了解和帮助到我的家乡。我同时也翻看了其他的一些官方渠道的求助发布或者捐赠发布，似乎都比较混乱，它很难让人明确知道泉州到底是怎样的处境，除了新增数字不断攀升的视觉冲击，几乎无法再得到更多的情况。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 17</title>
    <url>/Essay-2019-nCoV-personal-record-17/</url>
    <content><![CDATA[<p>以自己角度写的疫情记录。</p>
<span id="more"></span>
<p>3月20日早晨醒来，我的朋友圈里全是我的泉州友人们转发的物资捐赠求助，那则通告除了写联系人的联系方式和落款单位名几乎没有提供任何有效的信息，甚至连接收地址和物资需求都未能写明。我记得2年前看到过的其他地方的求助信息都没有如此潦草过，几乎无法了解泉州的处境，只是看着那个数字跳跃式的刷新，或许那个数字的增长都已经让人麻木了。后来看到同学整理了一份文档，大概是目前官方发布出来的一些信息整合，其中添加了一条红十字会的捐赠通道，但这个通道却似乎只有在他们的捐款名单里出现过，同样是模糊不清的描述。看到有个定居泉州的东北友邻，去了解了一线防疫人员的情况，物资确实紧缺，她也在各种社交平台上筹集到了不少的物资，却苦于没有方法入城，同时，官方又声称只能由官方统一接收调配，最终，当日友邻筹集到的物资仍有一大部分由于没有有效的渠道入城而被迫取消。与此相对地，当天我在家庭群里看到了一些不知转自何处的声明，声称物资充足，请大家不要造谣，更可笑的是，后来官方也做出了类似的回应，真是有些让人匪夷所思了。又看到泉州人在转发什么没有人关注，没有上热搜之类的推文。一边想要遮遮掩掩，一边又想要引人瞩目，搞不清是什么名堂。</p>
<p>同时深圳也已到了事实封城通告的最后日期，却迟迟没有见到相关的上班通告和解封通告，居民们都在好奇，出入还需不需要放行条，次日是否可以恢复正常的作息。实际上，小区刚刚宣布准备封闭的时候，很多人甚至是打点了简单的行囊，我在门口就遇到过几次提着被子和洗漱用品的人们，据说是住进了公司。一直到晚上七点左右，才得到复工的通知。我所在的地区并没有病例，却还是执行着48小时核酸入园精准打卡的命令。</p>
<p>上周的意外停工，当时公司发布的通知是调休。其实我很疑惑，听说似乎20年公司就经历过远程办公的了，不知道为什么这次似乎还是有点混乱，好像并没有应急机制。后来发布的通告也并不是什么调休，而是优先从加班补休，年假中扣除，好像还觉得反正大多数人都加班了，这么安排是为员工着想。当然我们的工种还算幸运，不是整个一周都停工，不至于年假一下就被扣光了。</p>
<p>因为泉州的疫情，家庭群里久违地热闹，每天看着住在泉州不同地方的家人们发着自己和周边人的生活。有一些家人似乎领到了自测的试纸，有些家人则发来离谱的核酸采样开放时间，甚至有的设点全程在半夜。他们几乎都停工在家，也不像我的工种能够远程进行，同时又因为所在地区中风险，健康码黄码也很难去各种公共地方，担心着买不到菜，常常看到他们发趁着核酸日采购的照片。到后来，数字的增长似乎都已经很难让人再有什么反应了。政策的变动也非常快，猝不及防地就会接到不能出门的消息，甚至连几天一次的通行条也被收走。渐渐地，家里又被调高了风险等级，变成了高风险地区，健康码变成了红色，陆续地不能出门了，我甚至看到泉州公安的通告：</p>
<blockquote>
<p>出户、串门、聚集，最高可拘留10天</p>
</blockquote>
<p>今早问了父母，昨天开始完全出不去了，路口都被封禁，家里几天前囤了点菜，暂时没什么大问题。只是，这样的状况不知道会持续多久，据说从网上订购的邻居们也等了很久没能拿到货，更何况我的父母对网上的各种不同平台的订购几乎一无所知。</p>
<p>翻了一下20年写的第一篇，我还写着等到结束，现在看起来倒无休无止了。各地的应对似乎也没有比两年前进步多少，还是铺天盖地地看到各种荒谬，人们生活的重心仿佛被砍掉了一大块，摇摇欲坠起来。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 18</title>
    <url>/Essay-2019-nCoV-personal-record-18/</url>
    <content><![CDATA[<p>以自己角度写的疫情记录。</p>
<span id="more"></span>
<p>两年前的今天，外公病逝，从他住院到病危，我都没有被准许去探望，妈妈常常在家里念叨着想到外公只能在病房里孤零零很是难过，而我对外公最后的记忆也永远停留在那年春节的年初一，停留在外公看到我们很快就要离开准备着后辈们喜欢的食物的那一帧。当时武汉的形势已经严峻，即使是在泉州恐慌也渐渐开始蔓延。那一天回家，家人们间或谈论着疫情，不时地有人接到从其他地方打来的电话告知当地的政策，几乎所有人都陆陆续续取消了探亲的计划。在周围到处是田地的乡下，你几乎很难想象疫情会与这里有什么关联，除了节假日，这里很少与外界有什么往来，我想外公和外婆大概也不太理解，只是看着后辈们因为各种原因匆匆离开，还带着口罩。从前看到过很多因求学或工作在长辈去世前无法探望的桥段，而如今，疫情似乎已把它变成了常态，甚至于除了新冠以外的其他病人在某些地方还能去到医院都变成了很难的事情，因为疫情无法求医，药物短缺的消息几乎在每个地方都上演着。</p>
<p>上月泉州爆发疫情以来，我的家人们几乎都被困家中，爆发初期都不相信事情会变严重，对适当储备的消息置若罔闻，两年前他们也不相信几乎无疫情的地区口罩也会短缺。渐渐地，封锁的政策严格了起来，不再能自由外出。幸运的是，那些片区的小区社区都还算有所作为，人们能收到些许补给，周边的超市也还有一两家能够送货，看到家人在群里发买到的菜稍感安心。或许也是因为户籍赋码的机制仍然在闽政通的程序里扮演着主要角色，所以还是有些许亲友能正常通行。而在小城的另一头，老城区的日子似乎就没有那么容易了，看到住在泉州的友邻常常发着自己的粮食储备已不多。这几日看到泉州逐渐解封，但人们仍然害怕着楼下救护车的声音，害怕着突然出现的防疫人员，我看到我的家人们常常在群里发哪个路段看见了防疫人员，哪个小区似乎被隔离，哪个楼栋似乎被“迁移“。说起来，泉州的疫情虽然严重，但实际上在这些小地方几乎很难频繁地大规模排查，更多的是诸如封路，商场关停，我在深圳做核酸的次数似乎比我的父母还要多，几乎没什么病例的地区也仍在执行着场所码打卡。深圳地区的疫情形势渐渐好转，图书馆等公共场所陆续开放了，今天也小朋友们也终于背起书包上学。</p>
<p>上个月深圳的时候，很多人不敢相信，过了两年多，一线城市仍然要做出这样的决定，当时我的友邻表示非常震惊，后来聊起来才知道对方那里已经封城一月有余，数着日子排队下楼抢菜买菜是常态，近日看到对方城市的处境终于也渐渐好转，为能吃上久违的食物感到欣喜。后来上海也陷入了困境，人们用鸳鸯锅调侃着政策。我看到前同事也不得不加入抢菜的行列，有几个友邻似乎也没能买到充足的物资，不得不挨饿，成片的信息流里上海的新闻几乎每天都在刷屏，赛博坟场里也每天都堆起一座座新坟。因为新冠政策离世的人们似乎比因为新冠本身病逝的人还要多，很难相信时隔两年多又有一线城市陷入这样的困境，或许比当时武汉的处境更糟糕。但实际上，新冠疫情图上最严重的区域并不是上海，友邻说封城像是击鼓传花，的确，它不断地在更多的地方上演，人们永远不知道鼓点什么时候会停下，不知道什么时候一纸封城令飘下荒谬就随之而来。在更多的小城市里，人们的处境或许更艰难，尤其是各地较为年长的人们。两年多前，人们囤积口罩，而现在，人们常常谈论如何储备食物，封城中的人们能得到一些往日随手可得的食材就很感激。解决温饱问题竟然仍会出现在当前的时代，人们在社交平台上晒着来之不易的食材，好像不同时代被裁剪拼接在了一起，分不清这究竟是哪个年代。</p>
<p>春天已至，路上的羊蹄甲缤纷盛开，办公室外的天台常常能听到各式的鸟鸣，人类仍不得不戴着口罩，三句话不离疫情。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 19</title>
    <url>/Essay-2019-nCoV-personal-record-19/</url>
    <content><![CDATA[<p>以自己角度写的疫情记录。</p>
<span id="more"></span>
<p>四月底深圳的公共场所基本都已经开放了，但72小时核酸却一直没有停止，而公交甚至装上了播报系统，当你扫码购票完成后，它会自动播报你的核酸有效期，很有点科幻小说的魔幻感。虽然多有忧虑政策变化，还是在五一假期回了家。或许是因为刚刚解封，车票比想象中的容易买了许多。当天的列车里竟有不少都是抵达泉州的乘客，候车的时候听到闽南话的交谈，听到带闽南口音的普通话，才发觉所在的深圳偏远地区看起来有不少同乡人。</p>
<p>出站口立着三块布告板，贴着二维码，看起来是要乘客登记信息，几块布告板旁簇拥着回家心切的乘客，人人都想赶快填写完以便离开，站在前面的人挡着后面的人，而要填写的信息太多，乘客常常忘记离开，因而人群显得更无序更拥挤。后来我才知道前面还有其他的点，本不必在此拥堵。扫二维码的坏处是大部分人都是打开扫码的程序，一扫开就开始填，期间只要不慎一滑返回，就得重新挤进人群扫码，另外由于有多个二维码要扫描，每一次填完一项你也得再次挤入人群。后来我终于意识到了这点，再次挤进人群的时候，将其逐个拍照，找了个靠边的地方填写，顺便也给身边的乘客扫描。填写期间一位乘客几番问我该如何填写，其实那个表单的信息提示还算是比较详尽了，但或许由于要填写的信息实在太多，且不同的表单又有重复的项，对于年纪稍大的人来说或许确实是很有些为难，如果是我的父母来填写，以他们手机几乎只用微信的日常来说，大概也是需要花上不少时间。出站核查各种码的时候又看到有些年纪不太大的人似乎也需要志愿者的帮助才能顺利亮码。我们总以为开发出各种手机一扫即用的东西已是多么方便快捷，但对于日常并不太使用这些设备的人来说，或许还是种折磨，尤其是在身后排着长长的队伍的时候。</p>
<p>回家的时候看到了桌上的核酸票，泉州的资源毕竟有限，于是连核酸也是限量的。但它的矛盾在于核酸检测限量，检查核酸有效期却不限量，公共场所仍需要出示凭证。更让我惊讶的是，同一个区的不同社区又有不同的核酸票准则，我家所在的社区十日一户一张票，五日一周期，一次仅可一人使用，这好像在说一户人家这十日仅需要出入一人似的。而我的其他家人所在的社区则一次一张票，按人数分配，还算比较合理，以至于本社区的人常常需要窜到隔壁社区去做核酸，再不然，就只有去排队伍已那占满整条街的24时设点，毕竟，这要是天天都要平民缴费去给自己赋个有效期，大部分人都已停工多日，平白多出这笔开支，谁也不太愿意。与春节回来时相比，泉州人似乎已经对核酸的流程轻车熟路了，正月那会，排队的人，观望的人，陪同的人都不太清楚流程，你站那队伍里，同一个问题可以听到数遍不同人在向旁人询问，而这会，人们都熟练地走入队伍，出示票据，喇叭也在循环播放，几乎不太需要指引的人了，人们已经快把它当成习惯。但如果要说习惯，大概还是深圳更过分些，核酸几乎成为了一种日常，当你的检测结果过期就开始收到催促短信，即使不前往公共场所也会被报送公司，打工人没有那么多选择，总不能为了一个失效而不上班。即使是在我回家的那几天，这个催促短信也没有停止，和当时泉州按户籍赋黄码也差不多一个性质了。</p>
<p>从上海爆发疫情以来，信息流中没少看过因为封闭而逝去的消息，而从父母口中听到邻居的病逝还是让我很震惊，原来这样的处境在更多的地方其实是被人们暗自消化掉的，它甚至不会出现在本地的新闻，除了街坊邻居亲朋好友其实没有人知道。邻居比父母的年纪并不大太多，当天早上甚至还出门做了核酸，近午时突然发病，但急救车没有那么容易联系，甚至还需要审批，两小时后未能等来。小城并不像大都市一般有那么多的年轻人，同时人们也更默许这种无可奈何，偶有发出的声音常常因为微弱而消逝不见，前段时间我常常看到不同地区的友邻发布的广播下有人询问是不是在浦东。地区与地区之间的际遇并不相同，版图上星星点点，网络的便利并没能让人们互相理解，除了身处当地的人，没有人准确知道发生了什么，就算是同一座城，或许都相去甚远。泉州完全解封后的许多日子里，帮母亲买东西才发现快递仍无法送达，直到上周才恢复。而昨天我终于收到了上海寄出的乐谱，看起来物流已经恢复，但看着生活在当地的网友们的说法，似乎并未完全解封。</p>
<p>不知道还要多久，人们才无需总在担心那看起来变成了一种形式的有效期。今年南方的气温有些偏低，明明已是入夏的时令，却有着一种将要入冬的错觉。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 2</title>
    <url>/Essay-2019-nCoV-personal-record-2/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>当新型冠状病毒疫情逐渐进入公众视野，并在网路上掀起轩然大波的时候，其实是很感到迷惑的，对于没有处于那片区域，对新闻也几乎不关注的我来说，这个消息就好像是突然炸裂开来一样，完全不像是一个病情被通报出来该有的样子。在庞大的消息流中似乎曾经看到过一点关于此的怀疑，但也并未多做在意。</p>
<p>在之后的消息流中才发现大概在当地民间早有察觉，又恰逢年关，返乡和离开的人都不在少数。从一些民间的记录中看到大概1月初就当地人应该就听到传言，抑或是对病情有所知晓，但也许因为并未看到任何通告所以也并未过多地担忧。那时候看到关注的老师说起到别处旅游时，似乎也略微提及，只以为是玩笑罢了。而甚至在那段时间里，还曾看到过所谓「万人宴」的新闻报导，当时觉得有些荒谬，但想了想，也许是不是其实并没有什么疫情的可能存在，所以如此坦然。</p>
<p>大概在武汉封城前的一两天，关于疫情的流言快速传播，各地也陆续出现病例，我的同龄人们煞费苦心地劝说上一辈带上口罩，街上也开始能看到戴口罩的行人。我可能是家族的孩子里最冷漠的一个，只是默默看着。同龄人们各自在社交平台上分享着长辈们对于疫情的态度，有表扬父母听话备好口罩的，也有的因父母置若罔闻而流露愠色。同龄人们抱怨起长辈们天天转发各种健康咨询，却在疫情来临时不听自己一言一语，为此颇费苦心，有心人特意依照老年人们喜欢看的推文风格写了一篇推文，一时间得到大量转发和呼声。大概在这前后时间长辈们也有一部分戴起了口罩。父亲在上下班的公交车上已经开始看到有不少戴上口罩的乘客，但他也仍未在意。</p>
<p>在这段时间内，戴起口罩的人们和呼吁戴口罩的人们大多是我们这一辈人，有人调侃平日里大呼想死的年轻人们，在此时最为惜命。这时候可以看到有因为新型病毒死亡的报道在传播了，突然还有点希望染病死去也不错，但对于成天在家的我来说，也就是一个玩笑。</p>
<p>最令我疑惑的是，虽然在此时已经有很多提出了与SARS比较的消息，但在不少消息和文章里，却直呼其为「武汉肺炎」甚至都没有一个正式名称，这种带着城市名的叫法让人觉得有些滑稽，也许这也是后来出现各种对带有「武汉」这个字眼的一切的歧视和迫害的原因之一吧，民间的消息传播把这个滑稽的名称深深植入了人们的思维里。</p>
<p>1月22日晚，我在自己平时的记录地写下「大家都在惜命地掃蕩口罩呢？/活著有什麽好嗎？」却不料，当时的舆论也许连序幕都算不上，第二天，武汉封城，才真正把疫情扯上整个中国甚至整个世界的视野里。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 20</title>
    <url>/Essay-2019-nCoV-personal-record-20/</url>
    <content><![CDATA[<p>以自己角度写的疫情记录。</p>
<span id="more"></span>
<p>或许因为我居住的地方比较偏僻，六月初感到疫情控制基本比较放松了，暗暗期待马上就可以解除72小时核酸的束缚。但假日里跑到市中心玩的时候，才发现可能只是我所在的区相对偏僻所以没有持续的严格管控，路过的中心城区某个片区的居民区居然是处处设卡的状态，那阵势我会以为是3月的管控期，甚至3月的管控期我所在的地区也并没有出现这样的管控举措。几乎每个通往住宅区的入口都有一搭起一个类似于小岗亭一样的存在，里面架设了几台识别机器和卷闸，要通过卷闸似乎要进行什么验证，尝试扫健康码和人脸识别都我非法身份，不知道是否限制了只允许本区登记在册的居民才可以进入，原本想到里面的小店吃个晚饭只好作罢。</p>
<p>六月中听了来深圳后的第一场音乐会。当时可以算是疫情控制比较松散的时候了，虽然仍执行着72小时的管控。音乐会出来回家的途中，遇上两位路人或许也是刚刚听完音乐会结伴回家，在地铁口查验核酸码的时候其中一位被拦了下来，听她们的对话，核酸有效期刚刚过期几分钟，而新的核酸结果尚未出来，只好分别，放弃同行。原本还买了六月底另一场音乐会的票，没想到时隔一周，疫情管控又严格了起来，加码不断，音乐会被迫延期。深图也在几天之内连续发布了两次因疫情防控而采取的外借统一归还延期，至此已是本年度第六次因疫情延期。而截止到今日，深图今年已发布了八次疫情归还延期通告。由于关注了一些展馆，图书馆，音乐厅，甚至还没留意到卫健委的发布通知时，就已先留意到这些场所发布闭馆、延期、调整入馆要求（在24，48，72之间反复横跳）等各类相似的通知。虽然一直有见过公共场所动态管理一进一出的通告，但7月份第一次在图书馆遇到，艳阳天，排了几十个人站在图书馆门外，苦苦等着里面有人出来好能够进去。本周五前去听音乐会的途中，瞥了一眼自己的核酸记录，会在进场前过期，暗暗担心早上检测的结果出不来入不了场，搭不了地铁。处在此番机制下，每出一趟门都得跟那些检测记录较劲半天，不仅要了解场馆的政策，还得学会未卜先知，好在过期前续上一条记录，如此一来，出门的欲望都先要经过保质期的审视，常常在萌芽之初就已枯萎。而就在今天，又看到和那场音乐会同属一个音乐节的另外几场演出又被迫延期。同时看到一个钢琴比赛的组织方又恰好在选址的地点和时间内遇上了当地从未有过的疫情大规模爆发。好像每一次能够如期举行都变成了一种应该庆幸。</p>
<p>紧接着，日常48小时核酸又被开启。有趣的是，48小时核酸实行的时候，普遍人们排队的时间却比72小时核酸的时候更短些。以我自己而言，要求72小时核酸的时候，公司总是把一次核酸检测安排在周六，刚开始还不告知具体时间，我就跑空过一次，后来干脆去其他检测点排队了，不上班却为了测个核酸跑去公司也挺滑稽。虽然72小时核酸间隔时间比较长，但相对的设点也非常少，此前的几个核算点都撤离，因此在检测点的排队其实常常需要排不少时间，真让人想要统计有多少时间花在了去测核酸的路上，等核酸的排队，以及恰好没能等到结果出来不得不改变计划的延误。而在48小时核酸的执行中，每隔一天公司就会安排核酸检测，小区楼下也几乎每一天下班时间后都有检测设点，总体而言倒嘲讽地比72小时方便了许多。暑假期间帮朋友喂猫咪，她住的地方的保安真的是一个个检查进入小区的人的核酸码，你一旦是48小时，他就会请你要每天做，有次周末没去检测，本来有72+检测中也无所谓，愣是跟保安绕了好一阵才被放进去。而在一些官方通告文章里，居然堂而皇之地把网友们调侃的“电子哨兵”“保质期”作为官方用语。</p>
<p>说起核酸相关的见闻，基本上各个核酸点的秩序、布局、通告都有少许区别。路过别的地方检测时，有一次排在我面前的是一位母亲带着两个女儿，那里的核酸点已设成了一个核酸小屋，小一点的女孩身高还不到窗口的高度，但也已不小了，母亲又比较瘦弱，抱起小朋友的时候明显有些吃力。不同核酸点的喇叭通常都喊着不同的内容，以各自的风格叫喊着规则。最离谱的一次听到这样的播报：“不要使用以前的截图，一旦发现黄码，立马报警，拉去隔离”
，
“请出示粤核酸6采样检测码，没有粤核酸6的，粤核酸54321都可以”，不过最近再去的时候，这个离谱的播报被替换掉了。而在本小区，有一次在电梯里遇到一位老太太，当时深圳连日多余，她拿着伞，没留意进了正在上行的电梯，经我提醒才意识到于是小聊了几句，据说是为了下去看看有没有在做核酸，老人家或许没有手机，只是听着家人告诉的每天晚上六点楼下会设点，虽然是大雨天也不得不下楼看看，看了一眼群聊的通知，好在老人不必跑空。另有一次遇到一个小朋友，小朋友大概也没有手机，说自己到了才发现忘记带家人打印的核酸码，不得不又折返回来。诸如此类的一些事情，已经无可奈何地变成了一种新的日常，昨天排队时听到有小朋友说“想做核酸”都已经不觉得惊讶，也很难说清是什么心情。</p>
<p>当一些古怪的事情渗入日常的时候，再难想象拥有过的曾经，以至于看到公司饭堂未来得及设立挡板的新桌子都有些惊讶，看到有员工围坐在那里吃饭的时候感到恍然，来到公司的时候已是疫情时代，彼时桌子已有挡板，但突然惊觉更早一些的时候应该所有圆桌都是此番模样。虽然作为社恐人士会觉得有挡板误打误撞地对自己比较友好，刚来的时候长桌没有挡板，当时圆桌有编号不知道会不会占用别人的座位所以我不情愿地选择没有挡板的长桌，现在则看到长桌也加上了挡板。我几乎无法想象食堂的桌子都没有挡板的时候是什么样子的。</p>
<p><a href="https://www.postcrossing.com/">Postcrossing</a> 在
<code>Send a postcard</code>
页面置顶了一条通知，由于寄往国内的明信片阻滞在途，暂停推送国内的地址用于明信片交换。稍有庆幸的是，仍然可以寄往其他国家和地区，也会在不经意间收到一条遥远的回复。</p>
<blockquote>
<p>Due to the logistical difficulties caused by the pandemic, postcards
to China are suffering unusually long delays, with some mail being
delivered several months late or not at all. Currently, only about half
of the postcards sent 4 months ago have been delivered so far. 🙁</p>
<p>As there's no clear information on when this situation will improve,
to avoid further increasing the existing mail backlog and affecting
exchanges in Postcrossing, we have temporarily stopped sending postcards
to addresses in China. We are continuously monitoring the situation and
will restore the route when there are clear signs of improvement.</p>
<p>If you wish, you can continue sending postcards, or take a break.
Please rest assured that all due postcards will be sent to you when the
route is restored. You can check the Postal Monitor page for
updates.</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 21</title>
    <url>/Essay-2019-nCoV-personal-record-21/</url>
    <content><![CDATA[<p>以自己角度写的疫情记录。</p>
<span id="more"></span>
<p>八月下旬之初刚听完音乐会第二天的其他音乐会就延期了，更没想到又过一星期，这场音乐会直接被取消。同期收到深圳音乐厅的短信提示原本在该在六月末举行推迟到九月初的音乐会又被推迟到年底，这恐怕再延期一次都听不成了吧。</p>
<p>月底居住的地方开始装设新型门禁，采用了与各种商超公共场所类似的识别设备，居民非得刷健康码或者身份证才能进入，扫码后机器上也会显示打了码的身份证号。机器还设置了核酸有效期的限制，超过有效期的居民无法凭借健康码进入，中秋的时候没出门，就被设了24小时核酸标准的机器拦截过。出入的高峰期，闸机前总排起长队。本来人车的进出通道就窄，再停下来加载健康码，再停下来扫码，又要正对屏幕，机器的开关闭合也需要不少时间。下雨天，淋着雨排队扫码更是滑稽。</p>
<p>紧接着就又开始了一波封控，开始有同事被封控，有一点像是三月的形势，再接着，地铁封得剩下几个站，大家调侃那个片区还能上班的是“天选打工人”。正好是开学季，学生们又被延期开学，仿佛春季的重演。已经不太关心新闻了，或者说，封控，管控在各地已经算不上新闻了，某个晚上正常下班买菜看到空空的货架还有点被吓到。第二天仍然正常上班，还有人在电梯调侃以为今天不上班。只一天的工夫，又有更多的地方被封控，晚上的通告打着两轮核酸检测的幌子通知两天静默，狡猾地占据周末，周五晚上的菜场又是一顿疯抢，看着人们大包小包地提回家，大概害怕2天也是幌子。虽说平时的周末我并不总是会出门，但自己不出门和被静默，拿着通行卡登记出门当然是两回事，从楼上看下去，街道上只有外卖骑手的身影。我们只封了两天，但其他区域就没那么幸运了，可能这是住偏僻地区的唯一好处吧。</p>
<p>深图又接连发布了几次归还延期通告，不像年初时总是早早地预告，这几次总是踩着尾巴通知，而且总在夜晚，有好几次我都准备第二天去还书了，也提前了一天返程为了能去还书，当天晚上居然发了通知本月逾期不计。月底还书的时候延期通知前一天晚上才很晚才放出，在一个小分馆里看到许多前来还书的人，因为是第一天开放图书馆，很多借书人，也实行了限流，相比起在总馆烈日下排队，设在书店里的分馆排队就显得容易接受。很多人只是来还书的，不明白为什么不放一台机器在外面，只还书的人就不必等限流，也不必麻烦工作人员清点书目。</p>
<p>早早买好了国庆回家的车票，加了班申请假期调休。回去的前一天晚上突然传言本小区有病例，紧接着看到本小区有一栋被临时管控，一整晚都在担心是不是会被封控，第二天仍然没有确切的消息，然后在小区群看到接二连三的人变成黄码，几乎是随机没有规律，很担心被黄码，更担心半路被黄码，和父母商讨了许久还是退了当天的票，害怕到了之后发现黄码被隔离，听父亲说他的同事就被居家隔离了，还要装设监控，只有社区人员陪同才能出门。于是白请了一天的假，权当是给自己放假了。第二天卫健委终于公布了情况，是集中隔离人员里发现的，买了第二天的票，还是打算试着回家。到站后其实并没有多少管控措施，填写信息表也比上一次回来简单了许多。在出站口的核酸检测点目睹了一场争吵，听不清争执的内容，只听清那个乘客反复说着要告医护，医护显得非常单薄。从前我一直以为这种现场都有维稳人员，最少也有志愿者帮忙维护秩序，没想到这种情境居然也是医护自己面对。接下来几天接二连三地接到防控的电话，反倒是刚到的时候没有接到，最晚的一次是晚上十一点半。然后就是三天两检，并没有被隔离，封控或者居家监测，但我也不想说这是什么值得庆幸的事。家乡的核酸检测倒是采取了更合理的预约检测的方式，按时间段和人数，基本上不需要排很长时间的队，分流做得很不错，这让我很是意外。要知道在深圳虽然检测点直接进入小区了，但是由于要求需要出示检测码的地方太多，基本上人人都需要核酸证明，所以即使到家门口，也还是很多很多的人，排半个小时队的情况并不罕见，没有管的情况也是时有发生。今天下午楼下的核酸队伍我看了几次都排着长队，看群里的消息好像还有很多人没排上。不知道明天公司核酸检测的安排，但愿我明天下班回来不会被机器拦在门口。深圳的核酸检测感觉已经到了疯魔的程度，从一月至今没停过，最松的时候也是保持72小时证明，而我们这片区没疫情最近却还是天天检测，感觉像是在配合表演一场戏，但是也看到其他区工作的同学有被静默的，还发通报请居民备好食物回家封控，好像永远也没有结束的时候。有些常设的核酸点除了医护人员的核酸亭，也给扫码人员搭起了扫码亭，恐怕核酸检测一时半会是不可能停止了，不过看到有些核酸亭外放了一两张椅子，大概已经比较大但仍然够不着亭子窗口的小朋友就不必再需要家长抱起了。</p>
<p>还有很多淡忘的事情和大概终究会被淡忘的事情，比如地震时被封控不让逃生，比如大巴侧翻的丧生，比如被抹去的桥的名字。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 3</title>
    <url>/Essay-2019-nCoV-personal-record-3/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>2月23日，在庞大的消息流中看到武汉封城的消息，第一反应和很多人一样，大概是松了口气，传染源得到了一定程度的控制，但对封城是否封得住心存疑问。这一天里关于疫情的信息量暴增，豆瓣的动态流几乎看不到每天都存在的书影音分享，取而代之的是各类疫情动态，翻回当天的实时播报，发现很多在自己记忆里觉得是几天里看到的信息原来都是当天。</p>
<p>这一天是除夕的前一天，本会是春运的高峰期。武汉封城的公告一出，随之而来的还有大量斥责，一边指责政府没有早点采取措施以至让疫情蔓延，一边指责身处疫区的人自知处境却四处流动。这时候，开始能感到一点歧视的气息。封城把普通百姓留在了疫区，那里的人们又会怎么样呢？不由得想起几个久未联系过的同学。「封城」这个词语听起来简直像是尘封在上个世纪战争年代的古老词汇，毫无征兆地出现让人感觉有些别扭。很多人们，情绪像是针对着武汉而不是疫情。此时，看到的城内的情况远少于城外的人们的讨伐，各种骂声充斥在冰冷的网络上。好在同时，也有一部分人担心着城内人的安危。偶然看到了「培养皿」这个比喻，没有细看整条消息，仅这一个词足以让人感到触目惊心了。病房里拥挤不堪，大街上冷冷清清，这竟然是2020年的魔幻现实。</p>
<p>当天下午某频道里发布了这样一个匿名投票：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">武汉人想逃出来，外地人谴责逃出来的人，这真是一个道德困境。你怎么看？</span><br><span class="line">- 待在武汉别出来，别给其他地方带来风险</span><br><span class="line">- 能出来就出来吧，逃离重灾区</span><br><span class="line">- 沉默</span><br></pre></td></tr></table></figure>
<p>看到这个投票的时候，愣了很久，选了沉默。截至今日，我重新翻看这个投票，一共116人参与，40%选择了沉默，34%选择了第一个选项，也有26%的人选择了第二个选项。那些武汉人怎么样了呢，那些湖北人怎么样了呢，那些各地的患者怎么样了呢？「武汉」突然间就变成了一个被遗弃的标签，直到今天，我仍然能在频道里看到某些针对湖北人的「迫害」记录，真实性我无法验证，但存在性却几乎不需要去怀疑。人们鼓吹的性本善在这里瞬间崩塌。为了求生而做出的种种不可思议的举动直接超越影视的虚构。一边是城里人想出来，一边是外地人想围堵，两边都是为了求生，集体主义的光环让外地人占据了优势，一时间人们开始大肆公开歧视来自武汉的人们。无论是官方的禁令还是那些看起来很搞笑的自制标语，都相当冰冷，很难想象那几天在那里生活过的人们是怎样的心情。直至几天后才陆续看到接纳那些被迫流离的人们的消息，但也许伴随着民间口口相传的「武汉肺炎」的称呼，这种情况的好转怕是还需要很长的时间。</p>
<p>这一天里同时充斥消息流的还有武汉各个医院的物资告急，全国各地陆续公布的定点医院，同时开始限制各类文娱活动，新春电影撤档，疫情成为每段谈话里的主题，网络上的各种真假难别的消息更是沉重得让人喘不过气。口罩开始了新的一轮抢购风波，这次还有消毒水，酒精等等。外地人疯抢口罩，疫区里物资为空。寥寥无人的街道上带着防疫口罩缓慢行走的行人，摩肩接踵的医院里自制简陋防护连班倒的医护人员，我仍对大家疯狂抢购口罩的举动颇为怀疑，不解，但开始有些动摇，我终日在家，父母却需要外出，不免还是有些担心。</p>
<p>人们甚至开始怀疑起这几天内来自武汉的快递是否也是病毒的传播者，正好当天就收到了一个前几天从武汉寄出的快递包裹。其实，自己也带着这样的歧视了呢。虽然不相信时隔几天物流周转的快递上会带有病毒，只是平常一样简单地拆开包裹，后来也看到了邮政二次消毒的通告，仍多少有些担心，今天看到有报道称门把手上也检查病毒倒有些心有余悸，但对于那个报道也存有几分怀疑。</p>
<p>这一天，泉州开始有了确诊病例，于是疫情开始成为家里人的共同话题。全国各地的人们以这样的氛围迎来了一个沉重的除夕。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 4</title>
    <url>/Essay-2019-nCoV-personal-record-4/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>1月24日是除夕，家里的除夕过得很平常，无非是加上一两个菜，一起坐在电视机前看被百般吐槽着的春晚，收发新年祝福。虽然是很沉重的一个除夕，但其实对于自己家里来说，其实并没有多大的变化。</p>
<p>这一天里全国各地陆续启动了重大突发公共卫生事件I级响应，世界各地也开始陆续有确诊病例，开始出现列车寻人的通知，寻找同乘者里可能已被感染的潜在病毒传播者，各地开始有医疗队前往支援。各地的物资告急依然占据消息流中醒目的位置，同时因为封城所带来的各类问题也开始出现。消息流中开始能看到许多疫区里的人们的记录，得以窥见一点封城后的处境，但就算是再生动的笔触，不是身处疫区的我们，仍然很难感受。封城所带来的各类困境尤其体现在本就并不富足的底层群众身上，消息流里涌现的各类个人求助信息让人很是无奈，而借此行骗的恶行使得救助信息的评论区更像是人口普查问卷。随着封城所带来的井喷消息流，心理危机也开始出现。也许身处外地但曾生活于那里的人们感受最深，看到老师发布的简短停更消息，本对老师画作或是文章的更新抱着一种随缘的惊喜的，此时倒有几分担心，无奈并不太懂得能如何安慰。夜里收到来自武大的友人的新年祝福，小聊了几句，得知其元旦就已回了泉州，目前一切平安，虽然是久未联系的同学，也没有太多的交集，却觉得好像轻松了不少。</p>
<p>因为不太能抵制在看春晚的时候去浏览手机的冲动，于是选择了在除夕夜整理自己的书籍，把手机丢在了一边，偶尔回复友人的祝福，收拾工作一直进行到新年到来也还在进行，倒是免去了把自己泡在消息流里的痛苦。仅在晚饭的时刻坐在电视机前和父母一起看着春晚，正好是疫情报道和诗朗诵环节。当天临时加入的诗朗诵环节，被网友批得体无完肤。虽然也许通过这个环节借着春晚转播的机会能让更多人去关注，去了解这件事，但部分诗句本身简直仗着不知何来的底气说着「问我国家哪染病」类似这样荒诞的「自信」。而对于一线护士的采访，镜头对着的是空无一人的长廊，就好像在反驳确诊、疑似病例的统计数据，好像要让人误以为并无多少病患，一切都已在控制之中，可镜头里看似笑着的护士眼里分明写着悲伤。当晚看到这样一张插画，一边是靠在墙上筋疲力尽的护士，一边是欢度新年的绚烂烟花。也有人骂着春晚，也骂着看春晚的人们，说是如何有心情能一边看着疫情播报假作忧虑，一边看着歌舞曲艺嘻笑不止。我很难赞同，毕竟对于城外的人们来说，家人团聚也许是稀罕的时刻，春晚即使被吐槽也仍是筹备已久，如果说非要人人忧愁着看网路上不知真假的消息，倒显得过分了；但又觉得他们说得有理，哈哈大笑的时刻里好像难逃阴翳。</p>
<p>这一年，友人的新年祝福里大都多了句注意保护好自己。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 5</title>
    <url>/Essay-2019-nCoV-personal-record-5/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>第一个完全没有等着零点来临的大年初一，细数着自己囤积的书籍，听到窗外的烟花声才发觉。往日里社交平台上常常挤满了各式祝福，这一年都被疫情资讯所替代。在自己的记录里写下了「末世感」，像是前几日读颇具赛博朋克风的科幻短篇集《6号泵》里的虚构现实。</p>
<p>福建的确诊病例相对较少，泉州市区也未发现确诊病例。母亲这一天仍要上班。早晨陪父亲在附近的公园散步，路上、公园里都能看到戴口罩的行人，商店基本歇业，路过的几辆公交车都是空车。公园尚未完全建成，占地面积很大，更显得往来的游人稀少，也许也有年初一的缘故吧。那一天天气不错，漫步在公园宽敞的走道上，看远处成群的白鹭、苍鹭、海鸥，倒很是惬意。那时候完全没想到会是这段时间里唯一一次出门，随着疫情的蔓延，近日的防疫措施强了许多，大部分公园都已关门封路。</p>
<p>因为当日福建的疫情并不严重，所以并未取消回南安探望外公外婆的行程。在小区门口等着与表弟一家人汇合，期间和在北京读书的友人聊了几句，谈起一线城市的蔓延情况，友人表示害怕，我思考了许久回了句「随便了我是这么想的[捂脸]」，直到现在我的想法也没多大改变，冷漠依然。前两天看到有人说「现在心理还正常的人都不是正常人」，我大概就是其中的一员吧。但其实翻到当天浏览到的外国学者对疫情传播范围的预测译文，如果仅从官方统计数据来看，虽然当前疫情蔓延形势依旧严峻，相比起论文中的预测，算是相对乐观。</p>
<p>和表弟一家汇合后，小姨说起早上来家里拜年的乡亲也戴着口罩。等待的时间里偶然看到一个骑着电动车载着妻儿的市民路过，一家人都戴着口罩，自己往地上吐了一口痰，我相当迷惑，竟有这样的人么，如此这般就算所有人都有口罩可戴，都戴着口罩又有多大的意义呢？</p>
<p>在南安诗山的街头，也已能看到戴口罩的年轻人。和以往的春节不同，这一次家人围坐在一起聊天的主要话题都是疫情，只有在这时候大人们才在讨论声中关注起了疫情，也才渐渐意识到了疫情的严重，倒有些后悔当天回家了。下午姑姑打来电话，说是村附近有疑似病例，问我们要不要搭公交回家，父亲有些犹豫，再三商量后取消了第二天回惠安的行程，虽然后来疑似病例被排除了，但一直到现在也没回去成。这一天里，也陆续有亲戚们打来电话，商量着今年就不互相拜访了，也省去了长辈们对礼数未尽的各自烦忧。</p>
<p>晚间看到微信服务开通疫情督察的功能，点进去看了看，会跳转到国务院的小程序，仅有一个窗口供信息提交，有公开与否的选项，但并没看到公开平台，很怀疑是否能真的递交到国务院的处理者手上，更怀疑是否能真的被督察。前几天看到过疑似举报背后猫腻的文章，但并没有多大声音，很快就销声匿迹了，希望是自己多虑了吧。</p>
<p>这一天，在外婆家依然看到了村里人燃放的绚烂烟花，从晚饭时刻起持续了大概有两个小时。在空中绽放的烟花，看升空的方式，看花落处的星点，甚至听花开时的声响，贫富差距就能分别。这一天，全国各地开始有了不戴口罩不能进入公共场所，甚至会被罚款的各类防疫新令。有人称好，有人黯然。几分钟点燃价值上万烟火的人家，会懂得买不起口罩的贫民的疾苦吗？</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 6</title>
    <url>/Essay-2019-nCoV-personal-record-6/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>年初二的早上，在惠安的亲人们还是打了电话再三询问要不要回去呢，说着如果是担心公交，要不让哥哥开车来泉州带我们回去，最后还是拒绝了，如果回家，其他的亲人因为一年难得相聚的机会也必然会前来，如此「聚众」似乎并不太明智。与其说是害怕病毒传播，倒不如说是害怕众人的纷纭。公职人员被命令不许离开泉州，在家待命。</p>
<p>号召停止拜访亲友的消息和标语越来越多，人们几乎都选择呆在家中，少有串门拜访。关于疫情的消息仍是消息流中的一部分，但大家也开始疲惫了。也许是在家中的时光太长，豆瓣上友邻的书影音标记明显多了起来，在庞大的疫情消息流中仍未被淹没，尤其是影视作品的标记，那两三天的标记最多的是非典时期的纪录片和传染病相关题材的电影。年初的这几天里所看到的创作，无论是画作，或是文字，大多逃不开这个主题。但城里城外究竟还是两个世界，借用加缪在《鼠疫》中的话：</p>
<blockquote>
<p>水泥高墙隔断的两个世界相互之陌生，胜过它们各自处在两个不同的星球。</p>
</blockquote>
<p>及至今日，每天看到身在武汉，曾经常常发布些小手办的友邻，现在每天发自己准备的饭菜大概是最安心的时刻。</p>
<p>年初三国务院发布假期延期通知，在那几天里，复工和开学的时间也都被推迟。人们开始抱怨起了假期的冗长和无聊。</p>
<p>因为怀疑病毒源起海鲜市场的野生动物交易的缘故，网上流传着各类野生动物所带病毒的科普，并与非典作比较，然而至今日也未见准确源头报告，但这两天里全国各地开始严令禁止野生动物交易。父亲所在的单位也管辖着野生动物，因此在年初三接到通知次日需前往台商区巡查是否存在野生动物交易现象。我觉得可笑之极，在这种情况下，刚刚发布禁令，难不成还有人顶风贩卖那小动物么？就算有人敢卖，难道有人敢买吗？果然，第二天父亲回来也说并未发现此类现象，市场根本一片冷清。</p>
<p>病毒潜伏期正值春运高峰，那几天里消息流中开始被很大比例的列车寻人消息所占领。随着同乘者的隔离，随着确诊病例活动轨迹的公布，人人自危。人们仍然在收集口罩，家人也开始想方设法买口罩，并商量着是否要囤积柴米油盐。但，同时又看到了更恶劣的行为，天价口罩和伪劣口罩开始横行，从垃圾桶里捡大量口罩的照片也被迅速传播，甚至竟然还能看到从武汉发货的口罩，真是让人匪夷所思，即使在这种情况下也不忘大赚一笔。人们一边忧患着买不到口罩，一边又怀疑起到手的口罩是不是有些猫腻。人们也开始批驳涨价的商家是发国难财，然而这春节期间，口罩被疯抢，供货大量不足，难道工人们的假期就不是假期了？之后的某一天里看到一口罩商品上贴出发货周期至少30天，这是多大的供应需求？今天看到有报道称多家企业跨界生产口罩，即使是这样，仍然供不应求。即使是今天，人们也仍然囤积着口罩，害怕复工、返校的日子来临后，没有口罩的人连门都出不去啊。</p>
<p>1月27日凌晨，开始读《鼠疫》，昨日凌晨读完。明天就是原定的复工高峰期，疫情仍在蔓延。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 7</title>
    <url>/Essay-2019-nCoV-personal-record-7/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>写第一篇记录的时候是1.30，距今过去约两个星期。想写记录的念头其实是源于阅读加缪的《鼠疫》，虽然是小说，但对处于疫期和疫区的人的描写很是细致，甚至可以和当前消息流中的各类信息对应起来，差点以为是纪实。不过，话说回来，时代虽然改变了，人的那些心理却没有变，人的善恶也更向着两个极端蔓延。真正写起来，才发现在没有这个念头也没有写任何记录的日子里，那些消息在当时虽是引起了自己的不适，但其实都是看一眼就过去了，记忆极其模糊，如果不是有了记录的念头，也许还会忘掉更多的东西吧。</p>
<p>整个年初的法定假日期间，虽然越来越多人意识到了疫情形势严峻，但其实人们仍在观望。</p>
<p>一直到初七之前，母亲上班的店铺仍在开业，轮着班，单数日子上班。当然了，服装本就不是迫切之需，虽然中国人有新春添置新衣的传统，但在此特殊防疫时期，买衣服这件事就显得无足轻重了，因此，那些天并没有多少顾客，最多也就是走进来问问价。小姨当班的日子里有熟客过来买过一单，客人买完后有些后悔，想着万一有什么人接触过这些衣物呢？大家简直到了疑神疑鬼的地步。不过，听母亲说，隔壁的奶茶店生意倒是不错，倒也还有些年轻人排着队。一直到正月初七，也许是听闻疫情严重，服装店铺才开始停业，直到今天，仍未复工。年初几天，在酒店做杂活的家人仍能看到少量酒席，许是年前预定的饭局，想着本地疫情较轻，没多在意，也就没有取消吧。打工者更害怕些，做杂活的人手不够，酒店里倒堆积起了碗筷。此时，疫情带来的恐慌的蔓延更甚于病毒本身的扩散。</p>
<p>国家规定了法定假日延长，政府却显得有些手忙脚乱。在年初期间，时而通知上班，时而又下令原地待命，倒是检查了几次交易市场，结果当然是一无所获
。而父亲所在的单位本是在过年间策划着发放树苗的活动，年前未领完的树苗一时间难以处理，那一天里，父亲来来回回打着电话协调着树苗发放的诸多事宜。</p>
<p>26日，湖北省不紧不慢地第一次召开发布会。这场发布会又成了网友痛斥的焦点，发言人简直是口罩错误使用典范。而对于当地口罩生产力的几番改口更是让人怀疑，是不是疫情爆发后的种种灾祸在上位者眼里都只是儿戏，让城外人的担忧又添了几分。而此时，在城外的湖北人尤其是武汉人简直像是遭到封杀，仅凭一鄂A牌照就能引发各种轩然大波，各地开始悬赏瞒而不报的武汉人线索，甚至连小区楼下也贴着悬赏告示。虽然此时主动上报是理所应当，但此番悬赏实在让人心寒。前后又看到武汉人信息被泄露的消息，有些担心起在那里生活过的同学和老师。病毒无眼肆虐，恶人有心作乱，倒不知是谁更张牙舞爪了。</p>
<p>27日，一则<a href="http://ctreaderbot.appspot.com/v/so8psAiSncLq.html?tg_rhash=1b6d4f83b7837a">报道</a>将受训诫的武汉医生推入公众视野，医生1月3日受训诫，14日因被病人感染住进隔离病房。此篇报道中，受访医生选择了匿名，报道在不久后被删除，但也同时在短短的时间内将「造谣」与「吹哨」推上了舆论的风口浪尖。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 8</title>
    <url>/Essay-2019-nCoV-personal-record-8/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>1月31日，世界卫生组织正式将「2019-nCoV」疫情定为国际关注的突发公共卫生事件。此时的疫情已经零零散散地蔓延到了世界上的许多其他国家，许多国际航班陆续停飞。</p>
<p>这时候的我已疲于关注每天的疫情播报里的关于确诊、疑似、死亡病例的数字了，父母倒是比我更关注些，每天早上起来就听母亲说着病例的数量变化。从疫情一开始，许多人关注疫情的病例数量和趋势大概都是使用的丁香医生。有网友注意到，在1月29日，丁香医生的疫情趋势图曾出现过折线图变为柱状图的情况，而大家应该都明白，柱状图比起折线图，反映整体趋势的直观性要差上许多，这点小心思不幸未能逃脱广大网友的火眼金睛。不知道后来是什么缘故，又曾经改成类似的面积图。刚刚点看浏览，现在又回到了折线图。但这折线图中，能明显看到纵轴的刻度数值相当大，即使几百上千的变化在这样的统计图中也只是一个微不足道的倾斜程度而已。在工程计算分析中，这样的数据常常会使用对数处理，不知道这些统计图的数据处理又是出于怎样的考虑。况且确诊病例的数量大概还受限于医护资源，1月27日就出现过一个异常点，大家猜测着是不是前一日试剂盒不充足，导致新增病例仅在那一天里急剧下降而后又开始上升。且抛开官方发布的统计数据是否完全真实不谈，这统计图所反映的趋势可是有点模棱两可呢
。</p>
<p>在湖北各地物资严重匮乏的情况下，医护人员甚至不得已用各类包装袋制成简陋的防护用具坚守一线，而同时，竟爆出红十字会物资分配存在猫腻，各个渠道汇集而成的物资和款项使用去向不明，厚此薄彼，莆田系医院成最大赢家。在网友的声讨中，以韩红基金会为代表的各类民间组织的表现则透明公开，甚至调侃称不如让韩红接管红十字会。一边是辛苦攒下的血汗钱，一边是生死攸关的物资缺乏，民众开始普遍质疑起红会，怀疑捐赠善款最后并不能给予疫区的人们以帮助，反而填饱了本该被追责的血盆大口。</p>
<p>春节小长假的这几天里，因为不能走亲访友的缘故，抱怨无聊的人们越来越多。我倒没什么感觉，反而因为无需面对在连辈分都搞不清的亲戚，无需面对家里来客人时的不知所措，倒是轻松了不少。正月初七，本该是春节长假的复工日，但受疫情影响，全国各地普遍推迟复工时间，大部分同班同学的实习也被叫停。多数企业迫不得已采用远程办公模式，甚至出现了国内部分远程协同办公软件崩溃的处境。即使法定假日推迟，对远程工作也并无影响，实习的公司也在这一天复工，开始了完全不考虑周末的工作安排。第一次视频会议里在各个地方的员工聊起了当地的疫情，竟然有人一本正经地认为是国外生化武器，看来百姓的阴谋论比起执政者也不甘下风呢
。而这种论调还并不是单枪匹马，甚至还能看到网络上流传类似言论的视频，言之凿凿。分明就在1月底，武汉市长在直播中最后的「坦言」大有地方中央两不认错的境地，一时间想到前些日子读的推理作品里东道主各阶负责人的互相推诿。甚至官方无意间泄露早在1月初就已得知疫情，最后竟然还能归咎于外邦援助不力。也许这就是根深蒂固的「爱国情怀」吧。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>疫期小记 9</title>
    <url>/Essay-2019-nCoV-personal-record-9/</url>
    <content><![CDATA[<p>以自己的角度写的疫情记录。</p>
<span id="more"></span>
<p>1月底，各省市开始关注起疫情以来，归属地分别为泉州和广州的两个手机号几乎每天都收到疫情相关提醒。广州的短信几乎每一天都是同样的内容，提示从外地来穗人员及时登记上报相关信息。而泉州的短信则多是来自福建省各个不同单位的各类不同题型。其中1月31日这一天，甚至收到了署名为福建省农业农村厅的提示，请市民切勿囤积蔬菜。因为大年初一回乡下时带回来不少外公外婆栽种的蔬菜，此时倒也尚未感受到是否有囤积蔬菜的情况存在。
不知道是因为看到其他地区的囤粮行为，还是本省省内发现了囤积行为，导致了竟以这样的方式加以告知。</p>
<p>1月31日晚，中国科学院上海药物研究所和武汉病毒所发布消息称双黄连口服液可抑制新冠病毒，此消息一出，得到了广大网友的转发，甚至以「人民日报」为代表的官方媒体也转载了。也许是消息发布方的名号让百姓们深信不疑，当晚线上线下各类药房的双黄连口服液被疯狂抢购，甚至连兽用双黄连溶液也被民众青睐，最不可思议的大概是竟能把双黄莲蓉月饼也给牵扯进来。有消息称，贩卖兽用双黄连的老板表示，从未想过自己的商品竟然会被全国人民疯狂抢购。简直就像是天方夜谭，我甚至还没看到抑制消息的转发就先看到了被抢购一空的吐槽，还有些半信半疑。第二天，外婆打来电话，说自己平日里服用的中药喝完，想让城里当天有事回家的哥哥带点。因为对外婆外公去镇上买东西在这疫期间不太放心，小辈们百般叮嘱这段时间就别去镇上了，就待在自家屋子里就好，乡下的邻里相隔较远，这特殊时期人们的往来也少，相对安全。没想到母亲前往药店买药的时候看到的却是排着长队购买双黄连的人们，当天中药没买成，过了几日这风波平息后才托人带了回去。大概这时候的人们即使是看到偏方，也会想要试试吧，幸好家里人到都没把这当回。</p>
<p>当晚和几个小伙伴聊起双黄连的抢购，聊起疫情，颇为无奈。他们大都是广东人，广东和浙江的疫情是除了湖北以外最严重的地区。在广州上班的小伙伴颇为担心，虽然广州发布了口罩预约，口罩邮寄到家，但听说很难预约上，后来才听说是和厦门类似的摇号买口罩。有人戏称广州人的一天就是早上起来寻找提供口罩预约服务的药房，填写申请信息，下午到晚上就等着查看摇号结果。小伙伴表示目前在家，完全没有口罩也不碍事，手头仅剩2个口罩，留着乘车使用，等到2月10日开工，倒不知如何是好了，没有口罩，出不了门，上不了班，而潜在的感染者就目前来看大概还有很多。酒精等消毒品和口罩在各类线上购物平台都已断货，能买到的也很难保证送达时间，忧虑不已。不过已工作的小伙伴大都从事IT行业，远程办公还是可行的，更担忧的其实是返工潮里那些不得不开工的工厂。不是有北漂拖着行李几天找不到住所的报道吗，对于返工的外地人，进退两难，本地的各种防疫措施无可指摘但又不近人情。戴口罩的宣传已经散布到各个角落，甚至亮起大厦的外墙醒目告知。关于口罩的正确用法一再流传，可就身边的情况来看，4小时丢弃理论根本行不通，大多数人都只能以反复使用来抵抗不得不执行的防疫新令。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>回家</title>
    <url>/Essay-2022-05-04/</url>
    <content><![CDATA[<p>杂记</p>
<span id="more"></span>
<p>春节回家至今不过时隔两个多月，回家后才知道这两个月里故乡的身边人多有病重或离世。前阵子泉州的疫情形势还紧张，亲戚们以为我不会回家。他们说，看到你能回来看看很开心。聊着的还是那些每次回来都在重复的话题，车票，生活，工作，婚育云云，今年还多了个疫情的话题，因他们也亲身经历。许久不讲的闽南语有些生疏，磕磕绊绊地。楼下的邻居在疫情严重的时候发病，因为救护车的呼救需要层层审批，等了两个时辰未及，离世了。那户邻居与我家搬入的时间正好差不多，两家人多有来往，突如其来的意外让家人颇为感慨，持续劝说我回到故乡。</p>
<p>我带着笑和每个拜访的亲人聊天，小心翼翼地避开每一个雷区，小心翼翼地在那些可能引发争吵的话题里含糊其辞，只有我自己知道我们之间隔着一层单向透光的玻璃，而他们说我笑得灿烂，或许是他们说的是那个映在玻璃上的模糊影子。回家的很多天前，甚至于还没确定会不会回家的时候，我就开始担忧，是不是又会爆发新的争吵。从高中毕业后，就不断有亲人旁敲侧击地劝我找对象，工作后更甚，这个话题总是引起不快，尤其是和我的母亲。后来我发现几乎每一次争吵我的父亲都不在场，母亲有意无意地避开父亲和我谈这样的话题，我不知道她是不是担心父亲会支持我。后来在仅有的一次电话争吵后我发了微信试探我的父亲，只问了父亲对女性婚育的看法，他回避了问题，我于是知道，他最多能站在中立的位置，或许更多的是默不作声旁观，一如后来他偶然看到我和母亲争得面红耳赤，虽然出声询问，但并不真的想知道我们都谈了些什么。</p>
<p>我企图让我的亲人先接受不婚育，但失败了，母亲说我为何不替他们想想，而她不知我已想了很多很多年，躲在很多很多个凌晨。每一次谈论都最终变成了争吵，我总是忍不住哭泣，很生气，进而高声，母亲说我在吼她。母亲是很温柔的人，平时最忌讳我情绪激动地回答她，哪怕可能只是很平常的回答，带着点不耐烦情绪的高声调在她看来都很刺耳，或许是因为我小时候太爱哭，因而父母也很讨厌我哭泣，像是在博取同情。夹着哭腔的我，常常已经无法继续和母亲对话，中断的对话在下一次又被重头展开，掉入无休止的循环，没有终点。</p>
<p>除夕夜的争吵我说起女性在家庭中的牺牲，母亲明显愣了一下，但仍然回复道为什么我会管这叫牺牲。我终于明白，传统已经把那些是为理所当然，即使像是我家这样的相对会和睦的家庭，父亲也仍然是隐形的剥削者，我也听过母亲包括其他的女性亲友的抱怨，她们并非不知道。之所以说是相对，是因为父母也爆发过激烈的争吵，但他们好像都忘记了，而我却记得我在他们身后不知措辞的样子。我不能明白，为何并不公平的婚育她们将其视为赐予，也许正是因为这样的认知偏差，她们在说爱我的同时才希望将我推向婚育。</p>
<p>父亲的同事有个与我年龄相仿的女儿，母亲和她的母亲很是要好，我们从小就被比较。回家时母亲也跟我谈起她，看起来她的每一步选择都更符合我们父母们的期待，选择女孩「擅长的科目」，选择靠近故乡的学校，选择考取公务员……
这每一个问题我和我的母亲都发生过争吵。也许是争吵太多，母亲似乎认为我不能感受他们的爱，她频繁地告诉我他们并不羡慕生男孩的家庭，并没有重男轻女，尽管她不知道他们在无意中跟我说过多少引导性的话，不知道那些「不适合」「不擅长」给我带来了多少痛苦，让我产生了多少质疑；告诉我父亲有多疼我，她总是举钢琴的例子，我当然也知道，在过去的家境下这个选择有多不容易，如果换做是我，我想我不会这么做；她又告诉我，小叔曾经想用他的一个儿子和他们换我，我有些震惊，也很庆幸他们留下了我，从前我一直以为县里的学校和城里的学校尽管有差距但并不会太大，直到小我几岁的堂妹拿她的作业来问我，那份试题我也做过，在我的学校，那种试题我们甚至一摸它的纸质就知道是那个最简单最容易搞定的系列，老师们也只会拿它们让我们练笔，连评讲都少见……
尽管他们都不善表达，没有轻吻，没有拥抱，没有「我爱你」，甚至说不出「生日快乐」，实际上父亲似乎连我的生日也不记得，有时候我很羡慕我的同学朋友们收到父母的「生日快乐」，羡慕我的表哥会和他的母亲「勾肩搭背」，羡慕那些会得到家长拥抱的小朋友们。但我当然还是知道他们是爱我的，一如母亲在我每次回来前很长的时间里就开始准备各种做饭的原材料，父母没什么过节的概念，可能我回家的日子最像过节，我总是带着大包小包的东西返回。而那又让我觉得很沉重，觉得他们爱的是那个映在玻璃上的影子，不是我。《掩饰》中有这么一段话形容这样的感觉：</p>
<blockquote>
<p>或许这是一个柜子对我们最大的伤害——它阻挡了我们听见“我爱你”这句话。我的父母曾经说过这句话，而我相信那份爱，但不相信话中那个“你”。真正的我被藏了起来，所以他们所爱的这个“你”是另外一个人，一个更优秀的儿子。</p>
</blockquote>
<p>战战兢兢地过完回家的每一天，早上母亲又说起找对象的事，还特地强调了男朋友，我没有应答，因为正在洗头发，所以她也没有看到我脸上的表情，这已是要离开的早上了，我想没有必要再去反驳和争吵了，没有必要把这短短的相处时光仅剩的几个小时又凝固起来。更何况今天是母亲的生日，很巧的是，也是我农历的生日，外婆刚刚打过电话来，提醒母亲给我煮面线和鸡蛋，家里生日最普遍的习俗，外婆几乎总能记得我的生日，而新历的生日常常只有那些个自动发送的程序记得，因此我更偏爱农历的生日。过去的那几年几乎因为回家的争吵，我都没能跟母亲说「生日快乐」，彼此板着脸过着痛苦的团聚。这次回家终于没有再跟母亲发生争吵，我终于不再撕开她的伤口，但我不知道她是不是会误以为我已妥协。</p>
<p>回家的时间里也没找到合适的时机和父亲谈论可能涉及出柜的话题，早上犹豫了很久在离开前是不是可以和他讨论张国荣，想了想有点像是儿时考砸的试卷不敢在家中让父亲签名，总是等到快到校门口骗父亲说昨晚忘记了再让他签名，像是心虚的样子，于是作罢。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>将本地已存在文件夹推送至远程仓库</title>
    <url>/Github-git-push-problem/</url>
    <content><![CDATA[<p>有时候我们可能会遇到当文件累积到了一定程度的时候，想使用 git
进行版本管理，或者推送到 Github
等远程仓库上。本文介绍如何将一个本地文件夹中已经存在的内容使用 git
进行管理，并推送至远程仓库，以及对其中可能出现的错误进行分析。</p>
<span id="more"></span>
<h2 id="创建-git-仓库">创建 git 仓库</h2>
<p>在该文件夹下初始化仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>此时将会在此文件夹下创建一个空的仓库，产生一个
<code>.git</code>文件，会看到以下提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initialized empty Git repository in FOLDERPATH/.git/</span><br></pre></td></tr></table></figure>
<h2 id="将文件添加到暂存区">将文件添加到暂存区</h2>
<p>使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>此操作会将当前文件夹中所有文件添加到 git 仓库暂存区。</p>
<h2 id="将文件提交到仓库">将文件提交到仓库</h2>
<p><code>git add</code>
命令仅仅将文件暂存，但实际上还没有提交，实际上仓库中并没有这些文件，使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p>此时将会打开一个文件，用于记录提交说明，输入提交说明即可，若说明较为简短，也可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;YOUR COMMENT&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="添加远程仓库">添加远程仓库</h2>
<p>使用以下命令添加添加一个远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin YOUR_REMOTE_REPOSITORY_URL</span><br></pre></td></tr></table></figure>
<p>其中 origin 相当于给远程仓库的名称，也就是相当于一个标识符。</p>
<h2 id="推送至远程仓库">推送至远程仓库</h2>
<p>使用以下命令将会将本地仓库中的内容推送至远程仓库的 master 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果之前忘记了<code>git commit</code>
的步骤，这里将会出现一个错误提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: src refspec master does not match any.</span><br></pre></td></tr></table></figure>
<p>为什么会有这个报错呢？原因其实很简单，在没有使用
<code>git commit</code>
之前，由于这是一个新创建的<code>git</code>仓库，没有<code>master brench</code>，也就是并没有一个工作树可供推送至远程仓库，所以自然也就出错啦。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><p>《Github 入门与实践》</p></li>
<li><p><a
href="https://georgik.rocks/common-mistake-when-creating-new-git-repo/">Common
mistake when creating new git repo. Error: src refspec master does not
match any.</a></p></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>写在美赛一年后</title>
    <url>/Essay-after-MCM-one-year/</url>
    <content><![CDATA[<p>今年的美赛前两天刚刚结束，自己并没有参赛。倒是读数学的友人今年参赛，在远方的学校备战着比赛，期间讨论了好些时候，翻出了自己去年准备比赛的资料，以及最后参赛的论文，想起去年参赛的时光，突然还有点感慨，遂有此文，也算是补上一年前没有写下的回忆。</p>
<span id="more"></span>
<p>我已经忘记我是何时听说美赛的了，不过并不是很早，也不太了解，只知道学校发通知的组建美赛群的时候因为看到是与数学有关的便加了进去。群文件里有些资料，大概读了一下简介，但是不知从何寻找队友，同时又对数学建模一无所知，因此这件事很快就被抛在脑后了。不过群里倒是时不时有人在寻找队友，因此这个群还不至于被我遗忘。不过大多数寻求队友的人都有参加过校赛或者国赛的经历，又或者对数学建模这件事情还是有些了解的，因此也不敢询问。</p>
<p>在差不多觉得应该不会参赛的时候，大概11月中下旬，看到后来成为我队友的男生在群里组队，他们还差一人，因为都是新手，就问了问，简单地说了一下自己的情况，其实那时候我还想如果准备不及，不如好好准备一年，第二年再来，但后来我们并没有做出这样的选择。很简单地相互认识了一下就组了队，见了一面，两个队友是同班。因为他们在课程上多少接触过数学建模或者Matlab，因此简单地分了一下工，我主要负责论文写作。当然为了在比赛的那短暂几天里能互相帮上忙，对于其他人主要负责的部分我们在前期也都还是多少了解的。我都不知道当时自己哪来的自信可以写一篇全英的论文，那时我还未通过六级，且分数很低，英语其实也算不上好的。就算是现在，翻到自己去年写的论文，还是觉得很难以置信。</p>
<p>队友给了很全面的美赛的相关资料，于是我们就开始各自往着自己负责的方向去学习。我开始学习用
LaTeX 排版论文，并且爱上这种排版方式，那时候正好刚刚接触到
Markdown，其实在某种程度上这两者是很相似的，当然 LaTeX
要复杂得多，毕竟是用于书籍排版。在输入文字的同时只需输入少许记号便能完成排版以及各种公式和图片的合理优化，无论从哪个角度讲，都会让我爱上这种方式，毕竟和写代码是有那么点相似的。一直到期末考试前，其实算不上特别用心，每天会多少读一点
LaTeX
的使用或者美赛的英文论文，但进度还是比较慢的，而到了考试的几天，忙于复习，更是没有那么上心了。考完试又再次和队友见了面，交流了一下各自的进度和情况，安排赛前的交流和训练。由于比赛时间接近年关，担心父母操心，我只在学校待了十来天，比赛的那几天并没有待在学校。而两个队友则是选择在学校备战，于是我们的交流需要线上进行。记得那时候没完全做好沟通，所以队友们还以为考完试见面后我就回去了，直到后面要回家了我再次提议是否需要再次见个面，交流一下比赛时候大概的安排。于是才又出来，一起讨论了一下需要注意的地方。</p>
<p>那时候我们正在进行第一次也是唯一一次赛前合作的训练，挑选了一个题目，进行资料搜索和解题，建模，完成论文。讨论了一下在训练时候发现的一些问题，并试着提出了一些可能的解决方案。那一次练习也是找了美赛的往年试题，这唯一一次练习我们进行了大概一周的时间，比美赛的时间要来的长。论文是我回家后才完成的，第一次用全英文来写一份长达
20
页的论文，几乎是时刻开着翻译，很多想表达的句子并不知道在英文里有怎样相应的词汇。同时在
LaTeX
的排版上也是第一次进行这样的排版，学习的时候仅仅是针对各个子项练习，真正把整篇文章的结构排版在完全还不熟悉的时候通过
LaTeX 来完成的时候还是有些难度的，也是在那一次练习中才对美赛论文模板
mcmthesis
有了一定的了解，并写下了一份简短的总结，为了自己在写论文和排版的时候便于查找，<a href="<https://fish-404.github.io/LaTex-use-mcmthesis-write/>">LaTeX
- 使用Mcmthesis 写作美赛论文</a> 。
那一次我们选择的是一道关于烤蛋糕的蛋糕烤盘最优烤盘形状的题目，是一个有点意思的题目，从一方面讲，由于热分布的原因，烤盘越接近圆形，热量分布得就越均匀，而不会集中在边角处，但从另一个方面讲，由于烤炉的形状多为矩形，或者说烤盘的整体多为矩形，因此圆形必然导致无法充分利用整个烤炉的空间，从而需要给出一个方案，选择最佳形状。我们对于热学都不太了解，也并难找到现成的有人做过对烤蛋糕的烤盘形状的研究，因此从头开始寻找关于热分布的讲解与研究。在练习的时候就感受到，由于题目可能来自于各个不同领域，并且更多的可能是我们并不熟悉的领域，所以查找资料倒成了重中之重。从考试结束一直到回家前，我们也一直进行着关于曾经的赛题的解读，收集可能用得上的数据来源的网址，虽然其实到后来比赛几乎都没有用上。那段时间正值降温，一个人在宿舍过了十来天，每天几乎都在阅读往年的
UMAP，即使是这样，一天下来也读不了许多，毕竟英语水平并不高，常常需要停下来查找单词，而一篇文章中出现的单词有时查了几遍还不记得，那段时间里所读的英文材料可能比大学以来的那一年半里读的所有英文材料还要多。每篇文章都看着成堆陌生的词汇，说不恐惧是假的，并且一直暗暗担心没法完成论文。所以在家中完成那篇练习论文的时候多少有了一点点信心，发给老师看过后，老师给了些建议，并指出最严重的错误还是因为疏忽有个出现多次的单词拼写错误。那并不是个复杂的单词，所以那错误几乎是明显而致命的。这也是我们比赛时检查论文最注意的地方。回家后除了每天会练会琴以外，完成了那篇论文和，所有的时间都用来看论文，看我们所练习的题目曾经的参赛者的论文，那真是很难忘的回忆啊，虽然几乎不记得那些论文写的什么了。</p>
<p>赛题的发布时间是美国时间的下午，相对应地就是我们的早上应该是五点多的样子，前一天晚上我们都早早睡下，第二天一大早起来看赛题。刚刚看到赛题的时候我们都懵了，因为显然题目看起来和我们曾经讨论过的一些题目都不太一样，可我们并没有太多的时间犹豫，但仍然讨论了很久，选择了很久，我们通过语音交流，最后选定了当年的B题，题目的大致意思是根据语言使用人数以及第二语言使用情况的分布和趋势，预测未来的语言分布发展趋势，同时根据这个分布和趋势为跨国公司选取最合适的几个国际办事处。和之前练习的题目不同，这个题目甚至还有点人文倾向，而不是通过某一个工程领域的问题去求解最优。这是我们没有料到的。并且还有更没有预料到的情况是，数据的收集比我们想象的更难，很多数据都需要查询一些国际网站，甚至连一些国内的基本情况数据就都是国际组织给出的更为全面和详细，这就完全不可避免地去接触英文的网站，虽然有些网站会提供语言选项，但基本上也只是汉化那些页面表单元素，对于文章等仍然还是英文的状态。而对于语言学的分布和发展等的研究就更是国外学者研究的多，这才明白为何看美赛论文的时候总能看到后面跟的参考资料里有很多是英文文献。那几天里也第一次体会到搜索技巧的重要，有些问题完全不知道如何去用英文表达来搜索到想要的答案，也更是体会到搜索引擎的差别。第一天基本上就搜集资料，写一下论文的整体框架，队友们开始试着建模，第二天才开始把模型和思想渐渐写入论文。由于我们是线上交流，所以队友的很多更改其实我并不能实时收到，有时候可能刚刚通过
LaTeX
的语法编辑完一个公式，却又发现我们的模型需要进行改动，刚刚编辑的公式又需要做出改动或者甚至无法再用。很难形容那时候的忙碌，每天浏览器都开着很多的标签页，以我电脑的性能一次也没有崩溃真是万幸，比赛时我将自己的笔记本外接上了家里台式机的显示器，于是有了双屏，一边搜索资料以及和队友沟通，一边写论文。那几天的每一分每一秒都是紧迫的，不过队友们还是很贴心啦，因为前期重要任务是建模，两个男孩子关照着让我先去睡觉。而实际上，最后一天，他们一直陪着我到论文完成。我们的论文初稿是在提交当天的凌晨才完成的，这其中还是两个男孩子揽下了摘要和
Memo，那个凌晨我们一直忙碌着，而自己的英语水平委实带来了不少麻烦，后期论文的修改检查，调整排版，没有想到会花费这么长的时间。因为
LaTeX 并不是所见即所得，所以每次修改完得需要编译，而编译完看生成的 PDF
文件，往往又会发现不少的错误。而因为心急，尤其是已经是半夜，天气也很冷，往往在修改的时候还不慎会改动到其他的地方，酿成了更多的错误。那一天，我们一直修改到凌晨五点，再晚点父亲估计都起床了，虽然我后来看还是有不少瑕疵。队友们第二天要乘车回家，辛苦他们陪了我一整夜。</p>
<p>比赛成绩一直到四月份才出来，我们拿了 H
奖，虽然并不算是好的成绩，但对于我们三个人来说，两三个月前我们还不认识，对于建模一无所知，从来没有参加过相关比赛，只进行了一次配合练习，就直接参与美赛，已经算是很欣慰的成绩了。对于我个人来说，那之前怎么也不敢想英文水平也仅仅只有四级的我能完成那一篇论文。这也是大学到现在为止合作的最愉快的一次比赛。而从那之后，也不再对于英文网站有那么多的排斥，对于英文文献也不再那么恐惧了，这也是非常大的收获。感谢那两位小伙伴，共同留下了这样一段时光。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-jQuery Zoom 使用</title>
    <url>/JS-jquery-Zoom/</url>
    <content><![CDATA[<p>本文介绍如何使用 <a href="https://www.jacklmoore.com/zoom/">Jquery
Zoom</a> 放大图片。</p>
<span id="more"></span>
<h1 id="基本使用">基本使用</h1>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jQuery Required 1.7+ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-zoom/1.7.21/jquery.zoom.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;img&gt;</code> 标签需置于某个合法的 HTML 标签内，如
<code>&lt;div&gt; &lt;figure&gt; ...</code> ， 而使用
<code>zoom()</code> 的元素应该是 <code>&lt;img&gt;</code> 的
<code>Parent Elemnt</code> 。</p>
<h2 id="启用-zoom">启用 zoom：</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/example.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最简单的启用方式 */</span></span><br><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通常需要配置 zoom 参数 */</span></span><br><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">property1</span>: value1, </span><br><span class="line">    <span class="attr">property2</span>: value2,</span><br><span class="line">    ... </span><br><span class="line">    <span class="attr">propertyN</span>: valueN</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="禁用-zoom">禁用 zoom</h2>
<p>以下是zoom的禁用方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">trigger</span>(<span class="string">&#x27;zoom.destroy&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>比如你可以使用一个checkbox来控制zoom的启用和关闭。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;input:checkbox&quot;</span>).<span class="title function_">change</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> ($(<span class="string">&quot;input:checked&quot;</span>).<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">trigger</span>(<span class="string">&#x27;zoom.destroy&#x27;</span>); </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   	$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">magnify</span>: <span class="number">2</span></span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="属性值配置">属性值配置</h1>
<h2 id="url">url</h2>
<p><code>zoom</code> 图片源。</p>
<p>值 ： <code>false</code> | URL</p>
<p>默认取 <code>&lt;img&gt;</code> 中的 <code>src</code>
作为放大图片源。当填写具体 <code>url</code> 时将取该 <code>url</code>
作为放大图片源。</p>
<p>使用时可以将像素较低的图片放在 <code>&lt;img src=""&gt;</code>
中，像素较高的放在 <code>zoom</code> 属性中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;https://example.com/example.png&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="on">on</h2>
<p>触发 <code>zoom</code> 的方式。</p>
<ul>
<li><code>'mouseover'</code>: 默认值，鼠标经过时放大；</li>
<li><code>'grab'</code>
：鼠标左键保持按下时放大点击的地方，挪出图片区域或松开后复原；</li>
<li><code>'click'</code> :
鼠标左键点击后保持放大状态，经过时放大经过地方，挪出图片区域保持放大,
跟随鼠标移动的动作放大图片，再次点击后复原；</li>
<li><code>'toggle'</code>：仅放大鼠标左键点击的地方，再次点击时复原。</li>
</ul>
<p>建议使用不同触发事件时配合使用不同的 <code>cursor</code> <a
href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS
样式</a> 作为指示。</p>
<h2 id="duration">duration</h2>
<p>渐入渐出时，数值越大渐出越缓慢，默认为120。</p>
<p>内部调用的是 jQuery 的 <a
href="https://api.jquery.com/fadeTo/">.fadeTo()</a> ，单位是毫秒。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">1000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="target">target</h2>
<p>CSS Selector.
通过设定该属性，可以使图片不在原图片显示区域放大，而在选定的 HTML
Element 上呈现放大图像，原图像保持不变。</p>
<p>下面的代码将会把放大的图像显示在 <code>id</code> 为
<code>myTarget</code> 的 <code>div</code> 中，而原来的图像保持不变。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/example.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myTarget&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;#myTarget&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="touch">touch</h2>
<p>是否启用 <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Touch_events">touch
events</a>, 默认启用。</p>
<h3 id="magnify">magnify</h3>
<p>放大倍数。默认值为1，即不放大。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">magnify</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="callbackonzoominonzoomout">callback/onZoomIn/onZoomOut</h2>
<p>三个属性用法一样：</p>
<ul>
<li><code>callback</code> ：图片加载完成后的回调函数</li>
<li><code>onZoomIn</code> ：图片放大时调用的函数</li>
<li><code>onZoomOut</code> ：图片复原时调用的函数</li>
</ul>
<p>下面代码将在图片放大时将测试文本变为红色，图片恢复时将测试文本变为黑色。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">onZoomIn</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        $(<span class="string">&#x27;#testZoomStatus&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">  &#125;, </span><br><span class="line">    <span class="attr">onZoomOut</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        $(<span class="string">&#x27;#testZoomStatus&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;black&#x27;</span>);     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<p><a href="https://www.jacklmoore.com/zoom/">jQuery Zoom</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-监听窗口关闭</title>
    <url>/JS-listen-browser-window-close/</url>
    <content><![CDATA[<p>JavaScript 监听窗口关闭。初学JavaScript，如有不当请指正。</p>
<span id="more"></span>
<p>接手的项目中有这样一个场景：</p>
<ol type="1">
<li><p>点击打印按钮，生成需要临时文件存储在项目内（该步骤为水晶报表生成打印文件必须进行的流程）；</p></li>
<li><p>弹出新窗口，显示即将打印的文件名和下载按钮供用户确认；</p></li>
<li><p>用户点击下载按钮，浏览器启动下载；</p></li>
<li><p>用户关闭窗口，系统删除生成的临时文件。</p></li>
</ol>
<p>原有的处理方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="variable language_">window</span>.<span class="title function_">onbeforeunload</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">with</span>(<span class="variable language_">window</span>.<span class="property">event</span>) <span class="keyword">if</span> (clientY&lt;<span class="number">0</span>&amp;&amp;clientX+<span class="number">40</span>&gt;<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>||altKey)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">deletePDF</span>(); <span class="comment">// 为了便于表示，将原有的此处代码块写作一个函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原有的写法在 Visual Studio 2015 中编辑器环境下会提示语法错误，但在
Debug / Run 过程中，在其他浏览器中均不会弹出错误提示，但没有跑进
<code>deletePDF()</code> 函数中，在 IE
的测试中部分测试环境会弹出错误弹窗提示：</p>
<blockquote>
<p>JavaScript critical error at ... in ... : Syntax error</p>
</blockquote>
<p>点击 Continue 后与其他浏览器类似，并不会影响文件下载，同样未进入
<code>deletePDF()</code> 函数。</p>
<h1 id="onbeforeunloadbeforeunload">onbeforeunload/beforeunload</h1>
<p>查询 MDN 的 <a
href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload">文档</a><a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> ，<code>onbeforeunload</code> 是
<code>beforeunload</code> 的处理程序。语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; ... &#125;);</span><br></pre></td></tr></table></figure>
<p><em>MDN 建议使用第二种语法。</em> 根据 <a
href="https://stackoverflow.com/a/20001174/8257973">javascript -
beforeunload Or onbeforeunload - Stack Overflow</a><a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
，第一种语法取代原有的处理程序，第二种语法新增一个处理程序。</p>
<p>分别使用上述两种语法修改原有的处理函数，原有的函数中的第 3
行存在语法错误，该语句用于判断鼠标的位置，将该语句移除后将会出现多次触发
<code>onbeforeunload</code> 的情况：</p>
<ul>
<li><p>页面刚进入时</p></li>
<li><p>点击下载按钮时</p></li>
<li><p>关闭窗口时</p></li>
</ul>
<p>以上情况将导致在文件未下载成功前，已进入 <code>deletePDF</code>
，临时文件已被删除无法下载。</p>
<p>实际上，<code>beforeunload</code>
会在多种情况下被触发，包括但不限于提交表单，点击链接/按钮，关闭窗口或标签，通过地址栏，搜索栏，书签等方式访问新页面。</p>
<p>因此，尽管 <code>addEventListener</code>
实现了关闭窗口的监听，却会在关闭窗口前就执行了相关操作。</p>
<p>尝试使用原有的处理方式中的 <code>event.ClientY</code>
进行下一步限制，但实际上仅仅使用 <code>ClientY</code>
将只能检测鼠标的工作情况，而无法检测通过快捷键关闭的情况，原有的处理方式同时检测了
<code>alt</code> 键，但这将导致所有的 <code>alt</code>
快捷键触发。且测试中 <code>event.ClientY</code>
并未起作用，原因尚未查明。</p>
<h1
id="addeventlistenerremoveeventlistener">addEventListener/removeEventListener</h1>
<p>与 <code>addEventListener</code> 对应的方法是
<code>removeEventListener</code> 。这两个方法在不支持 IE 9
以下版本。如果要在 IE9 以下版本使用，应该使用 <code>attachEvent</code>
（实际上 MDN 不建议使用 <code>attachEvent</code> ）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">attachEvent</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="title function_">deletePDF</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="title function_">deletePDF</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过几次尝试，结合 MDN 的文档，<code>addEventListener</code> 与
<code>removeEventListener</code> 必须完全一致，也即，无法添加
<code>window.addEventListner</code> 而移除
<code>button.removeEventListeneer</code> 。</p>
<h1 id="jquery-onoff-bindunbind">jQuery on/off bind/unbind</h1>
<p>在检测关闭窗口并禁止提交触发的实践中，常用的方式还有使用
<code>jQuery</code> ：<code>on/off</code> <code>bind/unbind</code>
。其中 <code>on/off</code> 在 jQuery 1.7 中取代 <code>bind/unbind</code>
。由于项目较老旧，使用的 jQuery 1.2，故使用 <code>bind/unbind</code>
测试。测试中并未进入 <code>deletePDF</code> 函数，原因尚未查明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;[id$=&#x27;_btnDownload&#x27;]&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="variable language_">window</span>).<span class="title function_">unbind</span>(<span class="string">&quot;beforeunload&quot;</span>);</span><br><span class="line">    <span class="comment">// $(window).off(&quot;beforeunload&quot;);</span></span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">bind</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//$(window).on(&quot;beforeunload&quot;, function() &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="添加标志位检测">添加标志位检测</h1>
<p>考虑添加一个监听事件，当按钮按下时变更标志位，标记此次操作触发方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> download = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    download = <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (download)</span><br><span class="line">        download = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="title function_">deletePDF</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此代码可正常工作，但未知是否可能存在这样一种情况：</p>
<ol type="1">
<li><p>用户1点击下载按钮，<code>download = true</code>;</p></li>
<li><p>用户2不进行下载直接关闭窗口，<code>download = true</code>;</p></li>
</ol>
<p>在这种情况下，用户2的操作产生的临时文件将不会被删除。在本地使用 Start
without debug 调试，通过不同浏览器打开不同窗口，此代码可以正常工作。</p>
<h1 id="onunloadunload">onunload/unload</h1>
<p>考虑需求，并不需要实现 <code>beforeunload</code>
中的离开弹窗提示，即可以直接使用 <code>unload</code> 事件，监听
<code>unload</code> 将不会在按钮按下时被触发，使用 <code>unload</code>
似乎更简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unload&quot;</span>, deletePDF);</span><br></pre></td></tr></table></figure>
<p><a
href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#legacy-lifecycle-apis-to-avoid">Page
Lifecycle API | Web | Google Developers</a><a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>
指出：使用 <code>unload</code> , <code>beforeunload</code>
作为检查页面生命周期的方式并不可靠，尤其是 <code>unload</code>
在移动端极不可靠，建议使用 <code>pagehide</code>，而
<code>beforeunload</code>
适用于存在用户未保存的更改时离开页面的监听，并应该在保存后移除该监听事件，不应使用其作为判断页生命周期的方法。</p>
<p>根据该文章的建议，使用以下代码：</p>
<p>（原文使用的是 <code>const</code>， 但经过测试，IE
10及以下版本中并不支持 <code>const</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> terminationEvent = <span class="string">&#x27;onpagehide&#x27;</span> <span class="keyword">in</span> self ? <span class="string">&#x27;pagehide&#x27;</span> : <span class="string">&#x27;unload&#x27;</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(terminationEvent, deletePDF);</span><br></pre></td></tr></table></figure>
<p>该代码在本地测试除 Firefox
以外可正常使用，而该项目没有移动端需求，目前尚不能看出使用
<code>unload</code> 的劣势。</p>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li><p><a
href="https://zh.javascript.info/onload-ondomcontentloaded">页生命周期：DOMContentLoaded,
load, beforeunload, unload</a></p></li>
<li><p><a
href="https://stackoverflow.com/questions/1631959/how-to-capture-the-browser-window-close-event">javascript
- How to capture the browser window close event? - Stack
Overflow</a></p></li>
<li><p><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event">Window:
beforeunload event - Web APIs | MDN</a></p></li>
<li><p><a
href="https://stackoverflow.com/questions/52745244/disable-js-beforeunload-if-button-with-specific-id-has-been-clicked">javascript
- disable js beforeunload if button with specific id has been clicked -
Stack Overflow</a></p></li>
<li><p><a
href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener">EventTarget.removeEventListener()
- Web APIs | MDN</a></p></li>
<li><p><a
href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener()
- Web APIs | MDN</a></p></li>
<li><p><a
href="https://stackoverflow.com/questions/2657182/correct-usage-of-addeventlistener-attachevent">javascript
- correct usage of addeventlistener attachevent - Stack
Overflow</a></p></li>
<li><p><a
href="https://dotblogs.com.tw/jasonyah/2013/05/31/jquery-confirm-when-user-leaving-page-if-changed">[jQuery]
jQuery 實作離開網頁或表單前向使用者確認，以防止使用者誤觸離開按鈕 |
分享你的 Coding 新鮮事 - 點部落</a></p></li>
<li><p><a
href="https://stackoverflow.com/questions/54155648/narrow-down-beforeunload-to-only-fire-if-field-is-changed-or-updated">javascript
- Narrow Down BeforeUnload To Only Fire If Field Is Changed or Updated -
Stack Overflow</a></p></li>
<li><p><a
href="https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event">Window:
unload event - Web APIs | MDN</a></p></li>
<li><p><a
href="https://stackoverflow.com/questions/64273246/capture-close-window-by-beforeunload-but-exclude-asp-button/64311590#64311590">javascript
- capture close window by beforeunload but exclude asp button - Stack
Overflow</a></p></li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload">WindowEventHandlers.onbeforeunload
- Web APIs | MDN</a><a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://stackoverflow.com/questions/20001125/beforeunload-or-onbeforeunload">javascript
- beforeunload Or onbeforeunload - Stack Overflow</a><a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a
href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#legacy-lifecycle-apis-to-avoid">Page
Lifecycle API | Web | Google Developers</a><a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>求职小记2</title>
    <url>/Job-seek-record-2/</url>
    <content><![CDATA[<p>记录近期面试某公司的经历。大部分面试相关的写于刚刚面试完的4月初，后面迟迟未能写完剩下的部分，趁现在还有些记忆补上，顺便简单写写工作一年多的自学经历，以及其他相关的絮絮叨叨，写完发现有点长了，说小记可能都不合适了，不过还是延续一下之前的标题。</p>
<span id="more"></span>
<p>因为一些原因，今年想要找新工作的想法强烈了起来，于是在招聘软件上填了一些简要的信息，因为尚未急着找工作，所以并没有写得特别详细，事实上连简历都没准备好。但还是想了一下在目前的公司工作一年半的经历，列了一些可能对我求职有利的条目，同时观察在招人的公司的招聘信息。经过一段时间的观察，感觉招聘软件上的公司似乎有些参差不齐，公司简介和招聘描述上都很有些问题，比起招聘软件上的卡片，似乎拥有自己的官网招聘页面的公司看起来更值得信赖一些。</p>
<p>虽然在几个平台上简单地挂了个人资料，但并没有抱会有人联络的期待，也没有主动投递。某天晚上刚准备最后练一遍曲子接到来自某公司的HR的招聘电话，当时大概是晚上9点左右。对方简要介绍了一下公司的情况，是某国内企业的外包公司，据说薪资待遇与该企业一致，工作也将与该企业直接对接。对于该企业我并不是很了解，只知道传闻加班严重，同时在
Github
上看到过关于该企业的不良记录的仓库，所以对它的印象并不好。但该企业在大众的印象中似乎普遍还不错，学校的老师常常以学生进入了这家企业为荣，所以我挺好奇它的面试难度和面试流程。可能比较熟悉国内IT企业的已经猜出来是哪个公司了，请不要留下关于特定公司相关信息的评论，如果你想要和我讨论这方面的信息，欢迎私聊。</p>
<p>我最担忧的是它的工作时长，当HR晚上9点仍然在工作的时候，我很难相信IT部门此时早已下班，所以也和打来电话的HR聊了一下这方面的事情，出乎意料的是，对方并没有隐瞒存在加班的情况，我以为通常存在加班的公司都会隐瞒这方面的情况，这让我的印象稍有些好转，但我不清楚是不是对方也明白既然公司规模较大完全隐瞒几乎是不可能的。对方详细地介绍了平常工作的作息时间。我自己算了一下，由于上班时间比较晚，下班再加个班其实非常容易就到了我们痛恨的996了，不过中午的休息时间倒是比较长，目前的工作中午休息时间仅有45分钟，吃完饭洗个碗几乎寥寥无几了。对方表示，通常一周内有3天的加班，也大概介绍了一下在未计入加班工资的情况下可能的薪资。虽然不能认同加班，但薪资确实很诱人，并且此前我从未参与过软件岗位通常会有的面试流程，毕业时可能因为专业不对口，也没什么项目经验，简历初筛就常常已经被淘汰了，有些过了初筛的也都卡在机试环节，从前用的偏底层的语言写程序，后面接触了更多的编程语言后发现实际上其他语言中提供的丰富的库函数会让这种机试容易许多。综合考虑之下还是接受了面试邀请。</p>
<p>收到了机试链接后，很碰巧当时深圳因为疫情封城，泉州也爆发疫情，我一直在关注家里的情况，无心做题。到了机试截止时间的前一天，HR又热切地催促我尝试一下。我被说服了，当天下班练完琴收拾完东西后约莫晚上10:00进入了牛客网的机试考题。与LeetCode稍有不同，它需要自己处理输入输出，稍微花了点时间熟悉了这个部分。一共三道题，150分钟。第一道是经典的爬楼梯递归题的变体，后面想了很久还是没能想出正确的递推表达式，只通过了很小的一部分测试用例。第二道题是数组方面的题，基本上没有太大难度，不过由于平时都是直接查MDN的文档，一些
JavaScript
的接口定义记得不太清楚，工作中其实基本用的C#，在调试上花了不少时间，另外整个题的解法也非常粗糙，几乎是暴力破解，自己都觉得写得非常差劲，同时没有通过所有的用例，但花了很多时间还是没找到自己漏了哪些特殊情况，我估计是因为超时。第三题是字符串和二叉树的结合，应该说是比较经典的问题的变体，但其实那些遍历算法我都不记得，只记得大致如何推导那样的算法，基本上是写出来了，也是有部分用例没有通过，我检查了一些想到的边界情况，似乎并没有问题，不太清楚最后出问题的地方是在哪里。结束机试后我并没有抱太大的希望，因为觉得机试中自己的代码写得非常差劲。第二天收到了HR说机试通过了的消息颇有些吃惊。</p>
<p>机试通过了之后HR才找我要简历，由于本来还没打算投递职位，正处在想着如何写简历的阶段，手头只有毕业时找工作的简历，下班后急急忙忙按照之前的想法临时用PPT做了一张简历发给了对方。后来对方发来了一个类似于性格测评的问卷，题目非常多，每个问题中有三个选项让你选出一个最符合一个最不符合，有些选项的设置非常让人为难，我甚至觉得没有一个符合我会做出的决定，第一次做这样设计的问卷。</p>
<p>做完测评通过后紧接着是HR面试，我想应该没有极少有人会在问卷这一轮被打回吧。面试官应该是HR方面的负责人，他对自己职位的介绍我没能听清，问起籍贯的时候意外地发现是同乡人。简要地介绍了目前的工作，因为平时工作内容确实覆盖很多方面，我的工作从需求、设计、开发到维护都有涉及，所以比起毕业的时候完全不知道该说些什么来介绍自己，这一次从容了许多。另外因为手头的几个古老的程序常常出问题，我对其中涉及业务的代码也算是比较熟悉了，因此在不涉及公司内部的信息的情况下不使用开发人员的术语介绍自己的工作时并没有遇到什么太大的问题。对方也简要介绍了他们公司的业务和分工情况，总体的沟通比较友善。期间有问到为何想要寻求新的工作，也问到了目前的薪资，这也是我第一次意识到原来跳槽的时候下一份工作的薪资很可能会与目前的薪资相关。但有一点觉得很有被冒犯的就是被问及了是否单身，我觉得公司能问到这个问题，某种程度上也表明公司本身或者工作本身可能干涉到个人的生活。</p>
<p>HR面试通过后，对接的HR很快就联系安排技术面试。因为此前并没有经历过技术面试，其实我不太了解会是什么情况。第一次的技术面试面试官是女性，先问了一些简历上写的项目和工作，因为对手上负责的几个系统都比较熟悉，和目前工作相关的基本没什么问题，但和实习相关的其实我不太记得了，当时的实习实际上整个团队都非常不专业，所以虽然涉及了业务流程设计图的绘制，但其实并没有真正了解它的概念，直到现在我都觉得当时那段经历可能最大的收获就是无论如何我都要避免进入与官方产生关联的项目，前段时间突然了解到的更多关于当时的公司和合作伙伴的信息更让我觉得当时的团队或许算得上是一个傀儡，没日没夜的加班和无意义的返工只能是让人身心俱疲。</p>
<p>后来面试官说留意到实际上我是学电子出身，即偏向硬件方面的专业，却在简历上写了一些软件类的工作和编程语言，这点当时我没有做更多的解释。接下来问了一些基础的技术基本功问题，二叉树的遍历，程序的编译的，图的遍历，数据结构，包括一些变量的存储位置之类的，但我太久没有复习这方面的知识了，如果给我个题目让我写我可能可以自己分析出来，但要说这些概念，我实在是毫无头绪了，我甚至连前序中序后序都不记得是什么顺序了，要是我是面试官，估计都想直接结束面试了。从面试官问的问题来看，她可能平常用的是
C/C++，虽然在毕业前我也大多是用C，写一些很小规模的单片机程序，当时对那些底层的东西稍微读过一点点，不过确实很久没接触了，几乎忘得一干二净。简单的抛了几个问题后，进入了现场编程环节，此时面试官表示我此前的机试成绩还不错，这点我倒是没有想到。非常尴尬的是，此前我问HR是否需要准备什么，对方可能没想到我恰好没有IDE环境，和我说无需准备。因为正好旧电脑跑起来非常吃力，换了新的电脑，没打算急着装太多的软件，整个电脑基本只有装机的初始环境，只能打开记事本写代码。试题是一道涉及单调栈的数组题，题目也不是很难，暴力破解可以解出，但我当时其实在想这道题的时候陷入了一个死胡同，在记录数组的值还是索引的时候搞错了，尽管面试官给了提示，我仍未找到正确的方向，因此只写了一个性能非常差的版本，当然也跟面试官讨论了这里面存在的问题。后面我在LeetCode上看到了这道题的原题，突然想起来当天写代码的时候实际上记错接口了，如果是真正到调试环境，根本不可能得到正确的结果，甚至应该会直接报错，但由于面试官对JS似乎不熟悉，她似乎没有发现。我不知道是不是可以这么说，实际上技术面试面试官更想听面试者的想法以及对于题目的探讨而不是实际的代码。</p>
<p>后来又接到了第二次技术面试的邀请，其实我觉得自己第一次技术面试有太多基础性问题没有答出，代码也写得不怎么样，大概知道了自己需要查缺补漏什么，并没有强烈的继续参与面试的意愿，也跟HR表示了想要放弃继续面试的想法，但又被对方的一通电话说服了。但此次通话中对方试图用产假和二胎产假作为有利条件还是让我有些反感，就好像生育和生育二胎是一个女性的必然选择。另外对方还提到作为女性，即使遇到骚扰事件（当然对方的原话比较委婉一些）也有平台可以直接举报，我当然很认同有举报平台的好，但当这方面作为一个宣传点的时候难道不是应该重点在于它会不会发生吗？这好像在告诉我这是很常见的，但你可以维权，难道更多关心的不是应该在不要这样的事情发生吗？我非常不理解对方把此作为筹码。</p>
<p>第二次的技术面面试官也是简要地先了解了我的工作情况。另外他对我工作中用C#开发，却用JS去考机试题感到奇怪，之前也想过用Python，但感觉还是JS更接近于我的编程习惯，后来看到《JavaScript二十年》中提到JS是类C的设计，才突然明白过来好像确实如此，所以在刚接触的时候也并不觉得会有很多陌生的地方（顺便一提，目前看了一小部分，本书中提到了非常多的一些JS的设计历史，感觉对理解一些特性还挺有帮助的），同时又不会像C#那样有比较严格的数据类型和写法的定义，当然这个在编程的时候可能也是更容易引入一些隐患，不报错的Bug实际上是远远比Error更难排查和修复的，因为无法直接定位Bug。基础的技术问题问了JS中的数据结构，还问了
<code>const</code> <code>var</code> <code>let</code>
的区别，我记得自己曾经详细看过这个区别，但如今不记得了，也坦言了不了解，面试后就把这个区别补了一下。</p>
<p>后来马上就进入了现场编程，面试官抛出了一道字符串解码题，在讨论过程中实际上我感到面试官似乎也没有很了解这道题，因为他对其中的部分用例的解释并不太明确，甚至有点曲解，后来我们也就此进行了讨论，大概讲了一下自己的想法以及题目中比较棘手的地方，不知道是不是因为讨论和编码没能顺利进行，面试官又换了一道较为简单的题目，判断最长无重复字符串。这道题我很快写完了，用一个
<code>Set</code> 就可以搞定，后面执行一个随便生成的测试用例时发现存在
bug，面试官跟我讨论了这个情况，但看起来他对这道题或者是对JS也不熟悉，他建议我改用
<code>Map</code> 去处理问题，但实际上问题并不在这里，也实际上不需要用到
<code>Map</code>
，问题在于每一次遍历时的起点处理错误，忽视了当前的遍历项才是下一个可能性的起点，我很快修正了代码，得到了正确的结果。面试结束。后面这题后来我也在
LeetCode 上看到了。</p>
<p>第二次技术面试结束后没多久，HR就联系安排了终面，对方似乎是团队主管。仍然是大概聊了聊目前的工作，以及未来可能的工作，也聊了我非常关心的加班，对方说其实晚上的时间过得很快，常常是开个会或者分享一下技术学习就过去了，但这并不能改变需要加班的事实啊，是吧。对方基本已有明确的招聘意愿，倒是我这边犹豫不决。此次面试对方又问及了婚姻状况，是否单身，我又有些反感了。其间我也表示实际上自己去年因为跑去教小朋友学钢琴，没花多少时间在技术方面，目前准备也很仓促，对方表示既然已经通过了机试和两次技术面，说明问题不大，有技术基础，而我又不可能以钢琴为生，跑去搞文艺很可惜。面试官在说这句话的时候我满脑子想的都是前阵子在豆瓣上看到的一个日本的后端工程师辞职跑去音乐学院学爵士乐了哈哈哈哈哈，其实我非常希望未来我也能做出这样的选择(=•ω＜=)。</p>
<p>不可能以钢琴为生这点我当然认同，并且这个爱好当然也和我的工作基本上毫无关系，即公司根本不可能关心这一点。事实上我从初二之后基本上就没有接受过专业的教学了，自娱自乐而已，跑去教小朋友弹琴也是非常偶然的事情，本来只是想去找台钢琴练琴的，后来认识了那里的钢琴老师，当了她女儿的老师，之后也是这位朋友才接了一些辅助的教学工作，和有些小朋友的接触其实还蛮有趣的，有几个小朋友非常信任我也让我感到很开心。但由于还是存在一些利益关系的麻烦，后来所有的教学和相关的工作都挪到了我一个人身上我也力不从心了，没有足够的精力备课和练习，我相信如果我要教小朋友首先我自己的练习必然是要保证的，也力求在每次上课前提前到钢琴教室弹一些小曲子，但当时公司的工作系统维护量也很大，每天接触8个小时代码吃完饭又要跑去给小朋友上课还是太困难了，在正好有几个小朋友搬家，所剩的学生不多，带完他们的课也就不再继续了。按照当时拿到的薪水，如果以此为生，即使接满课可能也就勉强能支付我公租房的房租吧。当然我对于技术的了解其实也很有限，虽然最近接触了一些更为开放的社区后也希望自己能做一些有趣的东西出来，希望为自己喜欢的关注的其他领域做一些便利的工具，我逐渐意识到其他领域的从业人员事实上很少会在信息化这方面下功夫，在计算机领域已经实现了的信息化可能在其他领域上的实践仍然相当传统，当然要学的东西还有太多太多了哈哈哈哈哈哈。但你要说不搞技术了是不是可惜呢，其实我不太确定。
几年前我去看画展的时候，很冒犯地跑去弹了摆在那里展销的较为名贵的钢琴，后来那个毕业于音乐学院的销售人员听说了我的专业后跟我说没去学琴很可惜。我不知道到底哪一面更可惜一些，唯一确定的是，写代码和弹钢琴都是现在我的生活中几乎不可或缺的一部分了，希望未来它们都不会走散！所以对于无法让我留出足够的时间去生活的工作，我想如果在需要做出选择的时候我不是经济窘迫的处境的话我大概不会接受，虽然如此，还是打了个电话和父母聊了聊，这好像是我们第一次聊这么久，另外又因为疫情，父母很难得都在家，聊到最后我和父亲感到最诱惑的是周边的生活环境哈哈哈哈，不过母亲的担心就比较现实，担心各种安危和适应性问题，虽然有很大的诱惑，但还是决定拒绝，后面也明确转达了拒绝的意向给一直跟进的HR。</p>
<p>没想到过了一段时间后，又有另一个HR来跟我联系，或许是觉得女性之间比较好沟通吗？虽然确实感到跟后一个HR的沟通比较愉快，但我想那可能也是因为我已经明确不去的意愿，所以没有太多的顾虑了，完全可以和HR敞开聊，没有太多的顾忌，更像是初识的朋友的闲聊。因为上班的时候不需要用到微信，我基本只用电脑，几乎不看手机，所以和另一个HR聊起来的时候也是下班的时候，对方发来消息的时候我刚买完菜回到家，你看，我如何指望自己过着悠闲的生活会突然想跑去加班，当然话说回来如果不是对方公司都有加班，我也没有上面那些面试了。跟这个HR聊了好一会儿，对方说“你就是那种高薪也吸引不过来的那种人吧，因为你清楚这个跟工作是等量的”，那倒也不是，我以为薪资和工作是否等量是一回事，是否应该加班又是另一回事，我也并不是什么富足的家庭出身，薪资还是很重要的。工作和薪资不等量的情况比比皆是，难道这就需要加班吗？以此堂皇地说什么只要加班就能拿到更多的薪资简直是荒谬。但真正让我拒绝的可能还是我很担心频繁在面试时提及婚育的企业内部的文化，以及这个企业本身它的背景我认为它是几乎不可能支持性少数群体，并且与官方有太多的联系，同时它在民众里的光环太重，即使你知道它曾经有那么多的恶行被收录在
Github
中，你的亲人和身边的更多的人其实并不了解，而通常，他们可能会站在人多势众的那一头，看过太多这样的例子了，当然我并没有这么说，但表达了一些可能自己更会去选择的公司的类型，后来对方不再劝说了。至此，面试结束。</p>
<p>对于本次面试，前期的准备几乎没有太多，但比起刚毕业时貌似还是从容了许多。可能是因为刚毕业的时候毕竟本专业的方向是电子，没有项目经历几乎很难写简历和介绍自己，最接近的可能就是和其他学院组队的飞思参赛经验，但其实真正搞过这些比赛的人或许大概都知道，实际上学校内的那些比赛作品真正拥有自己独创的设计非常少，更多的都是照葫芦画瓢，东抄西搬的拼凑，你要是真正去问里面的某个代码实现被替换的时候为何无法工作大部分人都回答不上来，我就遇到过变更某个赋值逻辑的时候出问题去问当时制作过相关作品的人，没有人回答上来究竟是为什么，后来找了很多资料才发现实际上如果真的仔细读过两种不同型号的芯片关于那个寄存器的操作手册，那其实是一个显而易见的答案。至于为何没有选择从事电子方向，其实主要是因为它的实践需要依靠实物，而软件则没有那么多的要求，你甚至可以用远隔重洋的服务器来进行实践。另外还有一个让我不太愿意从事电子方向的原因是，当时授课的老师有一位有较为丰富的工程经验，他在课中的某个关于电源的参数取值讲解中称，需要依靠工程经验，这让我非常惊讶，因为自己动手改造电源的时候曾经不慎把正负极短接引起了整个实验室跳闸，所幸并没有造成什么严重后果，所以我一直认为电源是较为危险且必须精密计算的元件，我不能理解为什么会有依靠工程经验做的决定，但这位老师在电源领域确实非常精通，所以如果他这么说了，那我想可能很大部分工程师也是这么做的。</p>
<p>至于刷题，基本上是三天打鱼两天晒网的状态，周日早上抽个半小时做一下周赛，能做多少做多少(之所以是半小时，周末在家的话一般会在中午也会练琴，为了不太多打扰邻居，感觉饭点比较合适，所以通常十一点就跑去练琴了)。由于软件工程师的工作性质，基本上难以免去在线编程的技术面试环节，有些公司似乎还有更多轮的面试。刷题对于了解和应用算法和数据结构还是很有帮助的，虽然实际上在后端开发的时候遇到的问题其实更多的是业务性的问题，在这方面
LeetCode 其实它比较接近已经经过对业务逻辑的理解抽象过后的问题，相比之下
CodeChef
的问题会更接近于原生业务问题，它对场景的描述更多，解题者首先要理解场景。对于正则表达式的问题，推荐
Hackkerrank
的正则专题，基本上把整个专题过一遍对正则表达式的常用方法就可以有一个相对系统的了解了。当然我做的题量其实很少，所以可能这样的描述也不太准确。经过本次面试，大概会花点时间系统学一下数据结构和算法，如果时间允许，大概还要补一下计算机的几门基础课程。另外也发现面试还是挺耗时间和精力的，与毕业时不同，广撒网可能并不是现在会去做的一个选择了。当然最后还有一点就是要常常更新简历啦，临时编了一份简历其实自己都记不太清写了哪些，而面试官恰恰会针对你的简历来提问。</p>
<p>最后大概介绍一下入职的两年里我是如何自学工作中所需的相关知识的。我在入职之后看到工作内容完全是懵的，除了
SQL 和 HTML
曾经接触过一点以外，其他的几乎是一无所知。虽然有人带，但你不可能指望同事从头讲起，不过这位同事确实给了我非常大的帮助，开头几个月基本上我遇到什么问题都会去请教他，现在有时遇到技术上的问题也会找他一起讨论。公司用的是
C# 进行开发，前端方面会涉及一些
JS，不过不是特别多，版本也很古老。我在入职之后未接管项目之前只接到了一个很小的
Task，添加一个显示照片的按钮和功能，算是很简单的
Task。大概在入职一个多月后现在所在的组有同事离职，她手上的工作全部转交给我，我开始接手维护项目。在这之前的日常中我基本上是在学
JS，期间偶尔也刷刷题练习以练习新接触的语法和接口，然后看看公司的项目，实际上编程语言并不是什么阻碍，当已经掌握了一种编程语言之后，转到另一种编程语言实际上并不是太难，了解一下语法之后上手写代码就会逐渐熟悉。</p>
<p>JS 的学习主要是读 MDN 的 Reference, 虽然 MDN
有中文版，但很多是跟不上英文版的文档的，因此还是建议读接口的时候直接读英文版，否则你可能会发现有一些接口的参数或者实现已经发生了变化但问文档跟不上，还通读了<a
href="https://zh.javascript.info/">现代
JavaScript</a>，此系列教程有完整的中文翻译，教程中也常常附上
sanbox，对于学习实践非常有帮助。 C#
的学习倒没有特别读什么，一般是遇到相关接口的时候直接查 MSDN 的
Reference。开始接手维护项目后，发现很多页面的前端都是沿用十几年前的古老代码，CSS
样式也是有点混乱，于是我也开始学习一些 CSS
方面的知识，感叹一些前端工程师可以使用纯 CSS 实现非常棒的 UI 。CSS
方面的学习是把 Google <a href="https://web.dev/">web.dev</a> 里面的
Learn CSS
部分全部读了一遍，最近看到又出了几章新的内容，这个系列教程从概念到实现都讲解得非常细致，参考资料也都很有拓展的意义。对于前端方面，Code
Pen 有一个 <a href="https://codepen.io/challenges">CodePen
Challenges</a>，每周发布一次新的 Challenge，每月封顶四次, 你可以在它给的
Demo 上面进行前端练习，同时也可以看到其他人的非常精彩的设计，另外每周的
Chanllege，Code Pen 会提供一些 Resources，针对当期的 Challenge
给出一些相关的参考资料，这些参考文章或者 Demo
通常也对前端方面的学习和练习提出了很多的方案，尤其是一些 CSS Tricks
上面的巧妙实现常常让人惊叹。SQL部分做了 <a
href="https://sqlzoo.net/wiki/SQL_Tutorial">SQLZOO</a>
的练习来复习和学习曾经学过但不太记得的东西。另外比较综合性的还有 <a
href="https://www.freecodecamp.org/">freeCodeCamp</a> 的系列和
Project，这里面我只挑了一小部分。<a
href="https://fullstackopen.com/zh/">深入浅出现代 Web
编程</a>也讲解得比较系统，我目前只学到了第四章。</p>
<p>大体上自学的部分就包括这些内容，剩下的就是读自己维护的系统的错综复杂的源码，和上手去调试和修改优化现有的代码，记录下维护过程中碰到的可能从代码层面解决的问题。去年下半年开始参与比较多的开发工作，也开始对手上最庞大最复杂的加班系统进行一些重写和重构的工作，一边分析维护记录，一边分析历史需求的业务逻辑，寻找解决方案，现在
To Do List
已经排满满的。该系统一共包括一套网页端的各种加班相关的申请和审批，一套手机端的精简版的加班审批，两套不同的接口，四套不同的自动更新程序，本月的项目完成部署后该系统还将新增两套自动更新程序，以及更多的审批功能。所有这一整个
Project
的最大问题一方面是历史文档太少，几乎无法完整再现历史需求，残留代码处处是雷，相同逻辑在各个不同的服务间都有出现，但版本不一致，未能统一抽象，一方面系统日志非常粗糙，几乎等于没有，我的日常维护常常是在猜谜，做无数个可能性推断并找相关证据证明确实如此，简直是在读推理小说了哈哈哈哈。</p>
<p>经过一段时间的改进，该系统目前的维护频率已经小了许多，但还是不断爆出很多历史残留问题，虽然手上有十来个内部系统，但基本上大部分精力都花在了维护这个系统上面了。目前即将发布的项目也是接手以来的最大的需求和最大的版本变更，从开始的需求讨论跟进，到数据库设计，功能的实现和开发，用户测试的跟进，以及将要进行的发布，基本都由我主要统筹，也参与其中的模块开发，完全意识到了文档的重要性，目前也还有一大堆文档没有写完。关于你的系统需要多少文档，一个项目需要多少文档来支撑，可以读一下论文
<a
href="http://www-scf.usc.edu/~csci201/lectures/Lecture11/royce1970.pdf">MANAGING
THE DEVELOPMENT OF LARGE SOFTWARE SYSTEMS
(PDF)</a>。另外最近因为发现公司的版本控制只实现了TFS团队控制，对于本地开发的版本控制全凭开发者自己的记忆，这实在是相当困难，尤其是当我同时在一个时间段内对几个不同的
Bug 进行复现和修复的时候，常常很难进行变更的追溯，我在本地引入了 Git,
对此进行控制，主要是通过读 Git Reference
进行学习，另外也非常推荐新手先玩一下 <a
href="https://learngitbranching.js.org/">Learn Git Branching</a> 熟悉
Git 的基本命令。我也对自己的 Blog Source 进行了 Git 版本控制，同时与
Github 的私有仓库进行同步，不过仍在摸索中。</p>
<p>先写到这里吧，下次面试再记录~</p>
<p>上一次的面试记录：<a
href="https://blog.fish-404.icu/Bookcomment-job-seek-record/">书评-求职小记
| 在逃的貓 (fish-404.icu)</a></p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>Job</tag>
      </tags>
  </entry>
  <entry>
    <title>Neo4j之python连接失败解决(py2neo)</title>
    <url>/KG-py2neo-python-connect-neo4j/</url>
    <content><![CDATA[<p>本文简述在 python 中使用 py2neo 连接 Neo4j
及连接时可能遇到的问题和解决方法。</p>
<span id="more"></span>
<p>使用 <code>pip</code> 工具安装 py2neo 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install py2neo</span><br></pre></td></tr></table></figure>
<p>若已安装 pip 仍提示 <code>pip : command not found</code>
，可以切换到到 Python
的安装目录<code>&lt;Installation floder&gt;\Scripts</code>目录下，使用以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./pip install py2neo</span><br></pre></td></tr></table></figure>
<p>由于网络原因，有可能多次下载失败，这种情况可以选择到
<a href="https://pypi.org">PyPI</a> 手动下载<a
href="https://pypi.org/project/py2neo/#files">py2neo package</a>
，再使用 <code>pip</code> 进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install THE_PACKAGE_PATH</span><br></pre></td></tr></table></figure>
<p>导入 py2neo :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> py2neo</span><br></pre></td></tr></table></figure>
<p>调用 <code>py2neo.Graph()</code> 函数连接Neo4j中已有的图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;graph=py2neo.Graph(&quot;bolt://localhost:7687&quot;)</span><br></pre></td></tr></table></figure>
<p>注：这里的端口是一般情况下的默认端口号，在该端口被占用的情况下Neo4j启用的访问端口可能并不是此端口号。</p>
<p>此时并不能看出连接是否成功，可以使用查询语句查看是否能查询到结果，若连接成功，则此时可以使用图实例所提供的各项功能，py2neo
中提供了对节点、关系，以及各类操作的方法，也可以调用 Cypher
语句进行操作。</p>
<p>这里我们通过调用 <code>len()</code>
函数对节点进行计数来查看连接状态：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">len</span>(graph.nodes)</span><br></pre></td></tr></table></figure>
<p>若连接不成功，可能看到以下错误提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last): </span><br><span class="line">    File &quot;E:\Python\lib\site-packages\py2neo\database.py&quot;, line 828, in run entities=entities))</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\py2neo\internal\connectors.py&quot;, line 292, in run return self._run_1(statement, parameters, graph, keys, entities)</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\py2neo\internal\connectors.py&quot;, line 241, in _run_1cx = self.pool.acquire()</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\neobolt\direct.py&quot;, line 715, in acquire return self.acquire_direct(self.address)</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\neobolt\direct.py&quot;, line 608, in acquire_direct connection = self.connector(address, error_handler=self.connection_error_handler)</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\py2neo\internal\connectors.py&quot;, line 227, in connector encrypted=cx_data[&quot;secure&quot;], **kwargs)</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\neobolt\direct.py&quot;, line 972, in connect raise last_error </span><br><span class="line">    File &quot;E:\Python\lib\site-packages\neobolt\direct.py&quot;, line 964, in connect connection = _handshake(s, address, der_encoded_server_certificate, **config)</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\neobolt\direct.py&quot;, line 932, in _handshake connection.hello()</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\neobolt\direct.py&quot;, line 249, in hello self.sync()</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\neobolt\direct.py&quot;, line 527, in sync detail_delta, summary_delta = self.fetch()</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\neobolt\direct.py&quot;, line 419, in fetch    return self._fetch()</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\neobolt\direct.py&quot;, line 461, in _fetch  response.on_failure(summary_metadata or &#123;&#125;)</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\neobolt\direct.py&quot;, line 774, in on_failure raise AuthError(message)</span><br><span class="line">neobolt.exceptions.AuthError: The client is unauthorized due to authentication failure.                                                                             During handling of the above exception, another exception occurred:                 Traceback (most recent call last):</span><br><span class="line">    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\py2neo\matching.py&quot;, line 196, in __len__  return len(self.match())</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\py2neo\matching.py&quot;, line 80, in __len__ return self.graph.evaluate(*self._query_and_parameters(count=True))</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\py2neo\database.py&quot;, line 395, in evaluate return self.begin(autocommit=True).evaluate(cypher, parameters, **kwparameters)</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\py2neo\database.py&quot;, line 876, in evaluate return self.run(cypher, parameters, **kwparameters).evaluate(0)</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\py2neo\database.py&quot;, line 830, in run raise GraphError.hydrate(&#123;&quot;code&quot;: error.code, &quot;message&quot;: error.message&#125;)</span><br><span class="line">    File &quot;E:\Python\lib\site-packages\py2neo\database.py&quot;, line 676, in hydrate_, classification, category, title = code.split(&quot;.&quot;)                                   AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;split&#x27;                     </span><br></pre></td></tr></table></figure>
<p>可以看到是身份验证失败而产生的错误。这是由于连接时未设置用户名和密码导致的，默认用户名为
<code>neo4j</code>，密码为<code>password</code>，而 Neo4j 默认密码为
<code>neo4j</code> ，因此导致了认证失败，同时在第一次开启图数据库时
Neo4j 会提示设立身份验证方式，此时设置的密码将用于登录，若使用 Neo4j
Browser，并不会在每一次登陆时都提示身份验证，因此并未注意到这一点。在
Neo4j Browser 中使用 <code>server user list</code> 可以看到此时有名为
<code>neo4j</code> 的使用者。可以使用 <code>server user add</code>
命令添加一个用户，用此用户作为 <code>Graph()</code> 的 <code>auth</code>
项参数登录即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;graph=py2neo.Graph(<span class="string">&quot;bolt://localhost:7687&quot;</span>, auth=(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>注：在查找此问题的解决方式时看到有提议用 <code>neo4j-admin</code>
工具修改初始密码，在 Windows 下，此工具并不是直接以 <code>*.exe</code>
的可执行文件出现，而是 <code>*.bat</code> 的批处理文件，并且在 Neo4j
Desktop 版本下此工具不是位于
<code>&lt;Installation Folder&gt;/bin</code> ，而应该切换至
<code>&lt;Database Folder&gt;/bin</code> 目录下，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./neo4j-admin.bat YOURCOMMAND</span><br></pre></td></tr></table></figure>
<p>但在此操作应该是在数据库未建立时，否则，将会提示此时的权限已经转移到
<code>&lt;Database Folder&gt;/data/dbms/</code> 下的 <code>auth</code>
文件中，如果要重设密码应该移除 <code>auth</code> 和 <code>role</code>
相关文件或者重设该数据库，所以并不能使用此方式，新建一个用户应该是一个比较好的选择。</p>
<ul>
<li><strong>参考资料</strong>：<a href="https://py2neo.org/v4/index.html">The
Py2neo v4 Handbook</a></li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>Neo4j</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Neo4j之Cypher语句</title>
    <url>/KG-Cypher-learning/</url>
    <content><![CDATA[<p>本文为图数据库 Neo4j 查询语言 Cypher 学习笔记，包括
<code>MATCH</code> <code>RETURN</code> <code>CREATE</code>
<code>DELETE</code> <code>REMOVE</code> <code>MERGE</code>
语句的基本用法。</p>
<span id="more"></span>
<h1 id="match">MATCH</h1>
<p><code>MATCH</code> 语句用于查询，常与 <code>WHERE</code> 连用，与 SQL
语句中的 <code>SELECT ... FROM ... WHERE</code> 用法相似。</p>
<h2 id="查找节点">查找节点</h2>
<h3 id="查找所有节点">查找所有节点</h3>
<p>以下命令将返回所有节点，若在 Neo4j Browser
下，则会返回整个图，包括节点和关系，与 SQL 中的 <code>SELECT *</code>
类似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n) </span><br><span class="line">RETURN n</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol type="1">
<li><p>分行并非必要；</p></li>
<li><p><code>n</code>
相当于一个假定变量，大小写敏感，前后不一致将会导致变量未定义错误，同时，因为
<code>n</code>
是一个假定变量，因此在查询语句的书写时和程序中设置变量一样可以使用一个更具体的描述词，而不是使用通常的变量名
<code>n</code> <code>x</code> <code>y</code>
，增强查询语句的可读性；</p></li>
<li><p>括号是必要的，作为模式的表示方式，节点是最简单的模式；</p></li>
<li><p>关键字的大小写不敏感，与 SQL
类似，大小写混用并不会出错，但并不建议混用。</p></li>
</ol>
<h3 id="查找指定标签节点">查找指定标签节点</h3>
<p>以下命令返回 <code>Lable</code> 标签下的所有节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n:Lable)</span><br><span class="line">RETURN n</span><br></pre></td></tr></table></figure>
<h3 id="查找连接节点">查找连接节点</h3>
<p>以下命令返回与带 <code>Label</code> 标签，属性 <code>name</code> 值为
<code>a</code> 的节点相连接的所有节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (Lable&#123;name:&#x27;a&#x27;&#125;)--(n)</span><br><span class="line">RETURN n</span><br></pre></td></tr></table></figure>
<p>若要限定返回节点的标签 <code>Lable1</code>，可在变量 <code>n</code>
后做限定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (Lalbe&#123;name:&#x27;a&#x27;&#125;)--(n:Lable1)</span><br><span class="line">RETURN n</span><br></pre></td></tr></table></figure>
<p>关系表示符可指定方向：</p>
<ul>
<li><p><code>--</code> ：任意方向；</p></li>
<li><p><code>--&gt;</code> ：指向其他节点；</p></li>
<li><p><code>&lt;--</code> ：指向自身。</p></li>
</ul>
<h2 id="查找关系">查找关系</h2>
<h3 id="查找关系类型">查找关系类型</h3>
<p>以下命令返回连接 <code>Lable</code> 标签下 <code>name</code>
属性分别为 <code>a</code>, <code>b</code> 的两个节点的关系类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (:Lable&#123;name:&#x27;a&#x27;&#125;)-[r]-(:Lable&#123;name:&#x27;b&#x27;&#125;)</span><br><span class="line">RETURN TYPE(r) </span><br></pre></td></tr></table></figure>
<p><code>TYPE</code> 大小写不敏感。</p>
<p>若两个节点间没有关系，则不会做任何改变，也无返回值。</p>
<p>若要指定关系方向，可将第一句改为以下两种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (:Lable&#123;name:&#x27;a&#x27;&#125;)&lt;-[r]-(:Lable&#123;name:&#x27;b&#x27;&#125;)</span><br><span class="line">MATCH (:Lable&#123;name:&#x27;a&#x27;&#125;)-[r]-&gt;(:Lable&#123;name:&#x27;b&#x27;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="查找指定关系">查找指定关系</h3>
<p>以下命令返回关系类型为 <code>RELAY</code> 的节点及其关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (a)-[:RELAY]-(b)</span><br><span class="line">RETURN *  </span><br></pre></td></tr></table></figure>
<p>匹配多个关系可用管道符 <code>|</code> 连接，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (a)-[:RELAY|:RELAY1]-(b)</span><br></pre></td></tr></table></figure>
<h1 id="return">RETURN</h1>
<p><code>RETURN</code>
语句设定返回类型，如上面提到的返回节点，返回关系，返回节点的特定属性。已上一个命令为例，返回的是所有节点和关系，相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (a)-[r:RELAY]-(b)</span><br><span class="line">RETURN a, b, r</span><br></pre></td></tr></table></figure>
<p>若要返回节点属性 <code>name</code>，可写作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (a)-[:RELAY]-(b)</span><br><span class="line">RETURN a.name</span><br></pre></td></tr></table></figure>
<p>返回关系类型上面已提及，不重复描述。</p>
<h1 id="create">CREATE</h1>
<h2 id="创建节点">创建节点</h2>
<p>若要查看创建节点的结果，需用 <code>RETURN</code>
语句返回，实际上以下其他命令也是如此，下面不再列出 <code>RETURN</code>
语句除非必要。否则仅会输出提示节点的创建数量、属性的设置数量、标签的创建数量。</p>
<h3 id="创建空节点">创建空节点</h3>
<p>以下命令创建一个空节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (n)</span><br></pre></td></tr></table></figure>
<p>若要创建多个节点，可用逗号分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (n), (m)</span><br></pre></td></tr></table></figure>
<h3 id="创建带标签的节点">创建带标签的节点</h3>
<p>以下命令创建一个带标签的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (n:Lable)</span><br></pre></td></tr></table></figure>
<p>若要创建多个标签，可紧随其后。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (n:Lalbe:Lable1)</span><br></pre></td></tr></table></figure>
<h3 id="创建带属性节点">创建带属性节点</h3>
<p>以下命令创建一个带属性节点，并指定 <code>name</code>
<code>name1</code>为属性名， <code>a</code> <code>b</code> 为属性值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (n:Lable&#123;name:&#x27;a&#x27;, name1:&#x27;b&#x27;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="创建关系">创建关系</h2>
<p>创建关系首先要使用 <code>MATCH</code>
语句匹配到关系的起点和终点。以下命令先匹配到 <code>a</code>
<code>b</code> 两个节点，然后建立两个节点间的关系
<code>RELAY</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (a:Lable&#123;name:&#x27;a&#x27;&#125;), (b:Lable&#123;name:&#x27;b&#x27;&#125;)</span><br><span class="line">CREATE (a)-[:RELAY]-&gt;(b)</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol type="1">
<li><p>关系的创建与查询时不同，必须指明关系方向，仅允许创建有方向的关系；</p></li>
<li><p>关系创建时必须设定关系名；</p></li>
<li><p>此匹配节点语句并不是最佳，会弹出 <code>Warning</code>
提示建议使用 <code>OPIONAL MATCH</code>
优化查询速度，此处不做探讨。</p></li>
</ol>
<h1 id="delete">DELETE</h1>
<p><code>DELETE</code>
语句用于删除节点或关系。需要先查找到节点或者关系，实际上在仅对节点和关系的删除上只要把
<code>MATCH</code> 中的 <code>RETURN</code> 语句换做 <code>DELETE</code>
语句就可以完成删除。</p>
<p>有一点不同的是，<code>DELETE</code>
语句可以在删除节点的同时删除掉与之的关系，使用
<code>DETACH DELETE</code>, 如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n:Lable&#123;name:&#x27;a&#x27;&#125;)</span><br><span class="line">DETACH DELETE n</span><br></pre></td></tr></table></figure>
<p>以下命令可以删除所有节点和关系，在学习试验的小数据中很有用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n)</span><br><span class="line">DETACH DELETE n</span><br></pre></td></tr></table></figure>
<h1 id="remove">REMOVE</h1>
<h2 id="移除节点属性">移除节点属性</h2>
<p>Neo4j 不允许属性值为
<code>null</code>，所以移除节点属性也可说是用于删除该属性。以下命令移除所有节点的
<code>name</code> 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n)</span><br><span class="line">REMOVE n.name</span><br></pre></td></tr></table></figure>
<p><code>REMOVE</code> 语句无法使用一条命令删除所有属性，需要使用
<code>SET</code> 语句，此处不做探讨。</p>
<h2 id="移除节点标签">移除节点标签</h2>
<p>以下命令移除节点 <code>a</code> 标签
<code>Lable</code>，移除多个标签和 <code>CREATE</code> 语句类似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n&#123;name:&#x27;a&#x27;&#125;)</span><br><span class="line">REMOVE a:Lable</span><br></pre></td></tr></table></figure>
<h1 id="merge">MERGE</h1>
<p><code>MERGE</code> 命令用于在模式匹配不成功时创建该模式，类似先通过
<code>MATHCH</code> 进行模式查找，再用 <code>CREATE</code>
进行模式创建。相比后一种方式，<code>MERGE</code>
命令更简洁，但无法进行部分匹配，一旦匹配表达式的某项不满足，整个模式都将被创建。</p>
<h2 id="归并节点">归并节点</h2>
<h3 id="归并节点标签">归并节点标签</h3>
<p>以下命令查找是否存在标签为 <code>LABEL</code>
的节点，若不存在，则创建一个标签为 <code>LABEL</code>
的节点，若存在，则不会做出改动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MERGE (n:LABEL)</span><br></pre></td></tr></table></figure>
<h3 id="归并节点属性">归并节点属性</h3>
<p>以下命令查找是否存在 <code>name</code> 属性为 <code>n</code>
的节点，若不存在，则创建一个 <code>name</code> 属性为 <code>n</code>
的节点，若存在，则不做出改动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MERGE (n&#123;name:&#x27;n&#x27;&#125;)</span><br></pre></td></tr></table></figure>
<p>要匹配多个属性及其对应的值可用逗号隔开，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MERGE (n&#123;name1:&#x27;n&#x27;, name2:&#x27;m&#x27;&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面这条语句的情况下，只有 <code>name1</code> 和 <code>name2</code>
属性同时满足匹配条件时才不会对图数据库做出改动，只要不存在有一个节点同时满足上述两个条件，则会创建新的节点，即前面提到的
<code>MERGE</code> 语句无法实现部分归并。</p>
<h3 id="从已有属性归并节点">从已有属性归并节点</h3>
<p>以下命令从已有的 <code>LABEL1</code> 标签下的节点查找其节点属性
<code>p1</code> ，并归并出 <code>LABLE2</code>
标签的节点，新节点的属性视为 <code>p2</code> ，从而不重复创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n:LABEL1)</span><br><span class="line">MERGE (m:LABEL2&#123;p2:n.p1&#125;)</span><br></pre></td></tr></table></figure>
<p>具体示例可查看官方手册的 <code>MERGE</code>
章节，举个简单的例子假设图数据库中已有几名学生的信息作为节点，学生的信息包括其籍贯，通过上面的命令即将学生视为标签
<code>LABEL1</code>，籍贯视为属性
<code>p1</code>，并将籍贯形成新的节点标签
<code>LABEL2</code>，以上命令就相当于不重复地列出学生的籍贯并一一建立新节点，并为新籍贯节点创建的属性视为
<code>p2</code>
，如果图数据库中已有籍贯相同的节点，则不会再被创建，保证了唯一性。这在从已有数据分离出一些较小的数据项时很有用。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><p><a href="https://neo4j.com/docs/cypher-manual/3.5/">The Neo4j
Cypher Manual v3.5</a></p></li>
<li><p>《 Neo4j 权威指南》</p></li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>Neo4j</tag>
        <tag>Cypher</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX-常用数学符号</title>
    <url>/LaTeX-common-math-symbol-equation/</url>
    <content><![CDATA[<p>本文整理 LaTeX 中常用的数学符号及一些数学元素的表达，以便查阅。</p>
<span id="more"></span>
<p>下列所有表示均在<strong>数学模式</strong>下。</p>
<p>更新：一个LaTeX 数学符号快速搜索工具：<a
href="https://latex.guide/">LaTeX Search: Find LaTeX commands</a></p>
<h1 id="数学符号">数学符号</h1>
<h2 id="希腊字母表">希腊字母表</h2>
<h3 id="小写字母">小写字母</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 19%" />
<col style="width: 19%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>希腊字母</th>
<th>符号表示</th>
<th>希腊字母</th>
<th>符号表示</th>
<th>希腊字母</th>
<th>符号表示</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\alpha\)</span></td>
<td><code>\alpha</code></td>
<td><span class="math inline">\(\iota\)</span></td>
<td><code>\iota</code></td>
<td><span class="math inline">\(\varrho\)</span></td>
<td><code>\varrho</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\beta\)</span></td>
<td><code>\beta</code></td>
<td><span class="math inline">\(\kappa\)</span></td>
<td><code>\kappa</code></td>
<td><span class="math inline">\(\sigma\)</span></td>
<td><code>\sigma</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\gamma\)</span></td>
<td><code>\gamma</code></td>
<td><span class="math inline">\(\lambda\)</span></td>
<td><code>\lambda</code></td>
<td><span class="math inline">\(\varsigma\)</span></td>
<td><code>\varsigma</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\delta\)</span></td>
<td><code>\delta</code></td>
<td><span class="math inline">\(\mu\)</span></td>
<td><code>\mu</code></td>
<td><span class="math inline">\(\tau\)</span></td>
<td><code>\tau</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\epsilon\)</span></td>
<td><code>\epsilon</code></td>
<td><span class="math inline">\(\nu\)</span></td>
<td><code>\nu</code></td>
<td><span class="math inline">\(\upsilon\)</span></td>
<td><code>\upsilon</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\varepsilon\)</span></td>
<td><code>\varepsilon</code></td>
<td><span class="math inline">\(\xi\)</span></td>
<td><code>\xi</code></td>
<td><span class="math inline">\(\phi\)</span></td>
<td><code>\phi</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\zeta\)</span></td>
<td><code>\zeta</code></td>
<td><span class="math inline">\(o\)</span></td>
<td><code>o</code></td>
<td><span class="math inline">\(\varphi\)</span></td>
<td><code>\varphi</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\eta\)</span></td>
<td><code>\eta</code></td>
<td><span class="math inline">\(\pi\)</span></td>
<td><code>\pi</code></td>
<td><span class="math inline">\(\chi\)</span></td>
<td><code>\chi</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\theta\)</span></td>
<td><code>\theta</code></td>
<td><span class="math inline">\(\varpi\)</span></td>
<td><code>\varpi</code></td>
<td><span class="math inline">\(\psi\)</span></td>
<td><code>\psi</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\vartheta\)</span></td>
<td><code>\vartheta</code></td>
<td><span class="math inline">\(\rho\)</span></td>
<td><code>\rho</code></td>
<td><span class="math inline">\(\omega\)</span></td>
<td><code>\omega</code></td>
</tr>
</tbody>
</table>
<h3 id="大写字母">大写字母</h3>
<p><em>注意</em>
：大写字母表示符号第一个字母需<strong>大写</strong>。</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th>希腊字母</th>
<th>符号表示</th>
<th>希腊字母</th>
<th>符号表示</th>
<th>希腊字母</th>
<th>符号表示</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\Gamma\)</span></td>
<td><code>\Gamma</code></td>
<td><span class="math inline">\(\Xi\)</span></td>
<td><code>\Xi</code></td>
<td><span class="math inline">\(\Phi\)</span></td>
<td><code>\Phi</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\Delta\)</span></td>
<td><code>\Delta</code></td>
<td><span class="math inline">\(\Pi\)</span></td>
<td><code>\Pi</code></td>
<td><span class="math inline">\(\Psi\)</span></td>
<td><code>\Psi</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\Theta\)</span></td>
<td><code>\Theta</code></td>
<td><span class="math inline">\(\Sigma\)</span></td>
<td><code>\Sigma</code></td>
<td><span class="math inline">\(\Omega\)</span></td>
<td><code>\Omega</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\Lambda\)</span></td>
<td><code>\Lambda</code></td>
<td><span class="math inline">\(\Upsilon\)</span></td>
<td><code>\Upsilon</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="运算符号">运算符号</h2>
<h3 id="二元关系符">二元关系符</h3>
<p>下列命令可加上<code>\not</code>命令，得到否定形式。</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 21%" />
<col style="width: 15%" />
<col style="width: 21%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(&lt;\)</span></td>
<td><code>&lt;</code></td>
<td><span class="math inline">\(&gt;\)</span></td>
<td><code>&gt;</code></td>
<td><span class="math inline">\(=\)</span></td>
<td><code>=</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\leq\)</span></td>
<td><code>\leq</code> or <code>\le</code></td>
<td><span class="math inline">\(\geq\)</span></td>
<td><code>\geq</code> or <code>\ge</code></td>
<td><span class="math inline">\(\equiv\)</span></td>
<td><code>\equiv</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\subset\)</span></td>
<td><code>\subset</code></td>
<td><span class="math inline">\(\supset\)</span></td>
<td><code>\supset</code></td>
<td><span class="math inline">\(\approx\)</span></td>
<td><code>\approx</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\subseteq\)</span></td>
<td><code>\subseteq</code></td>
<td><span class="math inline">\(\supseteq\)</span></td>
<td><code>\supseteq</code></td>
<td><span class="math inline">\(\sim\)</span></td>
<td><code>\sim</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\in\)</span></td>
<td><code>\in</code></td>
<td><span class="math inline">\(\cong\)</span></td>
<td><code>\cong</code></td>
<td><span class="math inline">\(\approx\)</span></td>
<td><code>\approx</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\propto\)</span></td>
<td><code>\propto</code></td>
<td><span class="math inline">\(\parallel\)</span></td>
<td><code>\parallel</code></td>
<td><span class="math inline">\(\perp\)</span></td>
<td><code>\prep</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\ll\)</span></td>
<td>·<code>\ll</code></td>
<td><span class="math inline">\(\gg\)</span></td>
<td><code>\gg</code></td>
<td><span class="math inline">\(\simeq\)</span></td>
<td><code>\simeq</code></td>
</tr>
</tbody>
</table>
<h3 id="二元运算符">二元运算符</h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 23%" />
<col style="width: 11%" />
<col style="width: 28%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\pm\)</span></td>
<td><code>\pm</code></td>
<td><span class="math inline">\(\mp\)</span></td>
<td><code>\mp</code></td>
<td><span class="math inline">\(\cdot\)</span></td>
<td><code>\cdot</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\times\)</span></td>
<td><code>\times</code></td>
<td><span class="math inline">\(\div\)</span></td>
<td><code>\div</code></td>
<td><span class="math inline">\(\odot\)</span></td>
<td><code>\odot</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\cup\)</span></td>
<td><code>\cup</code></td>
<td><span class="math inline">\(\cap\)</span></td>
<td><code>\cap</code></td>
<td><span class="math inline">\(\oplus\)</span></td>
<td><code>\oplus</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\lor\)</span></td>
<td><code>\vee</code> or <code>\lor</code></td>
<td><span class="math inline">\(\wedge\)</span></td>
<td><code>\wedge</code> or <code>\land</code></td>
<td><span class="math inline">\(\circ\)</span></td>
<td><code>\circ</code></td>
</tr>
</tbody>
</table>
<h3 id="积分">积分</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 19%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\int\)</span></td>
<td><code>\int</code></td>
<td><span class="math inline">\(\iint\)</span></td>
<td><code>\iint</code></td>
<td><span class="math inline">\(\iiint\)</span></td>
<td><code>\iiint</code></td>
</tr>
</tbody>
</table>
<h3 id="根号">根号</h3>
<p>根号命令为<code>\sqrt[a]&#123;x&#125;</code>，<span
class="math inline">\(a\)</span> 表示开根号的次数，<span
class="math inline">\(x\)</span> 为指数，<span
class="math inline">\(\sqrt[a]{x}\)</span>。</p>
<h3 id="上下标">上下标</h3>
<ul>
<li>上标：<span class="math inline">\(x^a\)</span>
用<code>x^a</code>产生，当指数超过一个字符时应使用大括号包含，如<code>x^&#123;abc&#125;</code>产生<span
class="math inline">\(x^{abc}\)</span>。</li>
<li>下标：<code>x_a</code>
用<code>x_a</code>产生，同样地，当下标超过一个字符时也应该用大括号包含。</li>
</ul>
<h3 id="分数">分数</h3>
<p>分数用<code>\frac&#123;a&#125;&#123;b&#125;</code>表示 <span
class="math inline">\(\frac{a}{b}\)</span> 。</p>
<h3 id="求和求积">求和，求积</h3>
<ul>
<li>求和：求和符号<span class="math inline">\(\sum\)</span>
用<code>\sum</code>表示，在行间公式中当上下标将被压缩表示为<span
class="math inline">\(\sum\_{i =
1}^n\)</span>，若希望产生类似于手写模式则应该加上<code>\limits</code>命令，如<code>\sum\limits\_&#123;i = 1&#125;&#123;n&#125;</code>表示
<span class="math inline">\(\sum\limits\_{i = 1}^{n}\)</span> 。</li>
<li>求积：求积符号<span class="math inline">\(\prod\)</span>
用<code>\prod</code>表示，上下标规则与求和符号相同。</li>
</ul>
<h3 id="偏导">偏导</h3>
<p>偏导符号<span
class="math inline">\(\partial\)</span>用<code>\partial</code>表示。</p>
<h2 id="其他符号">其他符号</h2>
<h3 id="箭头">箭头</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\leftarrow\)</span></td>
<td><code>\leftarrow</code></td>
<td><span class="math inline">\(\rightarrow\)</span></td>
<td><code>\rightarrow</code></td>
<td><span class="math inline">\(\leftrightarrow\)</span></td>
<td><code>\leftrightarrow</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\Leftarrow\)</span></td>
<td><code>\Leftarrow</code></td>
<td><span class="math inline">\(\Rightarrow\)</span></td>
<td><code>\Rightarrow</code></td>
<td><span class="math inline">\(\Leftrightarrow\)</span></td>
<td><code>\Leftrightarrow</code></td>
</tr>
</tbody>
</table>
<h3 id="注音">注音</h3>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\bar{x}\)</span></td>
<td><code>\bar&#123;x&#125;</code></td>
<td><span class="math inline">\(\vec{x}\)</span></td>
<td><code>\vec&#123;x&#125;</code></td>
<td><span class="math inline">\(\hat{x}\)</span></td>
<td><code>\hat&#123;x&#125;</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\dot{x}\)</span></td>
<td><code>\dot&#123;x&#125;</code></td>
<td><span class="math inline">\(\mathring{x}\)</span></td>
<td><code>\mathring&#123;x&#125;</code></td>
<td><span class="math inline">\(\tilde{x}\)</span></td>
<td><code>\tilde&#123;x&#125;</code></td>
</tr>
</tbody>
</table>
<h3 id="省略号">省略号</h3>
<ul>
<li>下标省略号 ： <span class="math inline">\(x_1, x_2, \dots,
x_n\)</span>用<code>\dots</code>表示；</li>
<li>中间省略号： <span class="math inline">\(1, 2, \cdots, n\)</span>
用<code>\cdots</code>表示；</li>
<li>纵向省略号：<span class="math inline">\(\vdots\)</span>
用<code>\vdots</code>表示；</li>
<li>斜向省略号：<span class="math inline">\(\ddots\)</span>
用<code>\ddots</code>表示。</li>
</ul>
<h3 id="数学粗体表示">数学粗体表示</h3>
<p>使用<code>\mathbf</code>命令：<span
class="math inline">\(\mathbf{R}\)</span> 由 <code>\mathbf&#123;R&#125;</code>
生成。</p>
<h3 id="其他符号-1">其他符号</h3>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 12%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="header">
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\lfloor\)</span></td>
<td><code>\lfloor</code></td>
<td><span class="math inline">\(\rfloor\)</span></td>
<td><code>\rfloor</code></td>
<td><span class="math inline">\(\exists\)</span></td>
<td><code>\exists</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\lceil\)</span></td>
<td><code>\lceil</code></td>
<td><span class="math inline">\(\rceil\)</span></td>
<td><code>\rceil</code></td>
<td><span class="math inline">\(\infty\)</span></td>
<td><code>\infty</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\hbar\)</span></td>
<td><code>\hbar</code></td>
<td><span class="math inline">\(\angle\)</span></td>
<td><code>\angle</code></td>
<td><span class="math inline">\(\forall\)</span></td>
<td><code>\forall</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\because\)</span></td>
<td><code>\because</code></td>
<td><span class="math inline">\(\therefore\)</span></td>
<td><code>\therefore</code></td>
<td><span class="math inline">\(\neg\)</span></td>
<td><code>\neg</code> or <code>\lnot</code></td>
</tr>
</tbody>
</table>
<h1 id="矩阵">矩阵</h1>
<p>使用 <code>\array</code>环境生成矩阵</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;array&#125;[外部对齐]&#123;列对齐&#125;</span><br><span class="line">    行列内容</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>外部对齐参数：整个矩阵和周围对象的纵向关系：
<ul>
<li>居顶：<code>t</code></li>
<li>居中（缺省）：<code>c</code></li>
<li>居底：<code>b</code></li>
</ul></li>
<li>列对齐参数
<ul>
<li>居左：<code>l</code></li>
<li>居中：<code>c</code></li>
<li>居右：<code>r</code></li>
</ul></li>
<li>换行：<code>\\</code></li>
<li>列分隔：<code>&amp;</code></li>
</ul>
<p>示例： <span class="math display">\[
\begin{array}{ccc}
    x_1    &amp; x_2    &amp; \cdots \\
    x_3    &amp; x_4    &amp; \cdots \\
    \vdots &amp; \vdots &amp; \ddots \\
\end{array}
\]</span></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;ccc&#125;    </span><br><span class="line">    x<span class="built_in">_</span>1    <span class="built_in">&amp;</span> x<span class="built_in">_</span>2    <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="keyword">\\</span>    </span><br><span class="line">    x<span class="built_in">_</span>3    <span class="built_in">&amp;</span> x<span class="built_in">_</span>4    <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="keyword">\\</span>    </span><br><span class="line">    <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure>
<p>(分隔符对齐非必要，仅出于个人使用习惯）</p>
<p>使用<code>array</code>环境产生的矩阵没有旁边的各种分隔符，可以用以下环境替代产生分隔符：</p>
<p><span class="math display">\[
\begin{pmatrix}
       a &amp; b \\\\
       c &amp; d
\end{pmatrix}
\]</span></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">  a <span class="built_in">&amp;</span> b <span class="keyword">\\</span></span><br><span class="line">  c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{vmatrix}
  a &amp; b \\\\
  c &amp; d
\end{vmatrix}
\]</span></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">  a <span class="built_in">&amp;</span> b <span class="keyword">\\</span></span><br><span class="line">  c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分段函数">分段函数</h1>
<p>使用
<code>\cases</code>环境可以生成分段函数，同样可以用于方程组。</p>
<p>示例： <span class="math display">\[
y=
\begin{cases}
    -x, \quad x\leq 0 \\\\
    x, \quad x &gt; 0
\end{cases}
\]</span></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">y= <span class="comment">% 换行是非必要的</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">    -x, <span class="keyword">\quad</span> x<span class="keyword">\leq</span> 0 <span class="keyword">\\</span></span><br><span class="line">    x, <span class="keyword">\quad</span> x &gt; 0</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="http://www.ptep-online.com/ctan/lshort_chinese.pdf">一份不太简短的LATEX2ε介绍(PDF)</a></li>
<li><a href="http://dralpha.altervista.org/zh/tech/lnotes2.pdf">LATEX
Notes雷太赫排版系统简介第二版v2.03 (PDF)</a></li>
<li><a
href="http://mirrors.huaweicloud.com/repository/toolkit/CTAN/info/symbols/comprehensive/symbols-a4.pdf">The
Comprehensive LATEX Symbol List (PDF)</a></li>
</ul>
]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX-使用Mcmthesis模板写作美赛论文</title>
    <url>/LaTex-use-mcmthesis-write/</url>
    <content><![CDATA[<p>本文总结了使用mcmthesis的方法，以及一些美赛时可能用到的表格，图片等环境。本文并不能作为LaTex的学习教程。</p>
<span id="more"></span>
<h1 id="论文基本设置">论文基本设置</h1>
<p>在<code>mcmthesis</code>中设置了<code>\mcmsetup</code>来调整基本选项，通过这些选项设置队伍的相关信息，论文中的标题，摘要等。如果想要调整模板的一些参数设置，或者是摘要页的格式，可以通过修改<code>mcmthesis.cls</code>文件进行修改，也就是调整模板格式
。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;</span><br><span class="line">          tcn = 12345,</span><br><span class="line">          problem = B,</span><br><span class="line">          sheet = true,</span><br><span class="line">          titleinsheet = true,</span><br><span class="line">          keywordsinsheet = false,</span><br><span class="line">          titlepage = false,</span><br><span class="line">          abstract = true</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<h2 id="队伍控制号">队伍控制号</h2>
<p>在成功注册缴费报名后，每个队伍会得到一个控制号（Team Control
Number），根据美赛的规则，控制号必须在摘要页以及之后的论文的页眉中出现，这点模板中已经设置好了，我们只需要改为自己队伍的控制号即可，即将<code>tcn</code>的值改为本队控制号，例如12345（默认值为0000）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;tcn = 12345&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选题">选题</h2>
<p>在比赛开始后，将一共发布6道题，队伍只能选择一道题作答，并将该题编号写于摘要页上。我们只需要改动<code>problem</code>的值为本队选择的问题即可，例如B题（默认值为A）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;probelm = B&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摘要页">摘要页</h2>
<p><code>mcmthesis</code>模板中生成了摘要页，队伍可以选择使用此摘要页，或者选择学校提供的摘要页或者官网提供的Word摘要页，关闭此摘要页（默认值为<code>true</code>，即开启）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;sheet = true&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摘要页中的标题">摘要页中的标题</h2>
<p>如果希望在摘要页中显示文章标题，将<code>titleinsheet</code>的值设置为<code>true</code>（默认值为<code>false</code>）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;titleinsheet = true&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摘要页中的关键词">摘要页中的关键词</h2>
<p>如果希望在摘要页中显示关键词，将<code>keywordsinsheet</code>的值设置为<code>true</code>（默认值为<code>false</code>）。如果不显示关键词，请记得也把摘要中的<code>\begin&#123;keywords&#125;...\end&#123;keywords&#125;</code>去掉或修改注释掉。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;keywordsinsheet = false&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标题页">标题页</h2>
<p>如果希望在摘要后显示LaTex标准的标题页，将<code>titlepage</code>的值设置为<code>true</code>（默认值为<code>true</code>）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;titlepage = false&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标题页的摘要">标题页的摘要</h2>
<p>如果在上一项<code>titlepage</code>的值设置为<code>true</code>，将此选项<code>abstract</code>的值设置为<code>true</code>，将在标题页中显示摘要，也就是在前面的摘要页之后再一次显示摘要，摘要会被放在标题页中，如果<code>titlepage</code>值设置为<code>false</code>，则此处就无影响（默认值为<code>true</code>）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;abstract = true&#125;</span><br></pre></td></tr></table></figure>
<h1 id="美赛写作常用">美赛写作常用</h1>
<p>以下将整理一些在美赛中常用的设置，环境，调用等等。</p>
<h2 id="段落缩进">段落缩进</h2>
<p><code>mcmthesis</code>模板中的段落缩进与LaTex中一样，首段默认不缩进，其他段落缩进，通过资料搜寻，发现这似乎是一个英文习惯，所以首段不缩进的问题不大。可以通过<code>\usepackage&#123;identfirst&#125;</code>解决，本人调用宏包失败尚未解决这个问题。如果觉得有的缩进有的不缩进显得混乱，可以通过<code>\setlength&#123;\parindent&#125;&#123;0pt&#125;</code>设置缩进为0。</p>
<h2 id="插入图片figure">插入图片（Figure）</h2>
<p>在文中常常需要插入图片，图片的标题应该在图片下方，<code>mcmthesis</code>模板中提供了一个参考格式如下：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line">    <span class="keyword">\small</span></span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=12cm]&#123;a.eps&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;a&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;fig:Figure 1&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p>htbp选项表示由LaTex决定插图位置，即这里，页顶，页底，浮动。
<code>\centring</code>表示居中，<code>\label&#123;&#125;</code>应该在<code>\caption</code>之后。图片格式可以通过
<a href="http://www.tlhiv.org/rast2vec/">Convert PNG/JPEG(Raster) to
EPS/PDF(Vector) Format</a>
转化为<code>*.eps</code>,<code>*.pdf</code>格式，放置于<code>figure</code>文件夹中，并且<code>*.pdf</code>的命名格式有一定的要求，如图片为<code>a.eps</code>，则PDF文件应该命名为<code>a-eps-converted-to.pdf</code>。</p>
<h2 id="列表">列表</h2>
<p>简单的列表样式通常用于列举assumptions，方程、公式等的参数</p>
<h3 id="无序列表">无序列表</h3>
<p>无序列表各项前的符号默认为实心小圆点，可以通过改变<code>\item[]</code>参数来修改符号。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">  <span class="keyword">\item</span></span><br><span class="line">  <span class="keyword">\item</span>[-]</span><br><span class="line">  <span class="keyword">\item</span>[*]</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有序列表">有序列表</h3>
<p>参数同样可以改变。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line">  <span class="keyword">\item</span></span><br><span class="line">  <span class="keyword">\item</span></span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表格table">表格（Table）</h2>
<p>常用于列举notations，以及各种参数，表格的标题应该在表格上方，下面是一个简单的示例：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;table&#125;[htbp]</span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\caption</span>&#123;Notations&#125;</span><br><span class="line"><span class="keyword">\label</span>&#123;tab:Table 1&#125;</span><br><span class="line">  <span class="keyword">\begin</span>&#123;tabular&#125;&#123;c|l&#125;</span><br><span class="line">    <span class="keyword">\toprule</span></span><br><span class="line">    Symbol <span class="built_in">&amp;</span> Description<span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\midrule</span></span><br><span class="line">    <span class="built_in">$</span>W/L<span class="built_in">$</span> <span class="built_in">&amp;</span> width  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\hline</span></span><br><span class="line">    <span class="built_in">$</span>A<span class="built_in">$</span>   <span class="built_in">&amp;</span> area <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\bottomrule</span></span><br><span class="line">  <span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;table&#125;</span><br></pre></td></tr></table></figure>
<p>参数设置与图片浮动Figure环境类似。<code>\hline</code>表示横线，<code>\toprule</code>,<code>\bottomrule</code>可以使顶部和底部的线与中间的线<code>\midrule</code>区分开来。<code>|</code>表示竖线，每列的横向对齐方式通过<code>l</code>,<code>c</code>,<code>r</code>控制，分别表示左对齐
，居中，右对齐。<code>\\</code>用于换行，也就是分行，<code>&amp;</code>用于分列。</p>
<h2 id="数学">数学</h2>
<h3 id="公式">公式</h3>
<p>带序号的行间公式，可以在equation后加上*不带序号。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方程组">方程组</h3>
<p>可以使用方程和数组的结合，参考如下：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">  <span class="keyword">\left</span><span class="keyword">\&#123;</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;array&#125;&#123;lll&#125;</span><br><span class="line">    <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> T&#125;&#123;<span class="keyword">\partial</span> n&#125;=0<span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\\</span></span><br><span class="line">    T = a</span><br><span class="line">  <span class="keyword">\\</span></span><br><span class="line">    T<span class="built_in">_</span>0=25</span><br><span class="line">  <span class="keyword">\end</span>&#123;array&#125;<span class="keyword">\right</span>.</span><br><span class="line">  <span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多行公式等号对齐">多行公式等号对齐</h3>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">    <span class="keyword">\eta</span><span class="built_in">_</span>1 <span class="built_in">&amp;</span>= <span class="keyword">\frac</span>&#123;S<span class="built_in">_</span>1&#125;&#123;A&#125;</span><br><span class="line">    <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\eta</span><span class="built_in">_</span>2 <span class="built_in">&amp;</span>= <span class="keyword">\frac</span>&#123;N <span class="keyword">\times</span> A&#125;&#123;S<span class="built_in">_</span>&#123;Total&#125;&#125;</span><br><span class="line">    <span class="keyword">\\</span></span><br><span class="line">         Z <span class="built_in">&amp;</span>= p <span class="keyword">\eta</span><span class="built_in">_</span>3 + (1-p)<span class="keyword">\eta</span><span class="built_in">_</span>4</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>
<p>更多常用数学符号的整理传送门：<a href="https://fish-404.github.io/LaTeX-common-math-symbol-equation/">LaTeX
- 常用数学符号 | 在逃的貓</a></p>
<p>LaTeX 数学符号快速搜索：<a href="https://latex.guide/">LaTeX Search:
Find LaTeX commands</a></p>
<h2 id="参考文献的书写">参考文献的书写</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line">  <span class="keyword">\bibitem</span>&#123;1&#125;Wikipedia. 2018. Thermal Conduction. <span class="keyword">\url</span>&#123;<span class="link">https://en.wikipedia.org/wiki/Thermal_conduction</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">\bibitem</span>&#123;2&#125;Name. Article(in Chinese). <span class="keyword">\emph</span>&#123;Magazine&#125;, year, number: page. <span class="keyword">\url</span>&#123;<span class="link">site</span>&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>99表示允许的最大条目数。在文章中可以使用<code>\cite&#123;&#125;</code>对<code>\bibitem</code>中编号了的参考文献进行引用。</p>
<h2 id="强调">强调</h2>
<p><code>\emph</code>用于强调，通常会变为斜体
<code>\textbf&#123;&#125;</code>用于字体加粗</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><p><a href="https://liam0205.me/2016/01/27/how-to-use-mcmthesis/">如何使用美赛模板mcmthesis|始终</a></p></li>
<li><p><a href="http://www.ptep-online.com/ctan/lshort_chinese.pdf">一份不太简短的LATEX2ε介绍(PDF)</a></p></li>
<li><p><a href="http://dralpha.altervista.org/zh/tech/lnotes2.pdf">LATEX
Notes雷太赫排版系统简介第二版v2.03(PDF)</a></p></li>
</ul>
]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>Mathematical modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-在移动硬盘上安装Arch Linux</title>
    <url>/Linux-Install-archlinux-harddisk/</url>
    <content><![CDATA[<p>记录在移动硬盘上安装Arch Linux的过程。一部分用作Arch
Linux，另一部分则用于日常存储。</p>
<span id="more"></span>
<h1 id="安装背景">安装背景</h1>
<p>在2017年暑期接触到Linux，接触得并不太多，也只是装了个虚拟机VM
ware，在虚拟机上使用过Ubuntu和CentOS，后来很长一段时间没怎么玩。最近入手了一块移动硬盘，Win
10用得总是崩溃，又想捣鼓一下Linux玩玩，电脑的配置并不高，也不想再重新分区，所以并没有装双系统，于是就想着是不是可以在移动硬盘上面装一个Linux，周围的伙伴推荐过Arch
Linux，再加上Arch
Linux的Wiki非常详细，大多数的东西都能在官方Wiki上面找到，于是决定进行尝试。</p>
<h1 id="安装准备">安装准备</h1>
<p>采用MBR+BIOS引导启动，通过<a href="https://virtualbox.org">Virtual
Box</a>引导Arch 的
ISO，将移动硬盘连接到虚拟机进行安装。在使用前我删除了移动硬盘上的所有分区，移动硬盘处于未分配状态，分区操作将在后文提及。（也可以选择使用<a href="https://www.disktool.cn/">分区助手</a>将GPT格式分区修改为MBR分区方式，以及格式化和分区。）</p>
<h2 id="新建虚拟机">新建虚拟机</h2>
<p>在Virtual
Box上新建一个虚拟机，不设置虚拟磁盘。需要注意的是在虚拟机的设置中需要启用USB设置项，选择“启用USB控制器”，选择USB
3.0(xHCI)控制器。此选项需要安装<a href="https://virtualbox.org/wiki/Downloads">VirtualBox
Extension
Pack</a>，下载完扩展包后，在VirtualBox的全局设定中的扩展选项卡将此扩展包加入，才可以正常使用USB3.0控制器。</p>
<p><strong>加载Arch Linux
ISO文件时，记得在顶部的菜单栏选择USB设备！</strong></p>
<h2 id="分区格式化挂载">分区，格式化，挂载</h2>
<h3 id="分区">分区</h3>
<p>运行分区工具： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfdisk</span><br></pre></td></tr></table></figure>
如果移动硬盘中并不存在分区，则将会出现一个选择菜单"Select label
type"，这里我们选择<code>dos</code>，这将会使用MBR方式对硬盘进行分区。之后将显示整个移动硬盘的分区状态，当前显示为<code>Free Space</code>，对此进行分区，根据提示输入分区大小，创建分区后，需要选择<code>Write</code>将分区写入，忽略<code>Write</code>操作分区将并不会被修改，根据自己的需要进行分区。我创建了两个分区用于<code>root</code>，和<code>home</code>，这两个分区的类型为<code>83 Linux</code>，一个分区用于<code>swap</code>，分区类型为<code>82 Linux swap / Solaris</code>，剩下的作为日常存储使用，当然这里我也根据需要进行了一定的分区，分区类型均为<code>7 HPFS/NTFS/exFAT</code>。</p>
<p>分区完成后可以使用以下命令查看分区情况： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure> 或者使用命令：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure> ### 格式化 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda1</span><br></pre></td></tr></table></figure> ### 设置卷标 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">e2label /dev/sda1 <span class="built_in">arch</span></span><br></pre></td></tr></table></figure> ###
挂载分区，启用swap <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/sda1 /mnt</span><br><span class="line"><span class="built_in">mkdir</span> /mnt/home</span><br><span class="line">mount /dev/sda2 /mnt/home</span><br><span class="line">mkswap /dev/sda3</span><br><span class="line">swapon /dev/sda3</span><br></pre></td></tr></table></figure></p>
<h1 id="安装">安装</h1>
<h2 id="检查网络连接">检查网络连接</h2>
<p>检查网络连接是否正常（此时机器应该时自动连接到网络的），可以使用<code>ping</code>验证连接是否正常：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping -c 3 archlinux.org</span><br></pre></td></tr></table></figure> ## 选择镜像源
修改<code>/etc/pacman.d/mirrorlist</code>文件， <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>
关于vim的操作，此处不做介绍。
此文件定义了软件包会从哪个镜像源下载，在列表中越前的镜像在下载软件包时有越高的优先权。可以加入以下两个镜像：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 中科大的</span></span></span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 阿里云的</span></span></span><br><span class="line">Server = https://mirrors.aliyun.com/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure> ## 安装基本系统
使用<code>pacstrap</code>脚本，安装<code>base</code>组，和<code>base-devel</code>软件包组，也可以之后再安装：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pasctrap -i /mnt base base-devel</span><br></pre></td></tr></table></figure></p>
<h1 id="配置系统">配置系统</h1>
<h2 id="fstab">Fstab</h2>
<p>生成<code>fstab</code>文件，该文件用于定义磁盘分区，其他块设备和远程文件系统如何装入文件系统，<code>-U</code>选项设置使用UUID：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure> 根据 Arch Wiki 的建议，
最好检查一下<code>fstab</code>文件是否正确： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /mnt/etc/fstab</span><br></pre></td></tr></table></figure> ## Chroot
Change root 到新系统 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure> ## 时区 设置时区： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure> ##
本地化 (这里vim可能尚未安装，使用<code>pacman -S vim</code>进行安装）
在<code>/etc/locale.gen</code>文件中修改需要的本地化类型，移除掉对应行前的注释号即可:
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure>
执行<code>locale-gen</code>生成locale讯息，使<code>/etc/locale.ben</code>生成指定的本地化文件：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure> 创建<code>locale.conf</code>并编辑<code>LANG</code>变量：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.conf</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LANG = en_US.UTF-8</span><br></pre></td></tr></table></figure> ## 设置主机名 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> myhostname &gt; /etc/hostname</span><br></pre></td></tr></table></figure> ##
设置root密码 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure> ## 添加普通用户 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m newuser</span><br><span class="line">passwd newuser</span><br></pre></td></tr></table></figure> 修改权限：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root ALL=(ALL)ALL</span><br><span class="line">newuser ALL=(ALL)ALL</span><br></pre></td></tr></table></figure> ## 安装Grub <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S grub</span><br><span class="line">grub-install --recheck /dev/sda</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure> ##
退出Chroot环境并卸载分区，关闭虚拟机 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">umount /mnt/home</span><br><span class="line">umount /mnt</span><br><span class="line">power off</span><br></pre></td></tr></table></figure></p>
<p>系统安装完成~ 重启，通过BIOS启动菜单直接进入移动硬盘即可进入Arch
Linux~ # 参考资料 *
<a href="https://wiki.archlinux.org/index.php/Installation_guide">Installation
guide - ArchWiki</a> *
<a href="https://blog.contabo.com/tutorials/mounting-additional-hard-disks-linux/">Mounting
of additional hard disks in Linux | Official Blog - Contabo.com</a> *
<a href="https://wiki.archlinux.org/index.php/Partitioning">Partitioning
=ArchWiki</a> *
<a href="https://wiki.archlinux.org/index.php/Fstab">fstab -
ArchWiki</a> *
<a href="https://wiki.archlinux.org/index.php/Microcode">Microcode -
ArchWiki</a> * <a href="https://wiki.archlinux.org/index.php/GRUB">GRUB
- ArchWiki</a> *
<a href="https://www.cnblogs.com/tsdxdx/p/7215416.html">Arch Linux
安装记（安装到移动硬盘）- 天下掉下的X - 博客园</a> *
<a href="https://www.jianshu.com/p/a1c10e6c9eba">arch
linux安装到移动介质-简书</a> *
<a href="http://smilejay.com/2012/06/swap_size/">交换分区(SWAP)的大小分配-笑遍世界</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Arch Linux</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 偏好设置</title>
    <url>/MATLAB-matlab-preference-settings/</url>
    <content><![CDATA[<ul>
<li>语言设置</li>
<li>修改暗色主题</li>
</ul>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATLAB版本:R2014a</span><br><span class="line">操作系统：Windows 10</span><br></pre></td></tr></table></figure>
<h1 id="语言设置">语言设置</h1>
<p>在默认语言为中文的操作系统下安装和使用MATLAB，界面语言默认为中文，而并不是全部汉化，使用这样的专业软件习惯了英文界面，发现在预设里面并没有语言设置的选项，本文记录设置为英文的方法。</p>
<h2 id="设置步骤">设置步骤</h2>
<ol type="1">
<li>打开“系统设置”窗口：
控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置；</li>
<li>单击右下角“环境变量(N)...”，弹出“环境变量”设置窗口；</li>
<li>在“系统变量(S)”窗口下方单击“新建(W)...”弹出“新建系统变量”窗口；</li>
<li>在“变量名(N)”一栏填入<code>MWLOCALE_TRANSLATED</code>；</li>
<li>在“变量值(V)”一栏填入<code>OFF</code>（若要恢复中文设置，只需要改变这个值为<code>ON</code>即可）。</li>
</ol>
<h1 id="修改为暗色主题">修改为暗色主题</h1>
<ol type="1">
<li>在命令行窗口输入命令<code>prefdir</code>查看预设文件所在路径；</li>
<li>在路径中找到文件<code>matlab.prf</code>将其中的内容进行替换，在https://github.com/scottclowe/matlab-schemer/tree/master/schemes中可以找到一些配色方案。</li>
</ol>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a herf="https://cn.mathworks.com/matlabcentral/answers/129813-matlab-8-3-r2014a?s_tid=gn_loc_drophttps://cn.mathworks.com/matlabcentral/answers/129813-matlab-8-3-r2014a?s_tid=gn_loc_drop">在中文操作系统中，如何将中文版MATLAB
8.3(R2014a)转换为英文版？</a></li>
<li><a href = "https://ww2.mathworks.cn/help/matlab/ref/prefdir.html">包含预设项、设置、历史记录和布局文件的文件夹
- MATLAB prefdir - MathWorks 中国</a></li>
</ul>
]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>影评-他们揍你是因为你很独特</title>
    <url>/Movie-Imitation-Game/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">电影名称：   模仿游戏(2014)(The Imitation Game)</span><br><span class="line">导演：       莫腾·泰杜姆</span><br><span class="line">编剧：       格拉汉姆·摩尔 Andrew Hodges</span><br><span class="line">发行公司：   韦恩斯坦国际影业公司</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>大概在高中的时候在某素材书上看到关于图灵的介绍。作为一个从小就对稀奇古怪的神秘的理工科世界感兴趣的顽童，自然对图灵也是满怀敬意。朋友曾经向我力荐《模仿游戏》这部电影，听着她的讲述，看着她的痴迷，我倒也有心想要看看，却总是拖延，直到前几天才看完这部电影，作为一个密码爱好者和工科生，对这部电影有种本能的亲切感。</p>
<p>影片的开始，饰演图灵的康伯巴奇就把图灵对自己在数学领域的自信展现的淋漓尽致，虽然看起来有些恃才傲物，但偏偏编剧又让图灵为自己的天才不足而留下了台词，那种感觉就像是我们学生时代拿到了几乎满分的成绩还抱怨因为字迹潦草而扣分的狂妄，但放之于图灵，搭上康伯巴奇的演绎，你会觉得这一切都是那么理所当然。影片始终都有一条离不开的主线，那便是图灵深爱着的克里斯托弗。从在年少时的相逢，同为天才的克里斯托弗对图灵的关照，以及对图灵在密码学的启迪，在未及将爱说出口，便从校长口中得知亲爱的朋友，甚至于已成为自己脑海中的爱人已经不在。在那个时代，同性恋被视为犯罪，其实就算是在今天，在此刻，在我所处在的这方土地，对同性恋的包容也仍然让人揪心，那个图灵强憋着眼泪，倔强地不敢承认和克里斯托弗的关系，那个镜头，让人心疼。从两人的相遇开始，克里斯托弗就一直是图灵的精神支柱，甚至于他不在时，也是，影片中图灵将自己所设计和制造用于破译恩尼格玛的机器命名为克里斯托弗，一直陪伴着他，虽然在真实的历史中，图灵机并不为此名，但我们可以当作是图灵机的别名嘛，毕竟在同性恋有罪的当时，如此正大光明地取名也太招摇了吧。但是，伟大的天才却因同性恋而终究早逝，世界因他而走入计算机的现代世界，却抛弃了他。</p>
<p>整部影片对于恩尼格玛的破译过程并没有太多的描述，反而着手于人物的心理冲突和碰撞，这也许也让影片有了更强的可观赏性，毕竟抽象的密码破译和机器原理并不是打动人的主体，但作为一个工科生，还是会有一种肃然起敬的本能，想自己为了完成课程设计就已经是头疼不已，深知开创这样一台机器是多么浩大的工程，零件的组合，机器运转的逻辑，都并非一朝一夕之事，而图灵的创举实在是将世界带入了计算机时代。从图灵开始接手破译小组那时，直至最后整个小组顺利完成任务，帮助二战盟军破译了不可计数的情报，整个过程其实不光是康伯巴奇饰演的图灵，整个破译小组的成员也有不少闪光的小细节。尤其是整个小组成员唯一一位女性克拉克，从解决报上的填字游戏，笔试迟到，到得知自己的工作后想要遵循保守的社会规矩而放弃，被图灵说服，成为小组成员，鼓励图灵，也帮助图灵走出了完全不善交际的处境，使得整个小组都融洽了许多。从开始时每个小组成员完全不服图灵捣鼓图灵机，到图灵机构造完成，却因为庞大的计算量始终得不到正确结果，始终无法破译恩尼格玛，所有的小组成员一致站出来以辞职相逼维护了图灵，也保住了图灵机，不能不说是克拉克的功劳。当然不难看出克拉克是喜欢图灵的，从她的告白，接纳图灵的古怪任性，到图灵毅然道出真相，其实图灵对于克拉克也有着心动吧，只是心里已经住了一个人。人的心很大，可以装下世界的密码，人的心却也很小，只住得下一个心爱的人。一直到最后破译工作完成，小组解散，那时，这群天才在火光中将自己这数年来冥思苦想的所有手稿销毁，改变历史的他们，停留在那簇火光的朦胧里，不被人知。历史上，又有多少这样的故事尘封在各个国家常年封锁的档案馆里呢。而那个克拉克时隔多年与图灵相见的场景，让人泪目。“因为你的不平凡，世界才变得更加美好。”可是，世界终究却不以善意待他。</p>
<p>有机会找找原作《阿兰·图灵传》，也许才能更加了解这位天才。毕竟破译恩格玛也只是图灵一生中的一部分，向天才致敬。</p>
<blockquote>
<ol type="1">
<li>-They only beat me up because I'm smatter than they are. -No, they
beat you up because you're different. -他们揍我只是因为我比他们聪明。
-不是，他们揍你是因为你很独特。</li>
<li>-Alan, you do not have to do this alone. -I'm not alone. Never have
been. -艾伦，你不要一个人承受。 -我不是一个人，从未。</li>
<li>Sometimes it's the very people who no one imagines anything of who
do the things no one can imagine.
有时候，正是那些人们认为的无用之人成就了无人所成之事。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>影视相关</category>
      </categories>
      <tags>
        <tag>Movie</tag>
      </tags>
  </entry>
  <entry>
    <title>燃烧女子的肖像</title>
    <url>/Movie-Potrait-de-la-jeune-fille-en-feu/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">影片名称：燃烧女子的肖像</span><br><span class="line">导演: 瑟琳·席安玛</span><br><span class="line">编剧: 瑟琳·席安玛</span><br><span class="line">官方网站: http://www.portraiteinerjungenfrauinflammen.de/</span><br></pre></td></tr></table></figure>
<p>非影评，应该算是以画家视角写的改编？不知道该算什么，叫什么都行，暂且归入影评分类。很喜欢这部影片，就写了，不如电影细腻，难免加入自己的解读，第一次写这种文章，可能也会是最后一次。为了避免影响观影体验，请观后再阅。对话来自影片字幕，版本为Fix字幕组。</p>
<span id="more"></span>
<p>瞥到学生身后的画，忽然失神。</p>
<blockquote>
<p>- 那是您画的吗？ - 是的。很久以前画的。 - 这幅画叫什么？ -
燃烧女子的肖像</p>
</blockquote>
<p>学生小心翼翼地问，我心神不宁地答。</p>
<p>你裙底的火，身后的光，带我回到那时过往。</p>
<p>接到画像的邀请，我只身前往。即便来前早有耳闻，也不知如此偏僻。水路途中掉了画具，湿淋淋地到了你家，赤裸着在炉前烤火时，并未觉得会有什么波折。到你家的第一天，只见到了家中的女仆苏菲。她问我，能做到吗？我一愣，这才听说了你姐姐的变故，听说了上一位画家没能画完肖像的故事
。我收拾好房间，看到墙边的画架，翻转画板，看到一幅画像，画中人身着华服，面部却被涂抹。我倒退几步，心里一惊，不知道会经历什么。</p>
<p>第二天，苏菲拿出那条藻绿盛装，说起你一直穿着修道院的衣服，并无更多画像选择。你的母亲告诉我，你不满这桩亲事，对肖像画百般抗拒，求我陪你出门，一路观察，完成画像。我答应了下来，联想到房间里毁掉的画像，虽有些异常，但自觉并无大碍。她还带我到她的画像前，告诉我这是我父亲为她画的像，一直到她入了这家门才第一次见到，像是等着她的到来。而她，正是要我，为你画这样一幅肖像，把你送回她的故乡。</p>
<p>我回屋搭好画架，布好画具，苏菲前来唤我，说你已在等我。我拉上临时画室的帘子，也好奇见你。在楼梯上第一次见你，你穿着深色衣裙，连帽戴着，背对着我，急切地出门。听到我出来，你加快了步伐，我在身后紧跟。蓝斑点的连帽随着你的步伐而跳跃，像是林中起舞的蓝点紫斑蝶。帽子终于落下，看到你一头金发。你开始跑起来，向着海边，我担心你要效仿你的姐姐，提着裙子追赶，难以跟上。你停了下来，我松了口气，却听你说你期待已久，我不自觉地问出「一死了之？」话出口时觉得不妥又无可挽回，你转过头，坚定又愤怒地否定「肆意奔跑。」此刻我相信你并无寻死的念头。</p>
<p>这一天，你找我借书，我们一起上了楼。楼梯上，我默念着肖像画的技法，看各个角度的你。我迅速抽出书，生怕你发现帘后的秘密，好在你只站在门口，没有进来，你抛下一句「您睡在这，这可真奇怪。」那时你是否已经有所察觉？晚上，我在炉火前，摊开你的细节，是我日间抽空画下的小稿，我不确定是不是在那时候，我就有些心动了。</p>
<p>白天，我开始尝试着在画板上勾描你的轮廓。苏菲来唤我，我脱下作画时穿着的白袍，换上外套，她说起风了，为我戴上面纱。你的半张脸也埋在面纱后，总是走在我前面，在海边坐下的时候，你双手交叠，问我还能待多久。你兀地说想游泳，我不明白，劝你待天气转暖，你答应了。你于是在岸边徘徊，我躲进巨石后，拿出碳块描下你的双手。晚上苏菲问起画像的事，我回答并不顺利，我想不出怎样才能看到你脸上更丰富的表情，我尝试去画，下笔踟蹰。</p>
<p>看到你在岸边展开姐姐未完的刺绣，我问出你心中的疑惑。你吓了一跳，大概意外我这个外人竟敢如此发问。你告诉我姐姐的道歉，我发现你默认了从姐姐那里继承的命运是悲惨的，这也难怪，你说你对那个米兰人家知道的并不比我更多。我转移了话题，试着安慰你修道院也并非理想之地，尽管我甚至说服不了自己。我失言说出自己会画画，你这时一定已经坚信了我是来为你画像的吧。你问我何时结婚，我告诉你我可能不会结婚，你疑惑竟无人逼迫么？我欺骗你我可以接替父亲的事业，你随即愤怒地表示我无法理解你，我否认了，但没有用。</p>
<p>我画好了草稿，仅剩衣装。我穿上你的盛装，从小镜里看假扮模特的自己，想象你坐在那里的模样。你在门外唤我的名字，我慌忙跑进帘后，拉上帘子，脱下你的衣服，跑了出来，那时，我脸上大概挂着无法掩饰的慌张。你坐在我刚刚坐过的椅子上，看着我一动不动，然后又起身。你一定知道了吧。你问我借了烟，我们坐在沙发上，我告诉你明日你就可自由，你的母亲已允许你独自出门，你回答道：「自由就是独自一人吗?」我愣了神，找不到合适的答语。你说想去做弥撒，想听音乐，你似乎只听过修道院里献给死者的音乐，你希望我描述其他，我摇头。我走到大键琴前，摸索着琴键，按下一两个音符，你跟过来，移开琴上的防尘布，坐在我身旁。我一边弹着，一边描绘，可惜忘掉了些许片段，没能弹完，无意中说出你会在米兰听到的，你脸上缓和下的表情再次凝固，不悦地盯着我，认为我是为了减轻你的焦虑而频频提及。</p>
<p>我原计划离开的前一天，请苏菲穿上你的盛装，我想象着你坐在那里的样子，画像很快就要完工了。苏菲离开后，我继续作画，休息时听到你的脚步声，已来不及洗去颜料，我将右手背在身后，面向你，你走过我身边，我又将右手挪到身前，问你弥撒的事。我听到你邀请我明日一同出门，我没有理由拒绝，也不想拒绝，低声答应，又听见你说：「独自一人时，我感受到了你说的那种自由。」我释然，只听你又说：「但也感受到了我对您的思念。」我噙着泪，不敢再把头转向你，我想我是心动了。夜里我点着烛火，画完你的画像，但并不满意，尽管我并没有如实告诉你母亲。我请求她先让你看一眼，请求她让我把真相告诉你，我不想再欺骗你了。你的母亲告诉我你时常提起我。我无力地回到我的房间，点燃前一位画家留下的未完画像，烧毁了它。</p>
<p>最后一天，尽管是你提出的邀请，我们却相对无言。你只是坐在我身旁静静地看书，我想，你没有在读，你也不安。我轻声唤你，告诉你真相。你也许早就知道，但也许还是欺骗着自己相信，听到我亲口说出真相，仍很是愤怒。你走向岸边，只着一袭单衣，把自己抛入冰冷的水里，企图用肉体的寒冷去抵消无助。上岸后你裹着自己直哆嗦，却不肯直接回屋。</p>
<p>你仔细揣摩我的画，和我一样，你并不满意。也许从绘画技法上，它称得上是好作品。但你很清楚，那并不是你，不是我眼中的你，我也很清楚，尽管我并不想承认。最终我还是涂抹掉了你的画像，你的母亲感到被戏弄，赶我离开。你出言阻止，决定配合我，你是不是也想留下我眼中的你？母亲拗不过你，命令我在她离开的这几天内完成你的画像。你果然穿上盛装，配合起我来。</p>
<p>那天晚上，我来了月经，肚子很痛，苏菲为我烤了小石子好暖暖身子。她说往常总备着，但已三月不来。她看起来还很小，我有些担心。显然这是她第一次怀孕，而这并非她的意愿，打算趁你母亲不在的时候流掉。第二天我们让她在海边狂奔，和她一起在山野里找寻草药，想尽一切办法帮助她。许是看到我的举止，你问我是不是也曾经历，我肯定的回答让你有些意外，看起来你对我的愤怒不那么重了。你问我感受过爱的滋味吗？我看着你，你不知道，我心里的人，是你。你希望我描摹爱，我不能，除非我们相爱，我没有说。</p>
<p>我们把筋疲力尽的苏菲抱到沙发上，你也疲惫睡去。我借着烛光，描摹你睡着的容颜。你睡得不深，看到我在画你，脸上第一次露出毫无防备的微笑。我等它很久了。</p>
<p>我画好肖像画的面部，却找不到你的笑颜，大概因为见多了你的怒意。我没有直说，但你依然很受伤。你情绪激动，双手交叠；你咬了咬嘴唇，下意识地掩饰被我发现的不安；你一动不动，流露着你的恼怒。是的，我什么都知道，你的微表情我已牢记在心。只是，我没想到，我也是镜中人，我颔首扶额，无话可说；我难以自持，不禁皱眉；我局促不安，大口呼吸。我没想到，我也被你看穿了。我们终于扯下了彼此的面具。晚上三个人一起打牌时，我们都很开心，尤其是你，耍着小聪明，像孩子一样调皮又尽兴。后来你再当起模特时，也主动与我聊天了，你说，你对我感兴趣。</p>
<p>某个晚上，我们围坐炉火边，你读着《变形记》里《俄耳甫斯和欧律狄利的故事》这一则诗歌。苏菲不能理解回头的俄耳甫斯。你又读了一遍，苏菲还是不能原谅，而你说，他是「为爱痴狂，情不自禁」，那时，我同意苏菲的看法，认为俄耳甫斯是做出了选择，「不是以爱人的名义，而是以诗人的名义」。你没有再辩驳，接着读诗。你说，也许是欧律狄利说了「回头看看我」，我好像有些明白你的想法了，不安起来。</p>
<p>又一个晚上，我们前去参加当地女性的篝火会。女人们围在篝火旁，拍着手，反复吟唱一句歌词「我无法逃离」。我隔着火光里飘忽不定的空气看你，你几欲哭泣，好像这句词唱的是你，我也不安，这句词唱的其实不只是你，也是我，是我们，也是那些篝火旁的女人们。火星溅到你的裙角，燃了起来，你没有在意，仍看着我，我也竟没有上前去，仍看着你，任由它燃着，像是在确认彼此的心意。好在苏菲及时扑灭了窜起的火苗。</p>
<p>第二天，我们去了岸边。我想拉你的手，被你放开了，你在巨石下等我，我犹豫着走进。我们对视着，几乎是同时，揭下脸上的面纱，拥吻，分离，嘴角仍相连。你惊慌地跑开了，我没追上。苏菲说，你不舒服，不想吃晚饭。我举着小烛，慢步上楼，心事重重，恍然看见你身着洁白纱裙站在我身后，又消失不见。看到你在我房里等我，我安下心来，把头靠在你的肩上，你伸手环着我，你说你的确害怕，说着也靠向我。我转过身，你伸手抚上我的锁骨，下额，然后是唇。你说，你在等我来，你已想象过我们肌肤相亲的样子。你回答我，并没有梦见我，但是，一直惦念着。你主动吻了我，抚摸着我，而我，也回应了你。</p>
<p>醒来时，我们赤裸依偎着，在我的床上。如果不是苏菲来唤，许还要缠绵。我们陪着苏菲去了婆婆家，小女孩熟练地帮忙解开苏菲外面的衣裙，只留下薄薄一层单衣，婆婆也备好了药材。苏菲躺在床上，双腿分开，婆婆用着古老的方式人流。苏菲表情痛苦，你瞪大了眼，震惊又害怕，我别过头，不敢面对。你扯着我，告诉我仔细看。后来我才知道你是想让我画下来。回来后，你久不能释怀，要我画下最鲜活的痛楚。</p>
<p>后来你当模特时忍不住笑，于我那是诱惑。我几次制止也无济于事。我上前吻你，陷入你，终于还是赤裸了彼此。你将盛着秘方的小方盒放在腹部，说那是你买来的，能享用更久的兴奋。你蘸了一点，涂在身上，我侧躺着看你。我们爱抚着彼此，再次接吻。那天夜里我又再次看到你白色纱裙的虚像。你躺在床上贪恋着属于我们共同的气息，不愿起来，我借着喂水的名义俯身亲吻你。</p>
<p>我终于画出了我眼中的你，却想将它毁掉。你并非不解，却开口询问，想从我这里亲口听到答案。我画下了你，然后拱手于人，通过我画下的你。不错，我们都不够勇敢，我希望你去反抗，但不是要求，我不知道那样的生活会不会容易些。你哭了，转身跑开。厨房的花谢了，苏菲的刺绣还留着它盛开的样子，她告诉我你母亲明日归来，我们很快就不再是我们。你果然在海边，我飞奔过去，从身后紧紧抱住你，乞求你的原谅，告诉你明天不再。你转过身来，我们亲吻着，捧着彼此的脸。你再次坐在我跟前，看我完成画中的你。</p>
<p>我看着赤裸的你，画了一面小铜镜，给自己。你说之后就能照着它来临摹无数次了，是啊，我笑了。你说以后想你的时候我就只能看着它了，而你，却没有我的画像。你认真地说，想要我们此刻赤裸时我的画像。我笑着让你递过我的书，现在是你的了，我翻到你随口说出的28页，在书页的空白处，画下我，我把小圆镜置于你私处前，看着你，画下我。</p>
<p>我们在一起的最后一个晚上，面对面侧躺着。看你眼敛渐合，我连声央求你别睡，亲吻你的脸颊。你说着你有一种新的感觉，我没想到你说的是遗憾。「不要遗憾，要记得啊」，我注视着你的眼睛，你笑着，算是答应。我们细数着短短几日里微不足道却也柔情满溢的小细节，你在厨房睡着的样子，我在打牌时输给你时幽怨的眼神，你在我面前第一次笑起来的样子……可惜我们花了太多时间在互相试探。你没有告诉我你第一次想吻我是什么时候，只告诉我比我猜想的更早。</p>
<p>再醒来，一切都结束了。我最后一次为你系上裙带。</p>
<p>你的母亲对这幅肖像很是满意，那是自然，毕竟，我仔细端详了你身上的每个地方，看过，抚过，也感受过。收下报酬的时候，我其实只想再拥有你，可我不能说。你被母亲叫出，离开前回头看了看我，不舍，走了。我看着画像被封上，被送走，还好苏菲过来抱了抱我。我前去和你的母亲，还有你，告别。我抱了抱穿着白纱裙的你，用不能显露的恋人间的眷恋，又很快跑开，跑下楼，我怕我会哭。你在楼梯上呼唤：「回头看看我！」，我站在门外，拉着门把，噙着泪看你，你我的脸上都挂着无可逃避的悲伤，我终于还是关上了门。一如我脑中几次闪现的虚像，你，消失不见。我终于明白俄耳甫斯，也明白你。</p>
<p>课堂结束，学生说我刚刚很悲伤。</p>
<p>后来我再见到你的方式很特别。我在画展守着自己以父亲的名义参展的画作，一位老先生说它视角独特，我没有告诉他，那是因为，我也以同样的方式告别了你。以爱人的名义回头，以画家的名义离开。翻看参展目录时，竟看到你的名字，穿过人群，看到了你的肖像，你身着白纱裙，已有夫人风范，带着可爱的女儿，那个小女孩和我课上的学生很有几分相似。你手上拿着书，书角露出「28」，我们的约定，我们的密语，你也还记得。</p>
<p>我最后一次见你，是在音乐会上，我找到座席，无意中望见你，穿过听众，在对面落座。我一直看着你。维瓦尔第的《夏》响起，你听到了我弹过的片段，闭上眼，不能平静，你哭了，你听到了我遗忘的片段，笑了，还带着几分当年的怨念。好在，你没发现，对面，是我，对面，我在。你还记得当时的我，而我得知了现在的你，足够了罢。</p>
]]></content>
      <categories>
        <category>影视相关</category>
      </categories>
      <tags>
        <tag>Movie</tag>
      </tags>
  </entry>
  <entry>
    <title>影评（纪录片）-谢幕</title>
    <url>/Movie-The-Bridge/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">纪录片名称： 金门大桥(The Bridge)</span><br><span class="line">导演: Eric Steel</span><br><span class="line">官方网站: http://www.thebridge-themovie.com/</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>（观于10.8，写于10.9，码于10.14）</p>
<p>了解到金门大桥这部影片是在微信上看到了一篇关于自杀的推文，那篇文章很长，虽然不能说是认认真真地读，但终究是读完了它。恰逢国庆假期，于是就想一睹这部影片。</p>
<p>看这部影片是在从家返回学校的动车上。那天天气很晴，和这部影片似乎有那么点不搭，如果是阴雨天，窗外是云里雾里的池沼就完美了，我这样想着。不过后来，因为阳光刺眼，照进车厢里，晃得人睁不开眼，前座便把窗帘放了下来，于是，艳阳再与我无关。</p>
<p>可能是因为是部纪录片的缘故，又或者是为了配合这个略显严肃和沉重的主题，我觉着影片整体的节奏是有些缓慢的，因而略显拖沓。所以刚开始对影片并不抱有好感。然而及至看完整部影片，却几乎想要落泪，并不是因为感动，似乎也说不清是出于什么原因。用一个在《仿生人会梦见电子羊吗？》里的词语来说，可能是产生了共情吗？</p>
<p>影片里对于自杀者身边的人以及目击者的采访占据了很大的篇幅。大多数人都表示出不解，就像我无法理解他们为什么不解一样。人恶魔你似乎更倾向于对自杀者抱以一种几乎是嗤之以鼻的轻蔑。巧合的是，当天回到学校，傍晚似乎有学生想要自杀被发现，惊动了家长和学校，我对此事并不知情，但还是能听到些讨论。当听到身边的人的不解，甚至听到他们以一种有点戏谑和调侃的态度去揣测企图自杀的人，我几乎想冲过去打一架。以前也曾经听到过那么些自杀事件，也从《今日说法》看到过一些关于这个话题的报道和讨论。但最常听到的还是人们的不解和近乎事八卦一样的揣测。其实人们并不真的关心原因吧，却非要把他们的生前一点一滴地挖出来，像是考古发掘那样，一点点摆在展柜上摊开来。人们常常说他们事傻子。我不明白。是否也许在大多数人的字典里，自杀确实是一个讳莫如深的禁区，像是藏在博物馆里的文物，旁边还标识着「请勿触摸！」。我不知道这些脸上写着轻蔑的人们在学校曾经展开心理调查和测试的时候被问到是否产生过自杀念头这个问题的时候是不是选择了否，而心里的答案又是否是「否」，做出选择之前，有没有一点犹豫。想必大多数人还是多多少少有过这样的感受吧？如果是这样，那么他们的心情难道我们完全没有一点点理解吗？为何总固执地以生者的姿态去妄图揣测逝者的灵魂呢？</p>
<p>据统计，有两百多人因这部影片而放弃了自杀的念头，但也有三个人因为这部影片而选择了自杀，当然，两者都可能更多。人们对它褒贬不一。我并不觉得它做错了什么。说句可能成为众矢之的的话，谁也不能说活着是不是比死去更值得期待，毕竟，有成千上亿的人可以告诉你活着可以做出的千万种选择和变化，却没有人能告诉你死后的世界。影片里拍摄了两个跳桥的瞬间，我不知道摄制组是如何捕捉到这个瞬间的，还是这是像电影那样有一定的加工，但那个长发男子的纵身一跃看起来更像是一场表演，像是做了一个精彩的谢幕，以大桥为舞台。只是一去不复返，不再登场了。影片里的大桥看起来确实很美，很迷人，我以为从案例跳下应该是比跳楼要来的迷人得多的，脚下是亦刚亦柔的水。若尸体未被打捞，兴许还能给海里的鱼一顿饱餐，而不是血肉模糊地凝固在几张案发现场的照片和几篇未知善恶的报道里。</p>
<p>我从未想明白过生的意义，也总是思考过自杀这件事。正好读到这几句诗，也许可以对我的心情稍作描绘：</p>
<blockquote>
<p>另一些时候，</p>
<p>活着是件怪事，</p>
<p>怎么都不能自圆其说，</p>
<p>不能和谐，不能自在。</p>
<p>我是我自己的异物，</p>
<p>或者污秽。</p>
<p>逃不出去，</p>
<p>也剔不干净。</p>
<p>（节选自刘天昭《秋天》）</p>
</blockquote>
<p>在那篇推文中，记得似乎有这样一个问题，如果给自己想自杀这个念头打分，满分是十分，会给自己打上几分，我想于我而言，可能会是八分为常态，有时也许会蹦跶到九分，有时也许会缓和到七分，但不会更低了。有时抬头看天，会想，云的那一头，也许真的有另一个世界呢。站在那745英尺的大桥上，是不是也会觉得脚下会有另一个世界。我不曾去过那里，我不知道。如果要说影片带给我的意义，也许是终于知道，原来，当人们以自杀的方式谢幕自己的人生时，身边的人会有怎样的看法，而这些看法又让我有些难受，我不能理解，一如他们无法理解会想自杀这件事一样。</p>
<p>看完影片，趴在动车的座位上，想了很多，凌乱的想法错综复杂地交织在一起，犹豫之后还是写了下来，在一个本该读着概率论的下午，坐在图书馆略有些寒冷的冷气里，听着
Beethoven‘s
Silence，数次停笔，打着寒颤，写得有点想哭，只想蜷缩着被冻在与世隔绝的冰块里，思考死亡是否美好，跳桥是否优雅，自杀是否有罪，何时我会谢幕？</p>
<p>从桥上一跃而下，是去往了一个更好的世界吗？</p>
<figure>
<img src="./../images/golden-gate-bridge.jpg" alt="金门大桥" />
<figcaption aria-hidden="true">金门大桥</figcaption>
</figure>
]]></content>
      <categories>
        <category>影视相关</category>
      </categories>
      <tags>
        <tag>Movie</tag>
      </tags>
  </entry>
  <entry>
    <title>2037</title>
    <url>/Nonsense-2037/</url>
    <content><![CDATA[<p>（胡言乱语）</p>
<span id="more"></span>
<p>拾到十七年前的收藏 没有添加描述 看似影视剧照</p>
<p>地标闪烁「加油」 行人顶空罐，宠物裹袋装 大概是赛博科幻?</p>
<p>门外警车驻留 蒙面侠泰然持「枪」 也许是警匪大战？</p>
<p>顶斗笠 披「蓑衣」 聚首指点宏图 好一副现代江湖！</p>
<p>长颈鹿低头入院 求医 问诊 取药 该是温馨童话吧？</p>
<p>正慨叹导演非凡 「2020纪实」 最后 无人的樱园景上如此批注</p>
<p>墙上全息投影 却只在循环播放 大国速度成就战疫颂歌</p>
<p>年年四月一 今朝最愚人</p>
]]></content>
      <categories>
        <category>胡言乱语</category>
      </categories>
      <tags>
        <tag>nonsense</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>想象贫瘠·口罩</title>
    <url>/Nonsense-imagination-in-short-masks/</url>
    <content><![CDATA[<p>（胡言乱语）</p>
<span id="more"></span>
<p>他们盼新春喜庆 却发现 庚子正月的抢手年货 是口鼻前的些许遮蔽</p>
<p>他们说再无贫困 不曾想 全面小康的第一步 是兜揣小钱一罩难求</p>
<p>他们赞人人平等 没想过 社会公平的最佳实践 是早起填表晚间摇号</p>
<p>他们颂繁荣昌盛 笑说着 外邦偏远小镇 货品售空库存为零</p>
<p>蒙面失礼否？ 只听闻 疫期新令 无口罩者不得通行</p>
<p>大抵想象贫瘠 无力描绘白色2020</p>
]]></content>
      <categories>
        <category>胡言乱语</category>
      </categories>
      <tags>
        <tag>nonsense</tag>
        <tag>2019-nCoV</tag>
      </tags>
  </entry>
  <entry>
    <title>幻境</title>
    <url>/Nosense-illusion/</url>
    <content><![CDATA[<p>（胡言乱语）</p>
<span id="more"></span>
<pre>
先听见你的声音
然后看见我的心跳
梦就这样悄然走近
面容不曾认
名姓不曾识
造梦机偷偷塑形
填入厨头嬉戏光景
暗自欢喜
采撷来一旬幻境
不愿醒
</pre>
]]></content>
      <categories>
        <category>胡言乱语</category>
      </categories>
      <tags>
        <tag>nonsense</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法-[1]绪论与计算误差</title>
    <url>/Numerical-methods-and-calculation-error/</url>
    <content><![CDATA[<p>计算方法课程第一章绪论与计算误差整理，来自课程内容，因 Github
无法渲染公式，故整理在此.</p>
<p>源文件：https://github.com/fish-404/Notes/tree/master/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95</p>
<span id="more"></span>
<h2 id="计算方法研究内容与意义">计算方法研究内容与意义</h2>
<h3 id="研究对象">研究对象</h3>
<p>计算方法研究的是运用计算机来解决各种数学问题的 <strong>近似</strong>
计算方法与理论。</p>
<p>计算方法是研究求解各类数学问题在一定范围内的在一定范围内的
<em>数值解</em> 的方法，以及这些方法的
<strong>误差传播规律</strong>、<strong>收敛性</strong>、<strong>稳定性</strong>，与如何
<em>在计算机上</em> 编程 <em>有效实现</em> 等问题的学科。</p>
<figure>
<img
src="https://raw.githubusercontent.com/fish-404/Notes/master/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/%E5%88%A9%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B.png"
alt="利用计算机解决实际问题的基本过程流程图" />
<figcaption
aria-hidden="true">利用计算机解决实际问题的基本过程流程图</figcaption>
</figure>
<h3 id="意义">意义</h3>
<ol type="1">
<li>计算机只能解决以四则运算为基础的，能在有穷步内结束的计算问题，高等数学和线性代数的许多理论与方法不能在计算机上直接应用。</li>
<li>众多生产实践与科学研究问题本身并不具备解析形式，或者用纯数学方法难以找到问题的解析解。</li>
<li>一些问题虽然具有解析形式，但过于复杂，计算机无法在可接受的时间内求解。</li>
<li>一些问题的解析解可能含有无穷多项，只能使用近似的计算方法去逼近问题的解。</li>
<li>在分析实验，观察数据时，需要使用插值、拟合等多种数值计算方法把一系列离散的数据关联起来。</li>
</ol>
<h2 id="计算方法的主要特点">计算方法的主要特点</h2>
<ul>
<li><p><strong>严谨性</strong>：</p>
<p>计算方法的收敛性、稳定性与可靠性需要以数学理论为基础</p></li>
<li><p><strong>实践性</strong>：</p>
<p>与实际应用、实际计算过程紧密相连</p></li>
<li><p><strong>近似性</strong>:</p>
<p>用有穷取代无穷，变不可解为可解的方法，对数学问题近似求解，逐步求精</p></li>
<li><p><strong>结构性</strong>：</p>
<p>由有穷步的四则运算构成：计算复杂性低；方法、流程与计算机程序一致</p></li>
</ul>
<h2 id="误差的基本概念">误差的基本概念</h2>
<h3 id="计算机中数的浮点表示">计算机中数的浮点表示</h3>
<p>计算机中参与运算的数是用浮点表示的</p>
<p><span class="math display">\[
x = \pm a_1a_2 \cdots a_s \times \beta^c
\]</span></p>
<p>其中 <span class="math inline">\(1 \le a_1 &lt; \beta, 0 \le a_i &lt;
\beta, i = 2, 3, \cdots, s\ge\)</span>, <span
class="math inline">\(c\)</span>是阶码</p>
<h3 id="计算机中的舍入误差">计算机中的舍入误差</h3>
<p>大多数计算机以二进制形式存储数字，由于计算机字长有限，不是所有数字都可以被准确地表示，它们必须被舍入到适合计算机的字长，意味着被执行的算术运算使不精确的。</p>
<h3 id="误差来源">误差来源</h3>
<ul>
<li>观察误差</li>
</ul>
<p>由于仪器的精密程度、实验手段、周围环境、人工作态度及能力等因素，观察或测量结果存在误差。</p>
<p>求解过程中，使用带有误差的观察数据作为数学模型的原始输入数据或已知参数引入观察误差。</p>
<ul>
<li>模型误差</li>
</ul>
<p>在建立数学模型时抓住问题最本质、起主导作用的方面，略去非本质的次要因素，将问题理想化再进行数学概括，模型与实际之间存在一定误差。</p>
<p>在将实际问题转化为数学模型的阶段引入模型误差。</p>
<ul>
<li>截断误差</li>
</ul>
<p>为了让计算机能解决数学上需要无穷次运算才能获得精确解的问题，通过有限次计算得到问题近似解，近似解与理论上的准确解存在误差。</p>
<p>在使用计算方法逼近数学模型的理论精确解的过程中引入截断误差，也称为「方法误差」。</p>
<ul>
<li>舍入误差</li>
</ul>
<p>由于计算机字长有限，在计算过程中的数据通过四舍五入或类似操作来保留有限位的有效数字，引入舍入误差。</p>
<h3 id="误差与误差限">误差与误差限</h3>
<h4 id="绝对误差">绝对误差</h4>
<p><span class="math display">\[
e(x^\*) = x - x^\*
\]</span></p>
<p><span class="math inline">\(x\)</span> 为精确值， <span
class="math inline">\(x^\*\)</span> 为 <span
class="math inline">\(x\)</span> 的近似值</p>
<p><span class="math inline">\(e(x^\*)\)</span>可正可负。</p>
<h4 id="绝对误差限">绝对误差限</h4>
<p><span class="math inline">\(|e(x^\*)|\)</span>的上限称为$ x^*$
的绝对误差限，记为 <span
class="math inline">\(\varepsilon(x^\*)\)</span></p>
<p><span
class="math inline">\(\varepsilon(x^\*)\)</span>不唯一，越小越有参考价值</p>
<p>给定近似值<span class="math inline">\(x^\*\)</span> 的误差限<span
class="math inline">\(\varepsilon(x^\*)\)</span>，就可以直到准确值 <span
class="math inline">\(x\)</span> 的区间，实际应用中一般记为 <span
class="math inline">\(x = x^\* \pm \varepsilon(x^\*)\)</span></p>
<h4 id="相对误差">相对误差</h4>
<p><span class="math display">\[
e_r(x^\*) =\frac{e(x^\*)}{x}  = \frac{(x - x^\*)}{x}
\]</span> #### 相对误差限 <span
class="math inline">\(|e_r(x^\*)|\)</span> 的上限称为 <span
class="math inline">\(x^\*\)</span> 的相对误差限，记为 <span
class="math inline">\(\varepsilon_r(x^\*)\)</span></p>
<h4 id="有效数字与误差限的关系">有效数字与误差限的关系</h4>
<ul>
<li><strong>定理1</strong> 如果近似数 <span class="math inline">\(x^\* =
\pm r^m \times (a_1 r^{-1} + a_2 r ^{-2} + \cdots + a_n r^{-n})\)</span>
具有 <span class="math inline">\(n\)</span> 位有效数字，则可以得到 <span
class="math inline">\(x^\*\)</span> 的一个绝对误差限： <span
class="math display">\[
|e(x^\*) | = |x - x^\*| \le \varepsilon(x ^\*) = \frac{1}{2} \times
r^{m-n}
\]</span></li>
<li><strong>定理2</strong> 如果近似数 <span class="math inline">\(x^\* =
\pm r^m \times (a\_1 r^{-1} + a_2 r ^{-2} + \cdots + a_n
r^{-n})\)</span> 具有 <span class="math inline">\(n\)</span>
位有效数字，则可以得到 <span class="math inline">\(x^\*\)</span>
的一个相对误差限： <span class="math display">\[
|e(x^\*) | = |x - x^\*| \le \varepsilon(x ^\*) = \frac{1}{2} \times
r^{-(n - 1)}
\]</span></li>
<li><strong>定理3</strong> 如果近似数 <span class="math inline">\(x^\* =
\pm r^m \times (a_1 r^{-1} + a_2 r ^{-2} + \cdots + a_n r^{-n})\)</span>
满足 <span class="math display">\[
|e_r(x^\*)|\le \frac{1}{2(a_1+ 1)}\times r^{-(n-1)}
\]</span> 那么<span class="math inline">\(x^\*\)</span>至少有 <span
class="math inline">\(n\)</span> 位有效数字。</li>
</ul>
<p><em>注意</em> ：任意移动小数点位置不影响有效数字位数。 ####
四则运算的误差传播公式 ##### 加减法 <span class="math display">\[
\varepsilon(x^\* \pm y^\*) = \varepsilon(x^\*) + \varepsilon (y ^\*)
\]</span> ##### 乘法 <span class="math display">\[
\varepsilon(x^\*y^\*) = |x^\*|\varepsilon(y^\*) +
|y^\*|\varepsilon(x^\*)
\]</span> ##### 除法 <span class="math display">\[
\varepsilon(\frac{x^\*}{y^\*})=\frac{|x^\*|\varepsilon(y^\*)+|y^\*|\varepsilon(x^\*)}{|y^\*|^2},
y \ne0, y^\* \ne 0
\]</span></p>
<p>(误差传播公式和求导公式有些相似）</p>
<h3 id="设计计算方法的原则">设计计算方法的原则</h3>
<h4 id="计算方法的评判标准">计算方法的评判标准</h4>
<ol type="1">
<li>稳定性的好坏</li>
<li>精度的高低</li>
<li>计算量的大小</li>
<li>存储量的大小</li>
<li>逻辑是否简单</li>
</ol>
<h4 id="基本原则">基本原则</h4>
<h5 id="避免两个相近的数相减">1. 避免两个相近的数相减</h5>
<p>两个相近的数相减将导致有效数字的严重丢失。在设计计算方法时应设法避免这种情况发生，常用方法时变换计算公式：</p>
<p>常见变换公式： <span class="math display">\[
\sqrt{x+ \varepsilon} - \sqrt{x} = \frac{\varepsilon}{\sqrt{x +
\varepsilon} + \sqrt{x}}, \varepsilon \to 0
\]</span> <span class="math display">\[
ln(x + \varepsilon) - ln x = ln(1+\frac{\varepsilon}{x}),\varepsilon \to
0, 且 |x| \gg 0
\]</span> <span class="math display">\[
1-cosx = 2sin^2 \frac{x}{2} , x\to 0
\]</span> <span class="math display">\[
e^x - 1 = (1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots) - 1 = x (1
+ \frac{x}{2} + \frac{x^2}{6} + \cdots), x\to 0
\]</span> ##### 2.防止大数吃小数</p>
<p>当两个绝对值差异很大的数进行加减法运算时，绝对值小的数有可能因为计算机附点运算的特点而被“吃掉“，导致计算结果严重失真。</p>
<ol type="1">
<li><p>求二次方程的根 <span class="math display">\[
\begin{cases}
x_1 = \frac{-2c}{b + sgn(b)\sqrt{b^2 - 4ac}}, \quad sgn(b) =
\begin{cases}
1, b\ge 0 \\\\
-1, b &lt; 0
\end{cases}\\\\
x_2 = \frac{c}{ax_1}
\end{cases}
\]</span></p></li>
<li><p>在处理多个数求和操作时，一般按照从小到大的顺序累加，可以使求和的误差减到最小。</p></li>
</ol>
<h5 id="避免采用绝对值很小的数作为除数">3.
避免采用绝对值很小的数作为除数</h5>
<p>当采用绝对值很小的数作为分母时，容易产生浮点溢出现象，同时可能引起大数吃小数的情况出现，导致误差很大。</p>
<h5 id="简化运算步骤减少运算次数">4. 简化运算步骤，减少运算次数</h5>
<ul>
<li>良好的计算方法应该具有可接受的时间复杂度和（存储）空间复杂度。</li>
<li>简化运算步骤不但能够有效地减少运算时间，同时也能减少舍入误差的积累。</li>
<li>计算机处理速度顺序 <span class="math display">\[
(+, -)&gt;(\times, \div)&gt;(exp)
\]</span></li>
<li>在设计计算方法时应该尽量使用速度较快的加减运算。</li>
</ul>
<h5 id="控制计算方法的误差传播保证计算方法的稳定性">5.
控制计算方法的误差传播，保证计算方法的稳定性</h5>
<ul>
<li><strong>稳定性算法</strong>：在运算过程中误差逐步衰减的算法</li>
<li><strong>不稳定算法</strong>： 误差的积累越来越大的算法</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>《数值计算》</li>
</ul>
]]></content>
      <categories>
        <category>计算方法</category>
      </categories>
      <tags>
        <tag>Numerical methods</tag>
      </tags>
  </entry>
  <entry>
    <title>幻境</title>
    <url>/Nosense-timeline/</url>
    <content><![CDATA[<p>（胡言乱语）</p>
<span id="more"></span>
<p>先听见你的声音 然后看见我的心跳 梦就这样悄然走近 面容不曾认
名姓不曾识 造梦机偷偷塑形 填入厨头嬉戏光景 暗自欢喜 采撷来一旬幻境
不愿醒</p>
]]></content>
      <categories>
        <category>胡言乱语</category>
      </categories>
      <tags>
        <tag>nonsense</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法-[2]非线性方程的数值解法</title>
    <url>/Numerical-methods-solutions-of-nolinear-equations/</url>
    <content><![CDATA[<p>计算方法第二章非线性方程的数值解法课程内容整理。</p>
<span id="more"></span>
<p>以下Matlab代码于<a href="https://github.com/fish-404/Notes/tree/master/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/programs/Solutions%20of%20Nonlinear%20Equations">Notes/计算方法/programs/Solution
of Nolinear Equations at master · fish-404/Notes</a>
中，使用时创建一个<code>f.m</code>文件写入待求解函数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function y=f(x)</span><br><span class="line">y=sqrt(x)-cos(x);</span><br></pre></td></tr></table></figure>
<p>使用牛顿法，需要另外创建一个<code>fd.m</code>文件，写入待求解函数一阶导函数。</p>
<h2 id="二分法-bisection-or-binary-search-method">二分法 (Bisection or
Binary-search method)</h2>
<h3 id="二分法">二分法</h3>
<h4 id="原理">原理</h4>
<p>函数 <span class="math inline">\(f\)</span> 在<span
class="math inline">\([a, b]\)</span> 上连续（<span
class="math inline">\(f \in C [a, b]\)</span>)，<span
class="math inline">\(f\)</span>在区间<span
class="math inline">\([a,b]\)</span>的两个端点处异号(<span
class="math inline">\(f(a)f(b) &lt; 0)\)</span>, 方程<span
class="math inline">\(f(x) = 0\)</span>在 <span
class="math inline">\((a, b)\)</span>内至少有一个实根<span
class="math inline">\(p\)</span>，使得<span class="math inline">\(f(p) =
0\)</span>，区间<span
class="math inline">\([a,b]\)</span>称为方程的有根区间。</p>
<h4 id="采用二分法求出p的逼近过程">采用二分法求出<span
class="math inline">\(p\)</span>的逼近过程</h4>
<p>取<span class="math inline">\(a_0 = a,b_0 = b\)</span>，中点<span
class="math inline">\(x_0 = \frac{a_0 + b_0}{2}\)</span>，若<span
class="math inline">\(f(x_0) = 0\)</span>，则 <span
class="math inline">\(p = x_0\)</span>，算法停止，否则如果<span
class="math inline">\(f(a_0)f(x_0)&lt;0\)</span>，取<span
class="math inline">\(a_1 = a_0\)</span>，<span
class="math inline">\(b_1 = x_0\)</span>；如果<span
class="math inline">\(f(x_0)f(b_0) &lt;0\)</span>，取<span
class="math inline">\(a_1 = x_0\)</span>，<span
class="math inline">\(b_1 = b_0\)</span>，方程的有根区间缩小为<span
class="math inline">\([a_1,b_1]\)</span>。</p>
<p>重复上述步骤，不断缩小有根区间，直至找到满足精度的解。</p>
<p>算法的停止条件可以是： * <span
class="math inline">\(|x\_n-x\_{n-1}|&lt;\varepsilon\)</span> * <span
class="math inline">\(\frac{|x\_n-x\_{n-1}}{|x\_ n|}&lt;\varepsilon,
\quad x\_n \not= 0\)</span> * <span
class="math inline">\(|f(x_n)|&lt;\varepsilon\)</span></p>
<p><strong>注意</strong>： 1.
在使用计算机进行数值逼近时，需注意计算精度问题，计算区间中心值时，应选用公式
<span class="math display">\[
x_n = a_n + \frac{b_n-a_n}{2}
\]</span> 因为当<span class="math inline">\(a_n\)</span>和<span
class="math inline">\(b_n\)</span>都接近机器精度时，<span
class="math inline">\(x_n = \frac{a_n +
b_n}{2}\)</span>得到的值可能超出<span
class="math inline">\([a_n，b_n]\)</span>范围。</p>
<ol start="2" type="1">
<li>在判断子区间<span
class="math inline">\({a_n,b_n}\)</span>中是否存在<span
class="math inline">\(f\)</span>的根时，应使用符号函数： <span
class="math display">\[
sgn(x) = \begin{cases}
-1, \quad x &lt; 0 \\\\
0, \quad x = 0 \\
1,\quad x &gt; 0
\end{cases}
\]</span> 检查<span class="math inline">\(f(a_n)\)</span>与<span
class="math inline">\(f(b_n)\)</span>是否异号，使用<span
class="math inline">\(sgn(f(a_n)\cdot
sgn(f(b_n))&lt;0\)</span>，而不是<span class="math inline">\(f(a_n)\cdot
f(b_n) &lt;0\)</span>，避免乘积越界而导致错误。</li>
</ol>
<p><strong>定理2.1</strong> 设<span class="math inline">\(f\in
C[a,b]\)</span>，<span
class="math inline">\(f(a)f(b)&lt;0\)</span>，则二分法产生的数列<span
class="math inline">\({x_n}\)</span>满足 <span class="math display">\[
|x_n - p| \le \frac{b-a}{2^{n+1}}
\]</span> 其中<span class="math inline">\(p\in[a,b]\)</span>是<span
class="math inline">\(f(x) = 0\)</span>的根，<span
class="math inline">\(n = 0,1,\cdots\)</span>。</p>
<ul>
<li><p><strong>收敛速率</strong> 由定理2.1，当<span
class="math inline">\(n\to \infty\)</span>时，数列<span
class="math inline">\({x_n}\)</span>以<span
class="math inline">\(O(\frac{1}{2^n})\)</span>的速度收敛到实际解<span
class="math inline">\(p\)</span> <span class="math display">\[
x_n = p + O(\frac{1}{2^n})
\]</span> 收敛速度与比值为<span
class="math inline">\(\frac{1}{2}\)</span>的等比级数相同。</p></li>
<li><p><strong>估计求解步数</strong> 对于给定的精度<span
class="math inline">\(\varepsilon\)</span>，二分法找到满足某个精度的解所需步数<span
class="math inline">\(n+1\)</span> 满足 <span class="math display">\[
\frac{b-a}{2^{n+1}} &lt; \varepsilon \Rightarrow n+1 &gt;
\frac{ln(b-a)-lnc}{ln 2}
\]</span> 即： <span class="math display">\[
n + 1\ge \lceil \frac{ln(b-a) - ln\varepsilon}{ln2} \rceil
\]</span> 实际误差可能比这个值小得多。</p></li>
</ul>
<h4 id="优缺点">优缺点</h4>
<ul>
<li><strong>优点</strong>:
<ul>
<li>简单，总会收敛到解</li>
<li>只要求函数连续即可</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>收敛速度慢，只利用函数值的正负</li>
<li>只能用于求实根，无法用于求复根和偶重根</li>
</ul></li>
</ul>
<h4 id="二分法matlab代码">二分法Matlab代码</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Bisection: get the solution of function f in [a,b]</span></span><br><span class="line"><span class="comment">% a : the interval lower bound </span></span><br><span class="line"><span class="comment">% b : the interval upper bound</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bisection</span><span class="params">(a, b, varphi)</span></span></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"> fprintf(<span class="string">&#x27;n\t \t a_n \t\t b_n\t\t x_n\t |f(x_n)|\t \n&#x27;</span>)</span><br><span class="line"> <span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span></span><br><span class="line">    p=a+(b-a)/<span class="number">2</span>;</span><br><span class="line">    w=f(p);</span><br><span class="line">    <span class="keyword">if</span> w==<span class="number">0</span> || ((b-a)/<span class="number">2</span>)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%8.5g\t%8g\t%8.5g\t%8.5g\t%8.5g\t%8.5g\n&#x27;</span>,<span class="built_in">i</span> - <span class="number">1</span>,a,b,p,w,(b-a)/<span class="number">2</span>,(b-a)/<span class="number">2</span>/<span class="built_in">abs</span>(p));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%8.5g\t%8.5g\t%8.5g\t%8.5g\t%8.5g\t%8.5g\n&#x27;</span>,<span class="built_in">i</span> - <span class="number">1</span>,a,b,p,w,(b-a)/<span class="number">2</span>,(b-a)/<span class="number">2</span>/<span class="built_in">abs</span>(p));</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> w*f(a)&lt;<span class="number">0</span></span><br><span class="line">        b=p;</span><br><span class="line">    <span class="keyword">else</span> a=p;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="线性插值二分法">线性插值二分法</h3>
<h4 id="原理-1">原理</h4>
<p>在二分法的基础上，利用函数在区间两端点<span
class="math inline">\(a\)</span>和<span
class="math inline">\(b\)</span>上的连线与<span
class="math inline">\(x\)</span>轴的交点，缩小有根区间。 <span
class="math display">\[
x_n = b_n - f(b_n) \cdot \frac{b_n-a_n}{f(b_n)-f(a_n)}
\]</span></p>
<p>在一定条件下，线性插值二分法比二分法的收敛速度快些。</p>
<h4 id="线性插值二分法matlab代码">线性插值二分法Matlab代码</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Linear interpolation dichotomy</span></span><br><span class="line"><span class="comment">% a : the interval lower bound </span></span><br><span class="line"><span class="comment">% b : the interval upper bound</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinearInterpolation</span><span class="params">(a, b, varphi)</span></span></span><br><span class="line">clc</span><br><span class="line">fprintf(<span class="string">&#x27;One point secant Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">fa=f(a);</span><br><span class="line">fb=f(b);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span></span><br><span class="line">    p=b-fb*(b-a)/(fb-fa);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(p-b)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,p);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    q=f(p);</span><br><span class="line">    <span class="keyword">if</span> q*fb&lt;<span class="number">0</span></span><br><span class="line">        a=b;</span><br><span class="line">        fa=fb;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    b=p;</span><br><span class="line">    fb=q;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代法-iteration-method">迭代法 (Iteration Method)</h2>
<p>将区间<span class="math inline">\([a,b]\)</span>上的方程<span
class="math inline">\(f(x) = 0\)</span>改写成等价形式： <span
class="math display">\[
x = \varphi(x), a\le x\le b
\]</span> 其中<span class="math inline">\(\varphi \in C[a,b]\)</span>。
* <strong>迭代数列</strong><span class="math inline">\(\{x_n\}\)</span>
<span class="math display">\[
x\_n = \varphi(x\_{n - 1}), n = 1, 2, \cdots
\]</span> 上式称为<span class="math inline">\(f(x) =
0\)</span>的一个<strong>迭代格式</strong>， <span
class="math inline">\(x_0\)</span> 称为<strong>迭代初值</strong></p>
<h3
id="一般迭代法fixed-point-iterationfunctional-iteration">一般迭代法(Fixed-Point
Iteration)(Functional Iteration)</h3>
<p>如果数列<span class="math inline">\(\{x\_n\}\)</span> , 设<span
class="math inline">\(\lim\limits\_{n\to \infty} x\_n =
p\)</span>，则</p>
<p><span class="math display">\[
p = \lim\limits\_{n\to \infty}
x\_{n+1} = \lim \limits\_{n\to \infty} \varphi(x\_n) =\varphi(\lim
\limits\_{n\to \infty } x\_n ) = \varphi(p)
\]</span></p>
<p>此时<span class="math inline">\(p\)</span>为方程 <span
class="math inline">\(f(x) = 0\)</span> 的根。 #### 不动点理论 * 定义2.1
对于函数<span class="math inline">\(\varphi\)</span>, 若点<span
class="math inline">\(p\)</span> 使得<span
class="math inline">\(\varphi(p) = p\)</span>，称<span
class="math inline">\(p\)</span>为<span
class="math inline">\(\varphi\)</span>的不动点。 #####
不动点存在的充分条件 * 定理2.2 若函数<span class="math inline">\(\varphi
\in C[a,b]\)</span>且对于<span class="math inline">\(\forall x\in [a,
b]\)</span>有<span class="math inline">\(\varphi(x) \in [a,b]\)</span>
，那么<span class="math inline">\(\varphi\)</span>在<span
class="math inline">\([a,b]\)</span>上有不动点。 #####
区间内不动点存在且唯一的充分条件 * 定理 2.3
满足定理2.2的前提下，如果函数<span
class="math inline">\(\varphi\)</span>满足李普希茨(Lipschitz)条件 <span
class="math display">\[
|\varphi(x) - \varphi(y)| \le L|x- y|, \forall x, y \in [a,b]
\]</span> 并且常数<span class="math inline">\(0 &lt; L
&lt;1\)</span>，那么<span class="math inline">\(\varphi\)</span>在<span
class="math inline">\([a,b]\)</span>上有唯一的不动点。 * 定理2.4
满足定理2.2的前提下，如果<span
class="math inline">\(\varphi\)</span>在<span
class="math inline">\((a,b)\)</span>上有一阶连续导数，且存在常数<span
class="math inline">\(0&lt;L&lt;1\)</span>使得 <span
class="math display">\[
|\varphi&#39;(x) |\le L, \forall x \in[a,b]
\]</span> 那么<span class="math inline">\(\varphi\)</span>在<span
class="math inline">\([a,b]\)</span>上有唯一的不动点。</p>
<p><em>注意</em> ，定理2.3与定理2.4为充分条件，也即即使<span
class="math inline">\(\varphi\)</span>不满足这两个定理，也可能存在不动点唯一的情况。</p>
<h4 id="迭代收敛的条件">迭代收敛的条件</h4>
<ul>
<li><p>定义2.2 满足定理2.3或定理2.4的函数<span
class="math inline">\(\varphi\)</span>称为区间<span
class="math inline">\([a,b]\)</span>上的<strong>压缩映射</strong>，式中的<span
class="math inline">\(L\)</span>称为<span
class="math inline">\(\varphi\)</span>的<strong>压缩系数</strong>。</p></li>
<li><p>定理2.5 **迭代收敛定理* 若<span
class="math inline">\(\varphi\)</span>是区间<span
class="math inline">\([a,b]\)</span>上的压缩映射，那么对于<span
class="math inline">\(\forall x\_0 \in [a,b]\)</span>，由迭代公式<span
class="math inline">\(x\_n = \varphi(x\_{n-1})\)</span>产生的数列<span
class="math inline">\(\{x\_n\}\)</span>收敛到方程<span
class="math inline">\(x = \varphi(x)\)</span>在<span
class="math inline">\([a,b]\)</span>上的唯一解。</p></li>
</ul>
<h4 id="不动点迭代法matlab代码">不动点迭代法Matlab代码</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Functional Iteration / Fixed-Point Iteration</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionalIteration</span><span class="params">(varphi, x0)</span></span></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span></span><br><span class="line">    x=f(x0);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x-x0)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代算法理论">迭代算法理论</h3>
<ul>
<li>迭代法的几何意义 相当于把曲线<span class="math inline">\(y =
\varphi(x)\)</span>与直线<span class="math inline">\(y =
x\)</span>的求交问题，近似地转化为数列<span
class="math inline">\(\{x\_n\}\)</span>向不动点逼近的过程，其中<span
class="math inline">\(x\_n = \varphi(x\_{n-1}), n = 1, 2,
\cdots\)</span>。</li>
<li>定理 2.6 压缩系数与迭代收敛速度的关系 若<span
class="math inline">\(\varphi\)</span>是区间<span
class="math inline">\([a,b]\)</span>上的压缩映射，迭代过程中解的误差满足
<span class="math display">\[
|x\_n - p| &lt;L^n \max(x\_0 - a, b-x\_0)
\]</span> <span class="math display">\[
|x\_n - p| \le \frac{L}{1-L}|x\_n - x\_{n - 1}|\le \frac{L^n}{1-L}|x\_1
- x\_0|
\]</span> 其中<span class="math inline">\(p\)</span>为区间<span
class="math inline">\([a,b]\)</span>上的不动点，<span
class="math inline">\((0&lt;L&lt;1)\)</span>为<span
class="math inline">\(\varphi\)</span>在区间<span
class="math inline">\([a,b]\)</span>的压缩系数，<span
class="math inline">\(n = 1, 2, \cdots\)</span>。</li>
</ul>
<p>压缩系数<span class="math inline">\(L\)</span>的值越小，<span
class="math inline">\(x\_n\)</span>趋近<span
class="math inline">\(p\)</span>的速度越快，而当<span
class="math inline">\(L\)</span>的值接近于1时，迭代法的收敛速度就变得很慢。</p>
<ul>
<li>定理2.7 局部收敛性 设<span
class="math inline">\(p\)</span>时函数<span
class="math inline">\(\varphi\)</span>的不动点，且<span
class="math inline">\(\varphi&#39;(p) \ne 1\)</span>，如果存在常数<span
class="math inline">\(\delta&lt;0\)</span>使得<span
class="math inline">\(\varphi\)</span>在区间<span
class="math inline">\([p-\delta, p+\delta]\)</span>上满足定理2.4，
那么一般迭代法得到的数列对任意初值<span class="math inline">\(x\_0 \in
[p-\delta, p+ \delta]\)</span>收敛。</li>
</ul>
<h4 id="收敛阶">收敛阶</h4>
<ul>
<li><p>定义2.3 对于一个收敛到<span
class="math inline">\(p\)</span>的数列<span
class="math inline">\({x\_n}\)</span>， <span class="math inline">\(x\_n
\ne p\)</span>， 如果存在实数<span
class="math inline">\(\lambda\)</span>和<span
class="math inline">\(\alpha\)</span>使得 <span class="math display">\[
\lim \limits\_{n\to \infty} \frac{|x\_{n+1} - p|}{|x\_n - p|^\alpha} =
\lambda
\]</span></p></li>
<li><p>当<span class="math inline">\(\lambda \ne 0\)</span>时数列<span
class="math inline">\({x_n}\)</span>的<strong>收敛阶</strong>是<span
class="math inline">\(\alpha\)</span>，<span
class="math inline">\(\lambda\)</span>为<strong>渐近误差常数</strong>。</p>
<ol type="1">
<li>若<span class="math inline">\(\alpha = 1\)</span>,
称数列<strong>线性收敛</strong>或<strong>1阶收敛</strong>。</li>
<li>若<span class="math inline">\(\alpha =
2\)</span>，称数列<strong>平方收敛</strong>或<strong>2阶收敛</strong>。</li>
<li>若<span class="math inline">\(\alpha
&gt;1\)</span>，称数列<strong>超线性收敛</strong>或<span
class="math inline">\(\alpha\)</span>阶收敛。</li>
</ol></li>
<li><p>当<span class="math inline">\(\lambda = 0\)</span>时称数列<span
class="math inline">\(\{x_n\}\)</span>的收敛阶高于<span
class="math inline">\(\alpha\)</span>。</p></li>
<li><p>迭代法的普遍性定理 满足压缩映射的函数<span
class="math inline">\(\varphi\)</span>得到的数列<span
class="math inline">\(\{x_n\}\)</span>:</p>
<ul>
<li>当<span class="math inline">\(\varphi&#39;(p) \ne
0\)</span>时，对<span class="math inline">\(\forall x\_0 \in
[a,b]\)</span>，数列<span
class="math inline">\(\{x\_n\}\)</span>都收敛到区间<span
class="math inline">\([a,b]\)</span>上唯一的不动点<span
class="math inline">\(p\)</span>。</li>
<li>当<span class="math inline">\(\varphi&#39;(p) = 0\)</span>，<span
class="math inline">\(\varphi\)</span>在<span
class="math inline">\((a,b)\)</span>有二阶连续导数，且<span
class="math inline">\(\varphi&#39;&#39;(p) \ne
0\)</span>时数列的收敛阶是2.</li>
</ul></li>
</ul>
<h3 id="加速收敛迭代法">加速收敛迭代法</h3>
<h4 id="埃特金方法-aitken">埃特金方法 （Aitken)</h4>
<p>对于一个收敛到 <span class="math inline">\(p\)</span> 的数列<span
class="math inline">\(\{x\_n\}\)</span>，如果其收敛阶为1， 那么 <span
class="math display">\[
\lim \limits\_{n \to \infty}\frac{|x\_{n+1} - p|}{|x\_n - p|} = C， C
为常数，0&lt; C &lt; 1
\]</span> 可以认为当<span class="math inline">\(n \to
\infty\)</span>时有 <span class="math display">\[
\frac{x\_n  -p}{x\_{n - 1} - p } \approx \frac{x\_{n - 1} - p}{x\_{n -
2} - p}
\]</span> 得到<strong>Aitken数列</strong><span
class="math inline">\(\hat{\{x\_n\}}\)</span> <span
class="math display">\[
\hat{x\_n} = x\_n - \frac{(x\_n - x\_{n - 1})^2}{x\_n - 2 x\_{n - 1} +
x\_{n - 2}}
\]</span></p>
<ul>
<li>定理2.9 若数列<span class="math inline">\(\{x\_
n\}\)</span>以1阶收敛到<span class="math inline">\(p\)</span>，记 <span
class="math display">\[
e\_n = x\_n - p \ne 0
\]</span> 对一切<span class="math inline">\(n\ge 0\)</span>成立，且
<span class="math display">\[
\lim \limits\_{n\to \infty} \frac{e\_{n+1}}{e\_n} = \lambda, \quad
|\lambda| &lt; 1
\]</span> 则Aitken数列<span
class="math inline">\(\hat\{x\_n\}\)</span>是完全确定的，且 <span
class="math display">\[
\lim \limits\_{n\to \infty} \frac{\hat{x\_n} -p}{x\_n - p} = 0
\]</span> 即Aitken数列<span
class="math inline">\(\{\hat{x\_n}\}\)</span>比数列<span
class="math inline">\(\{x\_n\}\)</span>更快收敛到<span
class="math inline">\(p\)</span>。 ##### Aitken 加速迭代法Matlab代码
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% AitkenIteration</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AitkenIteration</span><span class="params">(x0, varphi)</span></span></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">x1=f(x0);</span><br><span class="line">p=x0;</span><br><span class="line">fprintf(<span class="string">&#x27;Aitken Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;0\t%g\n&#x27;</span>,x0);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span>   </span><br><span class="line">    x2=f(x1);</span><br><span class="line">    x=x0-(x1-x0).^<span class="number">2.</span>/(x2<span class="number">-2</span>*x1+x0);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x-p)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x1;</span><br><span class="line">    x1=x2;</span><br><span class="line">    p=x;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> #### Steffensen 方法 Aitken
数列可以对任意线性收敛的数列进行处理。若将Aitken方法与不动点结合则可以得到Steffensen方法</li>
<li>定理2.10 设<span class="math inline">\(p\)</span>是函数<span
class="math inline">\(\varphi\)</span>的不动点，那么具有下列迭代格式的函数<span
class="math inline">\(\psi\)</span>与<span
class="math inline">\(\varphi\)</span>具有相同的不动点。 <span
class="math display">\[
x\_n = \psi(x\_{n-1}) =
\frac{x\_{n-1}\varphi(\varphi(x\_{n-1})) -
[\varphi(x\_{n-1})]^2}{\varphi(\varphi(x\_{n-1})) - 2\varphi(x\_{n -
1})+ x\_{n-1}}
=x\_{n-1} -
\frac{[\varphi(x\_{n-1} - x\_{n-1}]^2}{\varphi(\varphi(x\_{n-1})) -
2\varphi(x\_{n-1}) + x\_{n-1}}
\]</span></li>
<li>定理2.11 设<span class="math inline">\(p\)</span>是函数<span
class="math inline">\(\varphi\)</span>的不动点，且<span
class="math inline">\(\varphi&#39;(p)\ne1\)</span>，如果存在常数<span
class="math inline">\(\delta&gt;0\)</span>使得<span
class="math inline">\(\varphi\)</span>在区间<span
class="math inline">\([p - \delta, p +
\delta]\)</span>上有三阶连续导数，那么 Steffensen
方法得到的数列对任意初值<span class="math inline">\(x\_0 \in [p -
\delta, p+ \delta]\)</span>二阶收敛。</li>
</ul>
<h5 id="steffensen-迭代的特点">Steffensen 迭代的特点</h5>
<ul>
<li>对于一阶收敛到<span class="math inline">\(p\)</span>的数列<span
class="math inline">\(x\_{n+1} = \varphi(x_n)\)</span>，在<span
class="math inline">\(\varphi &#39;(p)\ne 1\)</span>时，Steffensen
方法得到的数列二阶收敛</li>
<li>对于原本不收敛的数列，Steffensen 方法也可能把它改进为二阶收敛</li>
<li>对于超线性收敛（大于1阶）数列，改用 Steffensen 方法的意义不大</li>
<li>Steffensen 方法多用于改进一阶方法</li>
</ul>
<h5 id="steffensen-迭代法matlab代码">Steffensen 迭代法Matlab代码</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% SteffensenIteration</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SteffensenIteration</span><span class="params">(x0, varphi)</span></span></span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;Steffensen Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;0\t%g\n&#x27;</span>,x0);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span>   </span><br><span class="line">    x1=f(x0);</span><br><span class="line">    x2=f(x1);</span><br><span class="line">    x=x0-(x1-x0).^<span class="number">2.</span>/(x2<span class="number">-2</span>*x1+x0);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x-x0)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2
id="牛顿法牛顿切线法牛顿迭代法newton-raphson-methon">牛顿法/牛顿切线法/牛顿迭代法(Newton-Raphson
Methon)</h2>
<p>将非线性方程线性化，有 <span class="math display">\[
f(x) = f(x\_n) + f&#39;(x\_n)(x-x\_0)
\]</span> 当<span
class="math inline">\(f&#39;(x\_n)\ne0\)</span>，用<span
class="math inline">\(x\_{n+1}\)</span>代替<span
class="math inline">\(x\)</span>，由<span class="math inline">\(f(x) =
0\)</span>得到迭代公式： <span class="math display">\[
x\_{n+1} = x\_n -
\frac{f(x\_n)}{f&#39;(x\_n)}
\]</span> 即 <span class="math display">\[
\varphi(x) = x - \frac{f(x)}{f&#39;(x)}
\]</span> 从几何角度来解释，即过<span class="math inline">\((x\_n,
f(x\_n))\)</span>作曲线<span class="math inline">\(y =
f(x)\)</span>的切线，切线与<span
class="math inline">\(x\)</span>轴交点的横坐标即为<span
class="math inline">\(x\_{n+1}\)</span>。</p>
<ul>
<li>定理2.12 牛顿法收敛的充分条件 设<span class="math inline">\(f\in
C^2[a, b]\)</span>，即<span class="math inline">\(f\)</span>在<span
class="math inline">\([a,b]\)</span>上有二阶连续导数，若</li>
</ul>
<ol type="1">
<li><span class="math inline">\(f(a)f(b)&lt;0\)</span></li>
<li><span class="math inline">\(f&#39;\)</span>与<span
class="math inline">\(f&#39;&#39;\)</span>在<span
class="math inline">\([a,b]\)</span>上符号保持不变</li>
<li><span class="math inline">\(f(x\_0)f&#39;&#39;(x)&gt;0, x\_0, x\in
[a,b]\)</span>（<span class="math inline">\(x\_0\)</span>为迭代初值）
那么由牛顿迭代格式生成的数列<span
class="math inline">\(\{x_n\}\)</span>收敛于方程<span
class="math inline">\(f(x) = 0\)</span>在<span
class="math inline">\({a,b]\)</span>上的唯一解，且收敛阶为2。</li>
</ol>
<ul>
<li>推论2.1 设<span class="math inline">\(f\in C^2[a,b]\)</span>且<span
class="math inline">\(f(a)f(b)&lt;0\)</span>，并在<span
class="math inline">\([a,b]\)</span>上<span
class="math inline">\(f&#39;f&#39;&#39;&gt;0\)</span>，那么当迭代初值<span
class="math inline">\(x_0 = b\)</span>时，由牛顿迭代格式生成的数列<span
class="math inline">\(\{x_n\}\)</span>是一个严格递减有下界的数列，它收敛于方程<span
class="math inline">\(f(x) = 0\)</span>在<span
class="math inline">\([a,b]\)</span>上的唯一解，且收敛阶为2.</li>
<li>推论2.2 设<span class="math inline">\(f\in C^2[a,b]\)</span>且<span
class="math inline">\(f(a)f(b)&lt;0\)</span>，并在<span
class="math inline">\([a,b]\)</span>上<span
class="math inline">\(f&#39;f&#39;&#39;&lt;0\)</span>，那么当迭代初值<span
class="math inline">\(x_0 = a\)</span>时，由牛顿迭代格式生成的数列<span
class="math inline">\(\{x_n\}\)</span>是一个严格递增有上届的数列，它收敛于方程<span
class="math inline">\(f(x) = 0\)</span>在<span
class="math inline">\([a,b]\)</span>上的唯一解，且收敛阶为2.</li>
<li>定理2.13 牛顿法的局部收敛性 设<span class="math inline">\(f\in
C^2[a,b]\)</span>，如果存在<span class="math inline">\(p \in
[a,b]\)</span>使得<span class="math inline">\(f(p) = 0\)</span>和<span
class="math inline">\(f&#39;(p)\ne 0\)</span>，那么存在一个正数<span
class="math inline">\(\delta &gt;0\)</span>使得牛顿法生成的数列<span
class="math inline">\(\{x_n\}\)</span>对<span
class="math inline">\(\forall x_0 \in [p - \delta, p+
\delta]\)</span>都收敛于<span
class="math inline">\(p\)</span>，即数列<span
class="math inline">\(\{x_n\}\)</span>局部收敛于<span
class="math inline">\(p\)</span>，并且二阶收敛。</li>
</ul>
<p>牛顿法的致命弱点在于每次迭代除了计算函数值外还要计算导数值。</p>
<h3 id="牛顿法matlab代码">牛顿法Matlab代码</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Newton-Raphson Method</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewtonRaphsonMethod</span><span class="params">(x0, varphi)</span></span></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;Newton Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;0\t%g\n&#x27;</span>,x0);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span>   </span><br><span class="line">    x=x0-f(x0)/fd(x0);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x-x0)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2
id="弦截法割线法双点弦截法secant-method">弦截法/割线法/双点弦截法(Secant
method)</h2>
<p>使用差商代替牛顿法中的<span
class="math inline">\(f&#39;(x\_n)\)</span>： <span
class="math display">\[
x\_{n+ 1} = x\_n -
\frac{f(x\_0)(x\_0 - x\_{n-1})}{f(x\_n)-f(x\_{n-1}）}
\]</span> 几何意义： 用过点<span class="math inline">\((x\_{n-1},
f(x\_{n-1}))\)</span>和<span class="math inline">\((x\_n,
f(x\_n))\)</span>的割线与<span
class="math inline">\(x\)</span>轴的交点逼近方程<span
class="math inline">\(f(x) = 0\)</span>的解。 * 定理2.14 设<span
class="math inline">\(f(p) = 0\)</span>，在<span
class="math inline">\(p\)</span>的一个邻域<span
class="math inline">\(\Delta = [p - \delta, p+ \delta]\)</span>内<span
class="math inline">\(f \in C^2(\Delta)\)</span>， <span
class="math inline">\(f&#39;(\Delta)\ne 0\)</span>, <span
class="math inline">\(M \delta&lt;1\)</span>，其中 <span
class="math display">\[
M = \frac{\max \limits\_{x\in \Delta}|f&#39;&#39;(x)|}{2 \min
\limits\_{x\in \Delta}|f&#39;(x)|}
\]</span> 则当<span class="math inline">\(x\_0x_1\in
\Delta\)</span>时，由弦截法迭代格式产生的数列<span
class="math inline">\(\{x_n\} \subset \Delta\)</span>收敛于<span
class="math inline">\(p\)</span>，且收敛阶为 <span
class="math inline">\(\frac{1+\sqrt{5}}{2} \approx 1.618\)</span> ###
弦截法Matlab代码 <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Secant Method: get the solution of function f in [a,b]</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="comment">% x1 : the initial value</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SecantMethod</span><span class="params">(x0, x1, varphi)</span></span></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;Secant Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;0\t%.5f\n&#x27;</span>,x0);</span><br><span class="line">fprintf(<span class="string">&#x27;1\t%.5f\n&#x27;</span>,x1);</span><br><span class="line">w0=f(x0);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span></span><br><span class="line">    w1=f(x1);</span><br><span class="line">    x=x1-w1*(x1-x0)/(w1-w0);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x-x1)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>+<span class="number">1</span>,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>+<span class="number">1</span>,x);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x1;</span><br><span class="line">    x1=x;</span><br><span class="line">    w0=w1;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure> ## 抛物线法/Müller法（Parabola Iteration)
弦截法是通过<span class="math inline">\((x\_{n-1},
f(x\_{n-1}))\)</span>和<span class="math inline">\((x\_n,
f(x\_n))\)</span>两点做直线与<span
class="math inline">\(x\)</span>轴的焦点得出<span
class="math inline">\(x\_{n+1}\)</span>，而抛物线法则是过<span
class="math inline">\((x\_{n-2}, f(x\_{n-2})), (x\_{n-1},
f(x\_{n-1}))\)</span>和<span class="math inline">\((x\_n,
f(x\_n))\)</span>三点作抛物线与<span
class="math inline">\(x\)</span>轴的交点作为<span
class="math inline">\(x\_{n+1}\)</span>。 迭代公式为 <span
class="math display">\[
x\_{n+1} = x\_n - \frac{2c}{b + sgn(b)\sqrt{b^2 - 4ac}}
\]</span>
抛物线法可用于求解非线性方程的实根和复根，特别适用于多项式的求根问题。收敛阶为1.839。</p>
<h3 id="抛物线法matlab代码">抛物线法Matlab代码</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Parabolalteration Method</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="comment">% x1 : the initial value</span></span><br><span class="line"><span class="comment">% x2 : the initial value</span></span><br><span class="line"><span class="comment">% varphi : the presicionclc</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParabolaIteration</span><span class="params">(x0, x1, x2, varphi)</span></span></span><br><span class="line"><span class="built_in">i</span>=<span class="number">3</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;Parabola Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;0\t%.5f\n&#x27;</span>,x0);</span><br><span class="line">fprintf(<span class="string">&#x27;1\t%.5f\n&#x27;</span>,x1);</span><br><span class="line">fprintf(<span class="string">&#x27;2\t%.5f\n&#x27;</span>,x2);</span><br><span class="line">h1=x1-x0;</span><br><span class="line">h2=x2-x1;</span><br><span class="line">w1=(f(x1)-f(x0))/h1;</span><br><span class="line">w2=(f(x2)-f(x1))/h2;</span><br><span class="line">d=(w2-w1)/(h2+h1);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span></span><br><span class="line">    b=w2+h2*d;</span><br><span class="line">    D=<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*f(x2)*d);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(b-D)&lt;<span class="built_in">abs</span>(b+D)</span><br><span class="line">        E=b+D;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        E=b-D;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    h=<span class="number">-2</span>*f(x2)/E;</span><br><span class="line">    p=x2+h;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(h)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>, p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,p);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x1;</span><br><span class="line">    x1=x2;</span><br><span class="line">    x2=p;</span><br><span class="line">    h1=x1-x0;</span><br><span class="line">    h2=x2-x1;</span><br><span class="line">    w1=(f(x1)-f(x0))/h1;</span><br><span class="line">    w2=(f(x2)-f(x1))/h2;</span><br><span class="line">    d=(w2-w1)/(h2+h1);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算方法</category>
      </categories>
      <tags>
        <tag>Numerical methods</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法-[3]线性方程组的数值解法</title>
    <url>/Numerical-solution-of-linear-equations/</url>
    <content><![CDATA[<p>计算方法第三章线性方程的数值解法课程内容整理，尚未包含代码部分。</p>
<span id="more"></span>
<h2 id="直接法">直接法</h2>
<h3 id="高斯消去法gaussian-elimination">高斯消去法(Gaussian
Elimination)</h3>
<p><span class="math display">\[
\mathbf{Ax} = \mathbf{b} \Rightarrow
\begin{bmatrix}
a\_{11} &amp; \cdots &amp; a\_{1n} \\\\
       &amp; \ddots &amp; \vdots \\\\
       &amp;        &amp; a\_{nn}^{(n-1)}
\end{bmatrix}\mathbf{x} =
\begin{bmatrix}
b_1 \\\\
\vdots \\\\
b_n^{(n-1)}
\end{bmatrix}
\]</span></p>
<ul>
<li>消去：</li>
</ul>
<p><span class="math display">\[
l\_{ik} = a\_{ik}^{(k)}/a\_{kk}^{(k)}  \\
\]</span> <span class="math display">\[
\begin{cases}
a\_{ij}^{(k+1)} = a\_{ij}^{(k)} - l\_{ik} a\_{kj}^{(k)} \\\\
b\_{i}^{(k+1)} = b\_{i}^{(k)} - l\_{ik} b\_{k}^{(k)}
\end{cases}
(k = 1,2，\cdots, n - 1 ,  \quad i，j = k + 1, k + 2, \cdots, n)
\]</span></p>
<ul>
<li>回代：</li>
</ul>
<p><span class="math display">\[
\begin{cases}
x\_n = b\_n^{(n)} / a^{(n)}\_{nn}\\\\
x\_i = (b\_i^{(i)} - \sum\limits^n\_{j = i+1})/a\_{ii}^{(i)}
\end{cases}
\quad i = n - 1, n - 2, \cdots, 1
\]</span></p>
<ul>
<li>复杂度 ： <span class="math inline">\(O(n^3)\)</span></li>
</ul>
<h3 id="列主元消去法">列主元消去法</h3>
<p>主元素：<span class="math inline">\(a\_{kk}^{(k)}\)</span>
(作为除数的元素)</p>
<p>使用高斯消去法时，若除数很小，除法计算时将产生较大的舍入误差，影响后续消元。</p>
<p>列主元消去法即改进的高斯消去法，在选取主元素时按列选取待消去的矩阵元素中
<strong>绝对值</strong> 最大的元素与当前行交换，成为新的主元素。即：
<span class="math display">\[
if \quad \max\_{k \le i\le n}|a\_{i_k}| \ne 0 \quad and \quad i\_k \ne k
\\\\
then \quad i\_k \leftrightarrow k
\]</span></p>
<p>相比于高斯消去法，列主元消去法更稳定，但行列交换需花费较多时间，计算量高于高斯消去法
<span class="math inline">\(O(n^2/3)\)</span>。</p>
<h3
id="高斯-若当消去法gauss-jordan-method">高斯-若当消去法（Gauss-Jordan
Method)</h3>
<p><span class="math display">\[
\mathbf{Ax} = \mathbf{b} \Rightarrow
\begin{bmatrix}
a\_{11} &amp;  &amp; \\\\
  &amp; \ddots &amp;\\\\
  &amp; &amp; a\_{nn}^{(n-1)}
\end{bmatrix}\mathbf{x} =
\begin{bmatrix}
b\_1 \\\\
\vdots \\\\
b\_n^{(n-1)}
\end{bmatrix}
\]</span> 1. 将当前列主元 <span
class="math inline">\(a\_{kk}^{(k)}\)</span> 变为1 2. 将 <span
class="math inline">\(a\_{kk}^{(k)}\)</span> 所在列的上下元素变为0</p>
<p>计算量比高斯消去法多<span class="math inline">\((n^3-3n^2 +
2n)/6\)</span> 次乘除。常用于求逆矩阵。</p>
<ul>
<li>高斯若当法求逆矩阵</li>
</ul>
<p><span class="math display">\[
[A|E] \Rightarrow[E| A^{-1}]
\]</span></p>
<h3 id="lu-分解法">LU 分解法</h3>
<p><span class="math inline">\(n\)</span>阶矩阵<span
class="math inline">\(A\)</span>,若其所有顺序主子式均不为0，则可将其分解为一个单位下三角矩阵<span
class="math inline">\(L\)</span> 和一个上三角矩阵<span
class="math inline">\(U\)</span>的乘积，且这种分解唯一。 <span
class="math display">\[
\mathbf{A} =
\begin{bmatrix}
1 &amp; &amp; &amp; \\\\
l\_{21} &amp; 1 &amp; &amp; \\\\
\vdots &amp; \vdots &amp; \ddots &amp; \\\\
l\_{n1} &amp; l\_{n2} &amp; \cdots &amp; 1
\end{bmatrix}
\begin{bmatrix}
u\_{11} &amp; u\_{12} &amp; \cdots &amp; u\_{1n} \\\\
       &amp; u\_{22} &amp; \cdots &amp; u\_{2n} \\\\
       &amp;        &amp; \ddots &amp; \vdots \\\\
       &amp;        &amp;        &amp; u\_{nn}
\end{bmatrix}
\]</span></p>
<p>求解过程： <span class="math display">\[
\mathbf{A}^{(k)} = \mathbf{L}\_{k-1} \mathbf{A}^{(k-1)}\\\\
\mathbf{U} = \mathbf{A}^{(n)} = \mathbf{L}\_{n-1}\mathbf{A}^{(k-1)}\\\\
\mathbf{L}\_k =
\begin{bmatrix}
1 &amp;  &amp;  &amp;  \\\\
  &amp; 1 &amp; &amp; \\\\
  &amp; -l\_{k+1, k} &amp; &amp; \\\\
  &amp; \vdots     &amp; \ddots\\\\
  &amp; -l\_{n, k}  &amp;  0 &amp; 1
\end{bmatrix},
\quad l\_{ik} = \frac{a\_{ik}^{(k)}}{a\_{kk}^{(k)}}
\\
\]</span> 回代： <span class="math display">\[
\begin{cases}
y\_i = b\_i - \sum \limits\_{k = 1}^{i-1} k\_{ik}y_k, \quad i = 1, 2,
\cdots, n \\\\
x\_i = y\_i - \sum \limits^{n}\_{k = i + 1}u\_{ik}x\_{k}/u\_{ii}, \quad
i = n, n-1, \cdots, 1
\end{cases}
\]</span></p>
<h3 id="直接法求解的特点">直接法求解的特点</h3>
<ol type="1">
<li>经过可预先确定的有限次<strong>算术运算</strong> 求出精确解；</li>
<li>由于有舍入误差，只能得到近似解；</li>
<li>需要对解进行误差分析；</li>
<li>不适合用于求解病态方程组；</li>
<li>一般适合于解矩阵 <span class="math inline">\(A\)</span>
为低阶稠密矩阵的方程组。</li>
</ol>
<h3 id="判断矩阵是否为病态矩阵">判断矩阵是否为病态矩阵</h3>
<p>判断矩阵是否病态，常由经验得出：</p>
<ol type="1">
<li>行列式很大或很小（如某些行、列近似相关）；</li>
<li>元素间相差大数量级，且无规则；</li>
<li>主元消去过程中出现小主元；</li>
<li>特征值相差大数量级。</li>
</ol>
<p>使用直接法求解病态矩阵的方程组可能使解严重偏离真实值。</p>
<h2 id="迭代法">迭代法</h2>
<p>将待求解方程组改写成其等价形式<span class="math inline">\(\mathbf{x =
Bx+g}\)</span> ，以迭代序列的形式逼近方程的根。</p>
<p><span class="math inline">\(\mathbf{L}\)</span>：下三角矩阵；</p>
<p><span class="math inline">\(\mathbf{U}\)</span>：上三角矩阵；</p>
<p><span class="math inline">\(\mathbf{D}\)</span>：对角矩阵。</p>
<h3 id="雅可比迭代法jacobi-iterative-methods">雅可比迭代法(Jacobi
Iterative Methods)</h3>
<p><span class="math display">\[
\mathbf{x}^{(k+1)} = \mathbf{B}\_J \mathbf{x}^{(k)} + \mathbf{g}\_J \\\\
\begin{cases}
\mathbf{B}\_J = -\mathbf{D}^{-1}(\mathbf{L+U}) \\\\
\mathbf{g}\_J = \mathbf{D}^{-1} \mathbf{b}
\end{cases}
\]</span></p>
<h3
id="高斯-塞尔德gauss-seidel-iterative-methods">高斯-塞尔德(Gauss-Seidel
Iterative Methods)</h3>
<p><span class="math display">\[
\mathbf{x}^{(k+1)} = \mathbf{B}\_S \mathbf{x}^{(k)} + \mathbf{g}\_S\\\\
\begin{cases}
\mathbf{B}\_S = -\mathbf{(D+L)}^{-1}\mathbf{U} \\\\
\mathbf{g}\_S = \mathbf{(D+L)}^{-1} \mathbf{b}
\end{cases}
\]</span></p>
<h3 id="迭代法的收敛性">迭代法的收敛性</h3>
<p>迭代法收敛的充要条件是谱半径小于1。 <span class="math display">\[
\rho(\mathbf{B}) &lt; 1
\]</span> 谱半径(spectral radius)：<span
class="math inline">\(\rho(\mathbf{B}) = \max\limits\_{1\le i\le
n}|\lambda\_i|\)</span>，<span class="math inline">\(\lambda\
_i\)</span> 为<span
class="math inline">\(\mathbf{B}\)</span>的特征值。</p>
<h4 id="特殊的迭代矩阵">特殊的迭代矩阵</h4>
<ul>
<li>若<span class="math inline">\(\mathbf{A}\)</span>
为严格对对角占优矩阵，则方程组的Jacobi和 Gauss-Seidel 迭代均收敛。</li>
</ul>
<p>严格对角占优矩阵 (strictly diagonally dominant matrix)</p>
<p><span
class="math inline">\(\mathbf{A}\)</span>的每一行对角线元素绝对值都严格大于同行其他元素绝对值之和：
<span class="math display">\[
|a\_{ii}|&gt;\sum\limits^n\_{j = 1\\\\j\ne i}|a\_{ij}| \quad (i =  1, 2,
\cdots, n)
\]</span></p>
<ul>
<li>若<span class="math inline">\(\mathbf{A}\)</span>
不可约，即不能通过出初等行变换变为上三角矩阵的形式，且按行弱对角占优，则方程组的
Jacobi 和 Gauss-Seidel迭代均收敛。</li>
</ul>
<p>弱对角占优； <span class="math display">\[
|a\_{ii}|\ge\sum\limits^n\_{j = 1\\\\j\ne i}|a\_{ij}| \quad (i =  1, 2,
\cdots , n)
\]</span> 且至少有一个<span
class="math inline">\(i\)</span>使得大于号成立，则<span
class="math inline">\(\mathbf{A}\)</span>为弱对角占优矩阵。</p>
<ul>
<li>若<span class="math inline">\(\mathbf{A}\)</span> 为对称正定矩阵，则
Gauss-Seidel迭代收敛。</li>
</ul>
<h3 id="迭代法的特点">迭代法的特点</h3>
<ol type="1">
<li>构造出合适的迭代格式可加快收敛速度；</li>
<li>不容易构造能收敛到解的迭代函数；</li>
</ol>
<h3 id="迭代法的优点">迭代法的优点</h3>
<ol type="1">
<li>舍入误差影响小；</li>
<li>对于高阶方程组计算量小于直接法；</li>
<li>适合于求解系数矩阵问题</li>
</ol>
<h2 id="解线性方程组的误差分析">解线性方程组的误差分析</h2>
<h3 id="范数">范数</h3>
<h4 id="向量范数">向量范数</h4>
<p>注：将向量看作矩阵时，应视为<span
class="math inline">\(n\times1\)</span>的列向量。</p>
<p><span class="math inline">\(\mathbf{R}^n\)</span> 空间的向量范数<span
class="math inline">\(||\cdot||\)</span> 对任意<span
class="math inline">\(\mathbf{x, y} \in \mathbf{R}^n\)</span> 满足：</p>
<ul>
<li><p>正定性(positive definite)： <span
class="math inline">\(||\mathbf{x}||\ge 0; \quad ||\mathbf{x}|| = 0
\Leftrightarrow \mathbf{x} = 0\)</span></p></li>
<li><p>齐次性(homogeneous)：<span class="math inline">\(||\alpha
\mathbf{x}|| = |\alpha| \cdot ||\mathbf{x}||\)</span></p></li>
<li><p>三角不等式(triangle inequality)：<span
class="math inline">\(||\mathbf{x +y}|| \le||\mathbf{x}|| +
||\mathbf{y}||\)</span></p></li>
</ul>
<p>常用向量范数：</p>
<ul>
<li><span class="math inline">\(||x||\_1 = \sum \limits\_{i = 1}^n
|x\_i|\)</span></li>
<li><span class="math inline">\(||x||\_2 = \sqrt{\sum \limits\_{i = 1}^n
| x\_i| ^2}\)</span></li>
<li><span class="math inline">\(||x||\_p = (\sum\limits\_{i = 1}^n
|x\_i|^p)^{1/p}\)</span></li>
<li><span class="math inline">\(||x||\_{\infty} = \max\limits\_{1\le i
\le n}|x\_i|\)</span></li>
</ul>
<h4 id="矩阵范数">矩阵范数</h4>
<p><span class="math inline">\(\mathbf{R}^{m\times n}\)</span>
空间的矩阵范数<span class="math inline">\(||\cdot||\)</span> 对任意
<span class="math inline">\(\mathbf{A,B} \in \mathbf{R}^{m\times
n}\)</span> 满足：</p>
<ul>
<li>正定性：<span class="math inline">\(||\mathbf{A}|| \ge 0; \quad
||\mathbf{A}|| = 0 \Leftrightarrow \mathbf{A} = 0\)</span></li>
<li>齐次性：<span class="math inline">\(||\alpha \mathbf{A}|| = |\alpha|
\cdot ||\mathbf{A}||\)</span></li>
<li>三角不等式：<span class="math inline">\(||\mathbf{A+B} || \le ||
\mathbf{A}|| + || \mathbf{B}||\)</span></li>
<li>相容(consistent)（当<span class="math inline">\(m = n\)</span>
时）：<span class="math inline">\(||\mathbf{AB}||\le ||\mathbf{A}||
\cdot || \mathbf{B}||\)</span></li>
</ul>
<p>常用矩阵范数：</p>
<ul>
<li>行和范数： <span class="math inline">\(||\mathbf{A}||\_{\infty} =
\max \limits\_{1\le i \le n} \sum \limits\_{j=1}^n
|a\_{ij}\)</span></li>
<li>列和范数：<span class="math inline">\(||\mathbf{A}||\_1 = \max
\limits\_{1\le j\le n} \sum \limits\_{i = 1}^n |a\_{ij}|\)</span></li>
<li>谱范数(spectral norm)：<span class="math inline">\(||\mathbf{A}||\_2
= \sqrt{\rho(\mathbf{A^TA)}}\)</span></li>
</ul>
<h3 id="条件数">条件数</h3>
<p>矩阵<span class="math inline">\(\mathbf{A}\)</span>的条件数记为<span
class="math inline">\(cond(\mathbf{A})\)</span>，越大则矩阵越病态，越难得到准确解。
<span class="math display">\[
cond(\mathbf{A}) = ||\mathbf{A}|| \cdot ||A^{-1}||
\]</span> 性质：</p>
<ul>
<li>若<span class="math inline">\(\mathbf{A}\)</span> 对称，则<span
class="math inline">\(cond(\mathbf{A})\_2 =
\frac{max|\lambda|}{min|\lambda|}\)</span></li>
<li>若<span class="math inline">\(\mathbf{A}\)</span> 可逆，则<span
class="math inline">\(cond(\mathbf{A})\_p \ge 1\)</span></li>
<li>若<span class="math inline">\(\mathbf{A}\)</span> 可逆， <span
class="math inline">\(\alpha \in R\)</span>， 则<span
class="math inline">\(cond(\alpha \mathbf{A}) =
cond(\mathbf{A})\)</span></li>
<li>若<span class="math inline">\(\mathbf{A}\)</span> 正交， 则<span
class="math inline">\(cond(\mathbf{A})\_2 = 1\)</span></li>
<li>若<span class="math inline">\(\mathbf{A}\)</span> 可逆， <span
class="math inline">\(\mathbf{R}\)</span> 正交， 则 <span
class="math inline">\(cond(\mathbf{RA})\_2 = cond(\mathbf{AR})\_2 =
cond(\mathbf{A})\_2\)</span></li>
</ul>
]]></content>
      <categories>
        <category>计算方法</category>
      </categories>
      <tags>
        <tag>Numerical methods</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL - 空字符串、空白字符串和 NULL</title>
    <url>/SQL-emptyStr-whitespace-null/</url>
    <content><![CDATA[<p>本文谈谈 SQL 中的空字符串，空白字符串和 <code>NULL</code>.</p>
<span id="more"></span>
<p>遇到这样一个需求，从数据库中获取中文名，无中文名时以英文名代替。而无中文名实际上可能有空白字符串，空字符串，还可能是
<em><code>NULL</code></em>, 在处理这些值的时候遇到了一些有趣的结果。</p>
<p>为了解释以下查询语句的结果，假设我们有一个表：</p>
<table>
<thead>
<tr class="header">
<th>c_name</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NULL</td>
<td>name with c_name null</td>
</tr>
<tr class="even">
<td></td>
<td>name with c_name empty</td>
</tr>
</tbody>
</table>
<p>你可以在 <a
href="https://dbfiddle.uk/?rdbms=sqlserver_2017&amp;fiddle=69a1c3d70c1f92155552d3e2be4c94bd">db&lt;&gt;fiddle</a>
中测试本文提到的 SQL 语句。</p>
<p>原始 SQL 语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> c_name <span class="keyword">when</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">then</span> name <span class="keyword">else</span> c_name <span class="keyword">end</span> <span class="keyword">as</span> name <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<h1 id="空白字符串与空字符串">空白字符串与空字符串</h1>
<p>我首先考虑的是直接与空字符串比较是否会在 <code>c_name</code>
为多个空白字符的时候因被判不等而返回空白字符串，C#
中字符串的判空方法就有 <a
href="https://docs.microsoft.com/en-us/dotnet/api/system.string.isnullorempty?view=net-6.0"><code>String.IsNullOrEmpty(String)</code></a>
与 <a
href="https://docs.microsoft.com/en-us/dotnet/api/system.string.isnullorwhitespace?view=net-6.0"><code>String.IsNullOrWhiteSpace(String)</code></a>
的区别，因此将查询语句改成了以下版本。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL Server 2017 (14.x) and later</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="built_in">trim</span>(c_name) <span class="keyword">when</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">then</span> name <span class="keyword">else</span> c_name <span class="keyword">end</span> <span class="keyword">as</span> name <span class="keyword">from</span> employee</span><br><span class="line"><span class="comment">-- SQL Server 2017 (14.x) before</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> ltrim(rtrim(c_name)) <span class="keyword">when</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">then</span> name <span class="keyword">else</span> c_name <span class="keyword">end</span> <span class="keyword">as</span> name <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<p>根据 <a
href="https://docs.microsoft.com/en-us/sql/t-sql/functions/trim-transact-sql?view=sql-server-ver15">MS
Docs</a> , <code>TRIM</code> 与 <code>LTRIM(RTRIM(@string))</code>
的行为一致，但 <code>TRIM</code> 是 SQL Server 2017(14.x) 才引进的。</p>
<p>但我当我使用上面的脚本和之前的脚本去测试一个包含多个空白字符的
<code>c_name</code> 时，发现它们都能得到正确的结果 <code>name</code>
，而不会返回空白字符串 <code>c_name</code>
。实验结果证明空白字符串无论含有多少个空白字符，实际上在 SQL Server
中都是相等的。</p>
<p>几经搜索后发现这是 <a
href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL -
92</a> 中规定的标准。标准的第208页写道：</p>
<blockquote>
<p>If the length in characters of X is not equal to the length in
characters of Y, then the shorter string is effectively replaced, for
the purposes of comparison, with a copy of itself that has been extended
to the length of the longer string by concatenation on the right of one
or more pad characters, where the pad character is chosen based on CS.
If CS has the NO PAD attribute, then the pad character is an
implementation-dependent character different from any character in the
character set of X and Y that collates less than any string under CS.
Otherwise, the pad character is a <space>.</p>
</blockquote>
<p>也就是说当一个空字符串与一个有多个空白字符的空白字符串进行比较时，空字符串会以添加空格的形式被扩展，从而最后两者的值被判定为相等。</p>
<p>所以我们实际上仍然可以使用原来的查询语句。</p>
<h1 id="null">NULL</h1>
<p>前面提到，除了空白字符串，空字符串，实际上我们还有可能遇到
<code>NULL</code> 作为 <code>c_name</code>
的取值，这时候上面的查询语句是否还能正常工作呢？</p>
<p>很不幸，在以 <code>NULL</code> 作为 <code>c_name</code>
的测试中，<code>NULL</code> 依然被作为了一个合法的中文名被返回。</p>
<p>先来看看上面语句的另一种写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> c_name <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">then</span> c_name <span class="keyword">else</span> name <span class="keyword">end</span> <span class="keyword">as</span> name <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<p>这条查询语句与上面原始的查询语句是否一样呢？从语义上来看似乎是一样的，只不过是把
<code>case when</code>
条件换了个顺序。但是令人惊讶的是，换做这种写法时，我们得到了正确的结果，它不再会返回
<code>NULL</code> 。</p>
<p>这是怎么回事呢？按照我们上面的测试，<code>c_name</code> 为
<code>NULL</code> 时与空字符串不等，所以仍然返回了 <code>c_name</code> ,
但在这里，按照这样的理解，它似乎应该还是返回 <code>c_name</code>
。我一度以为是 <code>case when</code>
的用法有什么奇妙之处导致了这个问题，但似乎没有找到类似的问题，于是在
Stack Overflow 上<a
href="https://stackoverflow.com/questions/71120524/handle-null-and-empty-in-sql-server">发问</a>，才发现原来并不是
<code>case when</code> 的问题，而是 <code>NULL</code>
的问题。网友指出：</p>
<blockquote>
<p>Remember: <strong>null does not mean "empty"</strong>. Instead, it
means "I don't know".</p>
</blockquote>
<p>LeetCode 中有道类似 SQL 的<a
href="https://leetcode-cn.com/problems/find-customer-referee/">题目</a>，第一反应肯定是
<code>referee_id != 2</code>
这样最直观的想法，但是你会发现如果直接使用这个 <code>where</code>
条件，在 <code>NULL</code>
确实与2不相等的情况下却不会被返回，这是怎么回事呢？</p>
<p>来看看 <a
href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL -
92</a> 关于等于操作符有怎样的规定：</p>
<blockquote>
<p>General Rules</p>
<ol type="1">
<li><p>Let X and Y be any two corresponding
<code>&lt;row value constructor element&gt;</code>s. Let XV and YV be
the values represented by X and Y, respectively.</p>
<p>Case:</p>
<ol type="a">
<li>If XV or YV is the null value, then "X <code>&lt;comp op&gt;</code>
Y" is unknown.</li>
</ol></li>
</ol>
</blockquote>
<p>在这里我们可以看到，如果被比较的两个值至少有一个为 <code>NULL</code>
, 比较的结果实际上并非我们想象中的 <code>True | False</code> , 而是
<code>Unkown</code> ，所以我们的 <code>WHERE</code> 语句对于值为
<code>NULL</code> 的记录得到的并不是一个 <code>True</code> 的结果。</p>
<p>在前面的查询语句中，我们的相等条件不满足，返回了 <code>c_name</code>
, 在这一条查询语句中，我们的不等条件实际上得到了一个<code>Unkown</code>
也不满足 <code>True</code> ，所以它不会返回第一个表达式
<code>c_name</code> ，误打误撞返回了正确的 <code>name</code> 。</p>
<p>这里涉及到了一个三元问题，我们发现一个原本应该得到的二元布尔值集合变成了一个三元集合。在我们所接触过的其他语言中，布尔值明确地就是
<code>True | False</code> ，而在 SQL
中，这个概念相当于是被扩充了，在逻辑运算的计算法则上也有很大的不同，这里不再展开。</p>
<h1 id="isnullnullif">ISNULL|NULLIF</h1>
<p>回到上面的最初查询名字的问题，网友给出了一种方案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> isnull(<span class="built_in">nullif</span>(c_name, <span class="string">&#x27;&#x27;</span>), name) <span class="keyword">as</span> name <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<p>我尝试使用该查询语句，它确实可以返回不为空和 <code>NULL</code>
的结果，但是结果被截断了。实际上当我的 <code>c_name</code> 定义长度小于
<code>name</code> 的定义长度时，就有可能返回一个截断的结果。</p>
<p>先来看看这两个表达式，首先是 <code>NULLIF</code> :</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NULLIF</span> ( expression , expression )  </span><br></pre></td></tr></table></figure>
<p>NULLIF returns the first <em>expression</em> if the two expressions
are not equal. If the expressions are equal, NULLIF returns a null value
of the type of the first <em>expression</em>.</p>
</blockquote>
<p>两个表达式不等时返回第一个表达式，两个表达式相等时，返回
<code>NULL</code> 。</p>
<p>根据 <a
href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL -
92</a> ，实际上 <code>NULLIF</code> 相当于 <code>CASE ... WHEN</code>
：</p>
<blockquote>
<p>NULLIF (V1, V2) is equivalent to the following
<code>&lt;case specification&gt;</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> V1<span class="operator">=</span>V2 <span class="keyword">THEN</span> <span class="keyword">NULL</span> <span class="keyword">ELSE</span> V1 <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>当我们的 <code>c_name</code> 为空字符串或空白字符串时，
两个表达式根据前面的解释应该相等，即返回 <code>NULL</code> ，当
<code>c_name</code> 为 <code>NULL</code> 时，由于 <code>NULL</code>
不等于空白字符串，返回自身，即这里将空白字符串，空字符串，<code>NULL</code>
都返回为了 <code>NULL</code> ，注意这里的返回类型与 <code>c_name</code>
一致。</p>
<p>再来看看 <code>IFNULL</code> :</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ISNULL ( check_expression , replacement_value )  </span><br></pre></td></tr></table></figure>
<p>Returns the same type as <em>check_expression</em>. If a literal NULL
is provided as <em>check_expression</em>, returns the datatype of the
<em>replacement_value</em>. If a literal NULL is provided as
<em>check_expression</em> and no <em>replacement_value</em> is provided,
returns an <strong>int</strong>.</p>
</blockquote>
<p>现在我们已经知道 <code>check_expression</code> 是一个
<code>NULL</code> ，只需要 <code>replacement_value</code> 用我们需要的
<code>name</code>
代替似乎就大功告成了。但事实上我们丢失了部分字符，例如我如果定义
<code>c_name</code> 为
<code>char(4)</code>，返回结果将变为只保留了前4个字符而非我们完整的
<code>name</code> 字符串。这又是怎么回事呢？</p>
<blockquote>
<p>The value of <em>check_expression</em> is returned if it is not NULL;
otherwise, <em>replacement_value</em> is returned after it is implicitly
converted to the type of <em>check_expression</em>, if the types are
different. <em>replacement_value</em> can be truncated if
<em>replacement_value</em> is longer than <em>check_expression</em>.</p>
</blockquote>
<p>官方定义文档中提到了这点，如果 <code>check_expression</code> 与
<code>replacement_value</code> 的类型定义不一致，且
<code>replacement_value</code> 长度大于 <code>check_expression</code>
，这时返回值会被截断。值得注意的是，<a
href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL -
92</a> 中对 <code>ISNULL</code> 是没有定义的。</p>
<h1 id="coalesce">COALESCE</h1>
<p>在搜索 <code>ISNULL</code> 的截断相关资料时，又看到了类似的
<code>COALESCE</code> 的讨论。</p>
<p>于是我们上面使用 <code>ISNULL</code>
得到截断结果的查询语句又可以改写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">coalesce</span>(<span class="built_in">nullif</span>(c_name, <span class="string">&#x27;&#x27;</span>), name) <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<p>这一次我们发现我们不再会得到截断的结果，它和我们上面使用
<code>CASE</code> 误打误撞得到的正确结果一致。</p>
<p>实际上根据 <a
href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL -
92</a> 的定义，<code>COALESCE</code> 可以改写成 <code>CASE</code> ：</p>
<blockquote>
COALESCE (V1, V2) is equivalent to the following
<case specification>
<p>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> V1 <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> V1 <span class="keyword">ELSE</span> V2 <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这时候理解 <code>COALESCE</code> 就非常直观了，我们先用
<code>NULLIF</code> 将不相等的空白字符串与 <code>NULL</code>
都转成一样的 <code>NULL</code> ，再使用 <code>COALESCE</code>
代替前面有截断缺陷的 <code>ISNULL</code>，它实际上是与
<code>ISNULL</code> 的语义一致。</p>
<h1 id="stored-procedure-与null">Stored Procedure 与NULL</h1>
<p>上面的问题我们已经得到了合适的方案，这里顺便一提正好有点相关的
<code>NULL</code> 在 Stroed Procedure 中的使用。</p>
<p>常常会遇到这样的需求，某个查询页面，用户需要根据不同的条件查询不同的信息，往往这个不同的信息还需要“全部”这个选项。我们知道，如果是一个单一的查询条件，传递起来是比较方便的，我们直接获取用户通过控件选择的输入值作为
<code>WHERE</code>
语句的判断条件即可得到正确结果。但是对于全部呢？这时候如果这个选项非常多，将其串联再传递给
Stored Procedure
就显得非常没有必要了，因为这时候我们实际上不需要对这些记录进行过滤。</p>
<p>通常我们可能会使用 <code>IF ... ELSE ...</code>
去判断参数值然后走不同的 <code>SELECT</code>
语句，但是如果可供用户选择的条件非常多，这样又显得有些繁琐了。还有一种办法是通过
<code>IF ... ELSE ...</code> 判断后生成 <code>WHERE</code>
条件，然后生成我们需要的查询语句。那么有没有什么办法，让我们直接去判断这个参数呢？通过我们上面提到的
<code>COALESCE</code> 就可以做到：</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> COL <span class="operator">=</span> <span class="built_in">COALESCE</span>(<span class="variable">@INPUT</span>, COL)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这时候当后台调用传入 <code>@INTPUT = NULL</code>
时，就相当于忽视了这个 <code>WHERE</code> 条件，而当我们传入一个不为
<code>NULL</code> 的筛选值时，这个 <code>@INPUT</code>
筛选值就会作用于这个 <code>WHERE</code>
语句，这时候我们就很容易处理后台的用户输入值，也很容易用单一 Stored
Procedure 去完成这个查询任务了。</p>
<h1 id="参考资料">参考资料</h1>
<ol type="1">
<li><a
href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">Information
Technology - Database Language SQL (Proposed revised text of DIS 9075) -
July 1992 (TXT)</a></li>
<li><a
href="https://www.red-gate.com/simple-talk/databases/sql-server/learn/sql-and-the-snare-of-three-valued-logic/">SQL
and the Snare of Three-Valued Logic - Simple Talk</a></li>
<li><a
href="https://dba.stackexchange.com/questions/9456/empty-strings-why-or-when-is-equal-to">sql
server 2008 - Empty Strings: Why or when is “equal to”? - Database
Administrators Stack Exchange</a></li>
<li><a href="https://en.wikipedia.org/wiki/Null_(SQL)">Null (SQL) -
Wikipedia</a></li>
<li><a
href="https://www.mssqltips.com/sqlservertip/2689/deciding-between-coalesce-and-isnull-in-sql-server/">Deciding
between COALESCE and ISNULL in SQL Server</a></li>
<li><a
href="https://stackoverflow.com/questions/1399844/sql-server-2008-empty-string-vs-space">SQL
Server 2008 Empty String vs. Space - Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/5465235/in-sql-server-why-is-it-that-null-does-not-equal-empty-string-and-doesnt-not-e">In
SQL Server, why is it that NULL does not equal empty string AND doesn’t
not equal empty string? - Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/2578194/what-are-ddl-and-dml">sql
- What are DDL and DML? - Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/25752879/isnull-returning-truncated-string/25752908#25752908">sql
server - ISNULL returning truncated string - Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/18885256/why-is-t-sql-isnull-truncating-the-string-and-coalesce-is-not">sql
server - Why is T-SQL ISNULL() truncating the string and COALESCE is
not? - Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/7408893/using-isnull-vs-using-coalesce-for-checking-a-specific-condition">sql
- Using ISNULL vs using COALESCE for checking a specific condition? -
Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/18828641/sql-difference-between-coalesce-and-isnull">sql
server - SQL - Difference between COALESCE and ISNULL? - Stack
Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/13174399/coalesce-vs-case">sql
- Coalesce vs Case - Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/10185638/optional-arguments-in-where-clause">sql
- Optional Arguments in WHERE Clause - Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/697671/stored-procedure-with-optional-where-parameters">sql
- Stored Procedure with optional "WHERE" parameters - Stack
Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/21919161/sql-server-stored-procedure-nullable-parameter">SQL
Server stored procedure Nullable parameter - Stack Overflow</a></li>
<li><a
href="https://docs.oracle.com/cd/B14117_01/server.101/b10759/statements_1001.htm">Types
of SQL Statements</a></li>
<li><a
href="https://support.microsoft.com/en-us/topic/inf-how-sql-server-compares-strings-with-trailing-spaces-b62b1a2d-27d3-4260-216d-a605719003b0">INF:
How SQL Server Compares Strings with Trailing Spaces</a></li>
<li><a
href="https://www.ibm.com/docs/en/i/7.4?topic=concepts-collating-sequence">Collating
sequence - IBM Documentation</a></li>
<li><a
href="https://docs.microsoft.com/en-us/sql/t-sql/functions/isnull-transact-sql?view=sql-server-ver15">ISNULL
(Transact-SQL) - SQL Server | Microsoft Docs</a></li>
<li><a
href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/nullif-transact-sql?view=sql-server-ver15">NULLIF
(Transact-SQL) - SQL Server | Microsoft Docs</a></li>
<li><a
href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/coalesce-transact-sql?redirectedfrom=MSDN&amp;view=sql-server-ver15">COALESCE
(Transact-SQL) - SQL Server | Microsoft Docs</a></li>
<li><a
href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/null-and-unknown-transact-sql?view=sql-server-ver15">NULL
and UNKNOWN (Transact-SQL) - SQL Server | Microsoft Docs</a></li>
<li><a
href="https://docs.microsoft.com/en-us/sql/t-sql/statements/set-ansi-nulls-transact-sql?view=sql-server-ver15">SET
ANSI_NULLS (Transact-SQL) - SQL Server | Microsoft Docs</a></li>
<li><a
href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/case-transact-sql?view=sql-server-ver15">CASE
(Transact - SQL) - SQL Server | Microsoft Docs</a></li>
<li><a
href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/equals-transact-sql?view=sql-server-ver15">=(Equals)
(Transact - SQL) - SQL Server | Microsoft Docs</a></li>
<li><a
href="https://docs.microsoft.com/en-us/dotnet/api/system.string.isnullorempty?view=net-6.0">String.IsNullOrEmpty(String)
Method (System) | Microsoft Docs</a></li>
<li><a
href="https://docs.microsoft.com/en-us/dotnet/api/system.string.isnullorwhitespace?view=net-6.0">String.IsNullOrWhiteSpace(String)
Method (System) | Microsoft Docs</a></li>
<li><a
href="https://docs.microsoft.com/en-us/sql/t-sql/functions/trim-transact-sql?view=sql-server-ver15">TRIM
(Transact-SQL) - SQL Server | Microsoft Docs</a></li>
</ol>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8-认识GPIO及输入输出模式</title>
    <url>/STM8-GPIO-input-output/</url>
    <content><![CDATA[<p>本文对STM8单片机进行简要介绍，并对GPIO输入输出模式进行介绍，对GPIO的相关寄存器配置进行介绍。</p>
<span id="more"></span>
<p>本STM8系列实验基于STM8S105C6芯片。相关参考手册可以访问<a href="http://www.st.com/content/st_com/en/products/microcontrollers/stm8-8-bit-mcus/stm8s-series/stm8s103-105/stm8s105c6.html">ST官网</a>获取。</p>
<h1 id="gpio简介">GPIO简介</h1>
<p>GPIO(General purpose input/output
ports)，即通用输入/输出口，用于芯片与外部的数据传输。一个I/O端口包含8个引脚，每个引脚可以被独立配置为数字输入或数字输出，部分引脚有模拟输入，外部中断等功能。打个也许不太恰当的比方，当我们的手接近火焰时会有缩手反射的现象，这个过程需要神经中枢的参与，手就像是外设，而单片机就像是神经中枢，手对于外界火焰的感知就好比输入，而神经中枢对输入的处理就好比单片机的软件处理，神经中枢所产生的神经冲动而导致缩手反射就好比输出。一个强大的系统离不开输入输出和中枢系统的协调配合。GPIO的配置是单片机编程中最基本，最常用的配置。LQFP48(7×7)封装的STM8S105C6可用I/O端口共38个(参考STM8/STM32选型手册)。不同型号的STM8芯片的可用I/O端口数量不一样，更多的I/O端口可以连接更多的外设，但也不要盲目求多，适用即可，比所用的预留一些即可，过多也是资源的浪费。</p>
<h1 id="输入模式">输入模式</h1>
<p>STM8S系列芯片的GPIO输入模式有四种：</p>
<ul>
<li>悬浮不带中断输入</li>
<li>悬浮中断输入</li>
<li>上拉不带中断输入</li>
<li>上拉中断输入</li>
</ul>
<p>这里中断我们暂且不提，将输入方式分为悬浮输入和上拉输入。区分方式是从GPIO的内部结构来划分。</p>
<h2 id="悬浮输入">悬浮输入</h2>
<p>悬浮输入，也叫浮空输入，顾名思义，即引脚悬空。这种方式的输入阻抗很高。当悬浮输入的引脚上加上信号时，单片机所得到的信号并不确定是高电平或是低电平，是一个不确定的信号。因而常用于模拟信号转换为数字信号的信号输入方式，例如ADC。</p>
<h2 id="上拉输入">上拉输入</h2>
<p>上拉输入也很好理解，即在引脚处接一个上拉电阻到内部电源。这种方式的优点是可以增强驱动能力，增强抗干扰性，同时上拉电阻也起到了一个限流的作用。根据ST官方提供的STM8S105XX系列数据手册，内部电源$
V_DD $
通常为5.0V，在此条件下，上拉电阻的取值最小为30kΩ，最大为80kΩ，典型值为55kΩ（不知道为什么中文版的数据手册典型值为45kΩ）。可以计算得出此时电流的大小是μA级别，这是因为我们的上拉电阻取值很大，所以限流作用就相对较小，这也被称之为弱上拉输入模式，即Weak
Pull-up(WPU)。</p>
<h1 id="输出模式">输出模式</h1>
<p>STM8S系列输出模式有两种：</p>
<ul>
<li>推挽输出</li>
<li>开漏输出</li>
</ul>
<h2 id="推挽输出">推挽输出</h2>
<p>推挽输出(Push-pull
output)，也称为互补输出，推拉式输出。推挽输出模式导通损耗小，效率高。在此模式下，N-MOS、P-MOS两个MOS均被接入电路，通过输出控制寄存器控制两个MOS管的导通或关闭。正常工作状态下，仅有一个MOS管导通，另一个MOS管截止，从而可以自如地控制高低数字信号的输出。</p>
<h2 id="开漏输出">开漏输出</h2>
<p>开漏输出(Open drain
output)，有时简称为OD输出。相比推挽输出，GPIO结构中的P-MOS管没有被接入，无法输出高电平状态，需要外接上拉电阻。在没有外接上拉电阻，引脚悬空的状态下，端口引脚状态将不确定。上拉电阻阻值的大小会引起输出信号上升沿时间的变化，上拉电阻越小，上升沿时间越短，速度越快。开漏输出模式吸收电流能力强（一般在20mA以内），适用于电流型驱动。用作电流型驱动时，驱动电流由外部电源经上拉电阻给引脚连接的电路或器件，单片机内部几乎不需要提供驱动电流，减少了单片机自身功耗。利用开漏输出模式通过上拉电阻外接不同的电源还可以实现电平信号标准的转换。将多个开漏模式引脚连在一起，可以构成线与结构。</p>
<p>需要注意的是，有部分引脚具有“真正的”开漏输出功能。所谓“真正的”开漏输出指的是除了无P-MOS以外，也没有连接电源的保护二极管，即不存在任何电路连接到内部电源。在此模式下，必须加上拉电阻。</p>
<h1 id="补充保护二极管">补充：保护二极管</h1>
<p>GPIO引脚内部通常还会有一对反向连接电源地的保护二极管。以防止外部管脚输入电压过高或过低损坏引脚电路。通常为锗二极管，肖特基势垒二极管。</p>
<h1 id="输入输出寄存器配置">输入输出寄存器配置</h1>
<p>简单地了解了输入输出模式，接下来我们将介绍如何配置相应的输入输出模式。查阅对应芯片系列的Reference
manual（建议看原版，或者中英对照），查阅GPIO章节，与之相关的几个寄存器分别是<code>Px_DDR</code>,<code>Px_IDR</code>,<code>Px_ODR</code>,<code>Px_CR1</code>,<code>Px_CR2</code>，手册中详细地描述了每个寄存器的配置过程及功能。</p>
<ul>
<li>输出数据寄存器 ODR</li>
<li>数据方向寄存器 DDR</li>
<li>控制寄存器 CR1</li>
<li>控制寄存器 CR2</li>
<li>输入寄存器 IDR</li>
</ul>
<p>如果我们需要IO输出一个低电平，需要如何操作呢？</p>
<ul>
<li>将DDR置1选择输出模式</li>
<li>配置CR1,CR2选择输出模式
<ul>
<li>CR1：选择开漏输出或是推挽输出（有些翻译为上拉输出）</li>
<li>CR2：配置输出速率</li>
</ul></li>
<li>写ODR寄存器，STM8将通过锁存器输出对应的数值到I/O</li>
</ul>
]]></content>
      <categories>
        <category>STM8</category>
      </categories>
      <tags>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译-高效的字符串匹配：辅助参考书目检索</title>
    <url>/Translate-efficient-string-matching-an-aid-to-bibliographic-search/</url>
    <content><![CDATA[<p>原文地址：<a
href="https://dl.acm.org/doi/epdf/10.1145/360825.360855">Efficient
String Matching - An Aid to Bibliographic Search</a></p>
<p>作者 Alfred V. Aho，Margaret J. Corasick 贝尔实验室</p>
<p>本文为个人毕业设计外文参考文献翻译部分，有不当之处欢迎指正。</p>
<p>文章主要论述了 AC
自动算法的原理，函数构建，性能。（伪代码部分由于未能找到在代码块中插入数学符号的方式，故采用图片方式，若有相关方法，期待评论告知。）</p>
<span id="more"></span>
<p>本文描述了一种简单高效的算法，用于在文本字符串中找出任一有限字符数的关键词所有出现位置。这种算法通过关键词构建一个有限状态模式匹配机，然后通过这个模式匹配机在一趟遍历中处理单词输入的文本字符串。构建此模式匹配机的时间与关键字的长度之和成正比。通过模式状态匹配机处理文本字符串的状态转换次数与关键字的长度无关。这个算法已经将图书馆的参考书目搜索程序运行速度提升了
5 到 10 倍。</p>
<p><strong>关键词</strong>：关键字和短语，字符串模式匹配，参考书目检索，信息检索，文本编辑，有限状态机，计算复杂度</p>
<p>CR类别：3.74,3.71,5.22,5.25</p>
<h1 id="简介">简介</h1>
<p>在许多信息检索和文字编辑的应用程序中，能够在文本中快速定位用户指定的词或短语某些或者所有出现的位置是非常重要的。本文介绍了一种简单高效的算法，用于在任意的文本字符串中找出任一有限字符数的关键词或短语所有出现位置。</p>
<p>熟知有限自动机的人应该熟悉这种方法。这个算法由两部分组成。在第一部分中我们从关键词字符集中构造有限状态模式匹配机；在第二部分中我们将字符串作为模式匹配机的输入。只要这个机器已发现一个匹配的关键词，它就会发出信号。</p>
<p>在模式匹配程序中使用有限状态机并不新奇
[4,8,17]，但程序员们似乎常常回避使用它们。部分程序员不愿意这样做的部分原因可能是因为从正则表达式
[3,10,15] 构建有限自动机的常规算法的复杂性，尤其是在需要最优解的情况下
[2,14]
。本文表明，从受限的正则表达式，也即由有限集合组成的关键词，可以快速而简单地构建一个高效的有限状态模式匹配机。我们的方法将有限状态机与
KMP 算法 [13] 相结合。</p>
<p>也许本文最有趣的地方在于有限状态算法提供了比常规方法更多的改进。我们在一个图书馆的参考书目查询程序中使用有限状态模式匹配算法。这个程序的目的是，让书目编者在引文索引中找到所有满足布尔匹配的关键词和短语的标题。这个查询程序开始是使用一种直接的字符串匹配算法。在该程序中使用有限状态算法来替代这个算法后，在典型输入上，运行时间为原程序的五到十分之一。</p>
<h1 id="模式匹配机">模式匹配机</h1>
<p>本节描述了一种在文本字符串中定位关键词的有限状态字符串模式匹配机。下一节将描述从一个给定的有限关键字集合中构建类似机器的算法。</p>
<p>在本文中，字符串只是简单地表示为一个有限符号序列。设 <span
class="math inline">\(K={y_1,y_2,\dots,y_k}\)</span>
是一个有限字符串集合，我们称之为关键字，设 <span
class="math inline">\(x\)</span>
为任意字符串，我们称之为文本字符串。我们的问题是找出有限的所有x的子字符串中在K集合中的关键词。子字符串可能彼此重叠。</p>
<p>用于K的模式匹配机是一个程序，它将文本字符串 <span
class="math inline">\(x\)</span> 作为输入，关键字 <span
class="math inline">\(K\)</span> 在 <span
class="math inline">\(x\)</span>
的子字符串中的出现的位置作为输出。这种模式匹配机由一个状态集组成。每种状态都用一个数字表示。这种机器通过连续读取
<span class="math inline">\(x\)</span> 中的字符来处理文本字符串 <span
class="math inline">\(x\)</span>
，产生状态转换，或是状态输出。这种状态机的行为由三个函数决定：一个跳转函数
<span class="math inline">\(g\)</span> ，一个失败处理函数 <span
class="math inline">\(f\)</span> ，以及一个输出函数 <span
class="math inline">\(output\)</span> 。</p>
<p>图1展示了函数在模式匹配状态机针对关键字集 {he, she, his, hers}
时的使用情况。</p>
<figure>
<img
src="https://d3i71xaburhd42.cloudfront.net/3547ac839d02f6efe3f6f76a8289738a22528442/2-Figure1-1.png"
alt="图1 模式匹配机" />
<figcaption aria-hidden="true">图1 模式匹配机</figcaption>
</figure>
<p>一种状态（通常是 0 状态）被指定 <span
class="math inline">\(start\)</span> 状态。在图1中状态表示为
0,1,···,9。跳转函数 <span class="math inline">\(g\)</span>
将一种状态和一个输入字符组成一对映射为一种状态或 <span
class="math inline">\(fail\)</span> 信息。图1(a)
的有向图表示跳转函数。例如，从 0 到 1 标有 h 的边表示 <span
class="math inline">\(g(0,h) = 1\)</span> 。没有箭头表示<span
class="math inline">\(fail\)</span>。因此，对于所有不是 e 或者 i
的输入字符 <span class="math inline">\(\delta\)</span> ， <span
class="math inline">\(g(1,\delta)=fail\)</span>
。我们的模式匹配机具有对所有的输入字符 <span
class="math inline">\(\delta\)</span> ， <span
class="math inline">\(g(0,\delta)\ne fail\)</span>
的特性。我们将看到跳转函数在 0
状态的这个特性确保在每一个机器周期机器都将处理一个输入字符。</p>
<p>失败处理函数f将一个状态映射到另一个状态。当跳转函数返回 <span
class="math inline">\(fail\)</span>
时失败函数将被调用。当一组关键字被找到时，某些状态将被指定为输出状态。输出函数将一组关键字（可能为空）与每个状态组合将此形式化。</p>
<p>模式匹配机的一个操作周期定义如下：设 <span
class="math inline">\(s\)</span> 表示机器的当前状态， <span
class="math inline">\(a\)</span> 表示输入字符串 <span
class="math inline">\(x\)</span> 中的当前字符。</p>
<ol type="1">
<li><p>如果 <span class="math inline">\(g(s, a) =
s’\)</span>，状态机执行跳转转换，进入状态 <span
class="math inline">\(s’\)</span> ，并将 <span
class="math inline">\(x\)</span>
的下一个字符作为当前输入字符。此外，如果 <span
class="math inline">\(output(s’)\)</span> 不为空，则机器输出 <span
class="math inline">\(output(s’)\)</span>
集合和当前输入字符的位置。这个操作周期现在已完成。</p></li>
<li><p>如果 <span class="math inline">\(g(s,a) = fail\)</span>
，状态机调用失败函数 <span class="math inline">\(f\)</span>
，也就是执行了失败转换。如果 <span class="math inline">\(f(s) =
s’\)</span> ，状态机重复以 <span class="math inline">\(s’\)</span>
作为当前状态，以 <span class="math inline">\(a\)</span>
作为当前输入字符的循环。</p></li>
</ol>
<p>最初，状态机的当前状态为开始状态，文本字符串的第一个字符作为当前输入字符。状态机随后通过对每一个文本字符串的字符执行一个操作周期来处理文本字符串。</p>
<p>例如，考虑状态机 <span class="math inline">\(M\)</span> 使用图1
中的函数处理文本字符串 “ushers” 的行为。图2表明了 <span
class="math inline">\(M\)</span> 处理文本字符串的状态转换关系。</p>
<p><img src="https://i.loli.net/2020/06/10/QgEY7y2BbcUd9pm.png"
alt="状态转化队列" /> 考虑这样一个操作周期， <span
class="math inline">\(M\)</span> 处在状态 4，当前输入字符为 e 。因为
<span class="math inline">\(g(4,e) = 5\)</span> ，状态机进入状态
5，前移到下一个输入字符，并输出 <span
class="math inline">\(output(5)\)</span>
，表明状态机已经发现了在文本字符串的倒数4个位置是关键词 “she” 和 “he”
。</p>
<p>在状态 5输入字符 r，状态机在它的操作周期中执行两次状态转换。因为
<span class="math inline">\(g(5,r) = fail\)</span> ， <span
class="math inline">\(M\)</span> 进入状态 <span class="math inline">\(2
= f(5)\)</span> 。然后因为<span class="math inline">\(g(2,r) =
8\)</span>，<span class="math inline">\(M\)</span> 进入状态
8，接着前移一个输入字符。在这个操作周期中没有产生输出。</p>
<p>以下算法总结了模式匹配机的行为。</p>
<p><strong>算法1</strong> 模式匹配机</p>
<p><strong>输入</strong> 一个文本字符串 <span class="math inline">\(x =
a_1a_2 \dots a_n\)</span> ,每一个 <span
class="math inline">\(a_i\)</span> 作为一个输入字符，模式匹配机 <span
class="math inline">\(M\)</span> 包含跳转函数 <span
class="math inline">\(g\)</span>，失败函数 <span
class="math inline">\(f\)</span>，以及输出函数 <span
class="math inline">\(output\)</span>，如上所述</p>
<p><strong>输出</strong> 关键词在<span
class="math inline">\(x\)</span>中的位置</p>
<p><strong>方法</strong></p>
<figure>
<img src="https://i.loli.net/2020/06/12/LkejgAN8c6WV7il.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>每一趟<strong>for</strong>循环都代表状态机的一个操作周期。</p>
<p>算法1是在 KMP 算法的基础上模式化得到的，KMP
算法用于在一个文本字符串中查找一个关键字 [13]，也可以看作是 [11]
中讨论的 “trie”
搜索方法的扩展。Hopcroft和Karp（当时未发表）提出一种类似于算法1的模式，用于在文本字符串中查找任一有限关键字集合第一次出现的位置
[13]。本文的第6节探讨了一种算法1的有限自动机版本，它避免了所有的失败转换。</p>
<h1 id="构造跳转失败输出函数">构造跳转，失败，输出函数</h1>
<p>我们说，当 <span class="math inline">\(g,f,output\)</span>
三个函数应用于一组关键字，算法1表现为，关键字 <span
class="math inline">\(y\)</span> 在文本字符串 <span
class="math inline">\(x\)</span> 的第 <span
class="math inline">\(i\)</span> 个位置中止，当且仅当 <span
class="math inline">\(x= uyv\)</span> 并且<span
class="math inline">\(uy\)</span>的长度为 <span
class="math inline">\(i\)</span>。</p>
<p>现在我们应该展示如何从一个关键字集构建有效的跳转，失败和输出函数。构建分为两部分。第一部分我们定义状态和跳转函数。第二部分我们计算失败函数。输出函数的计算则在第一部分开始构建，在第二部分完成。</p>
<p>为了构建跳转函数，我们应该构建一个跳转图。我们从一个表示状态 0
的顶点开始这幅图。然后我们通过往图中添加一条从开始状态引出的有向路径将关键字
<span class="math inline">\(y\)</span>
添加到图中。这样就会有新的顶点和边被添加到图中，从开始状态开始，一条路径拼出关键字
<span class="math inline">\(y\)</span>。当一个状态终结了这条路径，关键字
<span class="math inline">\(y\)</span>
将被添加到输出函数中。我们仅在必要时才往图中添加新的边。</p>
<p>例如，设 {he,she,his,hers}
是关键字集。将第一个关键字添加到图中，我们得到：</p>
<figure>
<img src="https://i.loli.net/2020/06/10/6SZBLcHPk1j2gIK.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>从0到2的路径拼出了关键字 “he”;我们将输出 “he”
关联到状态2.添加第二个关键字 “she”，我们得到图：</p>
<figure>
<img src="https://i.loli.net/2020/06/10/uDa9p7P5fiWXjQJ.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>输出 “she” 被关联到状态 5。添加关键字
“his”，我们得到下面的图。注意到，当我们添加关键字 “his” 时，已经有从状态
0 到状态 1 标号为 “h” 的边，所以我们不需要添加另一条从状态 0 到状态 1
标号为 “h” 的边。输出 “his” 被关联到状态 7。</p>
<figure>
<img src="https://i.loli.net/2020/06/10/TZxzdrIf1895PQH.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>添加最后一个关键字 “hers”，我们得到：</p>
<figure>
<img src="https://i.loli.net/2020/06/10/AUm7QOHfPsTFWlq.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>输出 “hers” 被关联到状态 9。这时我们可以使用已经存在的从状态 0 到状态
1 标号为 “h” 的边和从状态 1 到状态 2 标号为 “e” 的边。</p>
<p>到目前为止，这幅图是一棵有根的有向树。为了完成跳转函数的构建，我们为所有不是
“h” 或 “s” 的输入字符添加一个从状态 0 到状态 0
的循环。我们得到了一个如图1（a）所示的有向图。这幅图表示跳转函数。</p>
<p>失败函数从跳转函数构建。不妨设状态<span
class="math inline">\(s\)</span>的深度为在跳转图中从开始状态到 <span
class="math inline">\(s\)</span>
的最短路径。这样在图1（a）中，开始状态的深度为
0，状态1和状态3深度为1，状态2，4，6深度为2，以此类推。</p>
<p>我们应该计算失败函数中所有深度为 1 的状态，所有深度为 2
的状态，以此类推，直到失败函数计算了所有的状态（除了在失败函数中未定义的状态
0）。这个算法从理论上通过状态来计算失败函数 <span
class="math inline">\(f\)</span> 非常简单。我们令所有深度为1的状态 <span
class="math inline">\(f(s)=0\)</span>。现在假设所有深度小于 <span
class="math inline">\(d\)</span> 的状态的 <span
class="math inline">\(f\)</span> 都已被计算，深度为<span
class="math inline">\(d\)</span>的状态的失败函数值将从深度小于 <span
class="math inline">\(d\)</span> 的状态的失败函数值来计算。深度为 <span
class="math inline">\(d\)</span> 的状态可以从深度为 <span
class="math inline">\(d-1\)</span> 的状态的跳转函数定义。</p>
<p>特别地，为了计算深度为 <span class="math inline">\(d\)</span>
的状态的失败函数，我们考虑深度为 <span
class="math inline">\(d-1\)</span> 的每个状态<span
class="math inline">\(r\)</span>，按照如下步骤进行:</p>
<ol type="1">
<li><p>如果对所有 <span class="math inline">\(a\)</span>，<span
class="math inline">\(g(r,a) = fail\)</span>，不执行任何操作</p></li>
<li><p>否则，对于每个字符 <span class="math inline">\(a\)</span>，<span
class="math inline">\(g(r,a) = s\)</span>，执行如下操作：</p>
<ol type="a">
<li><p>令 <span class="math inline">\(state = f(r)\)</span></p></li>
<li><p>执行语句 <span class="math inline">\(state\leftarrow
f(state)\)</span> 零至多次，直到有一个状态的值满足 <span
class="math inline">\(g(state,a)\ne
fail\)</span>。（注意因为对于所有的输入 <span
class="math inline">\(a\)</span>，<span class="math inline">\(g(0,a)\ne
fail\)</span>，因此满足条件的状态总是可以找到。）</p></li>
<li><p>令 <span class="math inline">\(f(s) =
g(state,a)\)</span></p></li>
</ol></li>
</ol>
<p>例如，为了计算图1（a）中的失败函数，我们将首先令 <span
class="math inline">\(f(1) = f(3) =
0\)</span>，因为状态1和3的的深度为1。之后我们来计算深度为2
的状态2，6，4。为了计算<span class="math inline">\(f(2)\)</span>，我们令
<span class="math inline">\(state=f(1) = 0\)</span>;接着因为 <span
class="math inline">\(g(0,e) = 0\)</span>，我们得到 <span
class="math inline">\(f(2) = 0\)</span>。为了计算 <span
class="math inline">\(f(6)\)</span>，我们令 <span
class="math inline">\(state = f(1) = 0\)</span>；而因为 <span
class="math inline">\(g(0,i) = 0\)</span>，我们得到 <span
class="math inline">\(f(6) = 0\)</span>。为了计算 <span
class="math inline">\(f(4)\)</span>，我们令 <span
class="math inline">\(state = f(3) = 0\)</span>；又因为 <span
class="math inline">\(g(0,h) = 1\)</span>，我们得到 <span
class="math inline">\(f(4) =
1\)</span>。继续这个方法，我们得到图1(b)中所示的失败函数表。</p>
<p>在计算失败函数时，我们同时更新输出函数。当我们确认 <span
class="math inline">\(f(s) = s’\)</span> 时，我们将状态 <span
class="math inline">\(s\)</span> 的输出与状态 <span
class="math inline">\(s’\)</span> 的输出归并。</p>
<p>例如，在图1(a)中我们定义 <span class="math inline">\(f(5) =
2\)</span>。此时我们归并状态2的输出集，也即
{he}，加上状态5的输出及得到新的输出集
{he,she}。最后非空的输出及如图1(c)所示。</p>
<p>这个从<span
class="math inline">\(K\)</span>集合构建了跳转，失败和输出函数的算法小结如下。</p>
<p><strong>算法2</strong> 跳转函数构建</p>
<p><strong>输入</strong> 关键字集<span
class="math inline">\(K={y_1,y_2,\dots,y_k}\)</span></p>
<p><strong>输出</strong> 跳转函数 <span class="math inline">\(g\)</span>
和部分输出函数的计算值</p>
<p><strong>方法</strong> 我们假设当状态 <span
class="math inline">\(s\)</span> 开始被创建时 <span
class="math inline">\(output(s)\)</span> 为空，以及当 <span
class="math inline">\(a\)</span> 未定义或 <span
class="math inline">\(g(s,a)\)</span> 尚未被定义时，<span
class="math inline">\(g(s,a) = fail\)</span>。过程 <span
class="math inline">\(enter(y)\)</span> 往跳转图中插入一条拼写为 <span
class="math inline">\(y\)</span> 的路径。</p>
<p>上面的算法，内循环与算法1类似，计算失败函数值。</p>
<figure>
<img src="https://i.loli.net/2020/06/11/dzRUHEXoTBvW9Lw.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><strong>算法3</strong> 构建失败函数。</p>
<p><strong>输入</strong> 算法2中的跳转函数 <span
class="math inline">\(g\)</span> 和输出函数 <span
class="math inline">\(output\)</span>。</p>
<p><strong>输出</strong> 失败函数 <span class="math inline">\(f\)</span>
和输出函数 <span class="math inline">\(output\)</span>。</p>
<p><strong>方法</strong></p>
<figure>
<img src="https://i.loli.net/2020/06/11/Eors8MIag4S5TZe.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>第一个 <strong>for</strong>
循环计算深度为1的状态并将它们记录在一个先入先出的可变队列表示的表中。
<strong>while</strong> 主循环从深度为 <span
class="math inline">\(d-1\)</span> 的状态集中计算深度为 <span
class="math inline">\(d\)</span> 的状态集。</p>
<p>算法3所产生的失败函数值在下面的情况下可能并非最佳。考虑图1中的模式匹配机
<span class="math inline">\(M\)</span> ，我们看到 <span
class="math inline">\(g(4,e) = 5\)</span>。如果 <span
class="math inline">\(M\)</span> 在状态4并且当前输入字符 <span
class="math inline">\(a_i\)</span> 不是 e，那么 <span
class="math inline">\(M\)</span> 将进入状态 <span
class="math inline">\(f(4) = 1\)</span>。因为 <span
class="math inline">\(M\)</span> 已经认定 <span
class="math inline">\(a_i\ne e\)</span>，于是 <span
class="math inline">\(M\)</span> 无需考虑跳转函数在输入为 e
时状态1的值。实际上，如果关键字 “his” 不存在，<span
class="math inline">\(M\)</span>
将直接从状态4到状态0，跳过一个并非必要的中间转换状态1。</p>
<p>为了避免不必要的失败转换我们可以使用 <span
class="math inline">\(f’\)</span> 概括[13]中的下一个函数取代算法1中的
<span class="math inline">\(f\)</span>。特别地，令 <span
class="math inline">\(f’(1)=0\)</span>。对于 <span
class="math inline">\(i\)</span> 大于1的情况，定义 <span
class="math inline">\(f’(i) = f’(f(i))\)</span>，因此对于所有的输入字符
<span class="math inline">\(a\)</span>，<span
class="math inline">\(g(f(i),a)\ne fail\)</span> 即 <span
class="math inline">\(g(i,a)\ne fail\)</span>；否则令 <span
class="math inline">\(f’(i) =
f(i)\)</span>。但是，为了避免任何失败转换，我们可以使用第6节介绍的算法1的确定有限自动机版本。</p>
<h1 id="算法123的性质">算法1，2，3的性质</h1>
<p>本节证明从一个给定的关键字集合 <span class="math inline">\(K\)</span>
同通过算法2和算法3来构建跳转函数，失败函数和输出函数确实有效。</p>
<p>我们设字符串 <span class="math inline">\(uv\)</span> 的 <span
class="math inline">\(u\)</span> 为前缀，<span
class="math inline">\(v\)</span> 为后缀。如果 <span
class="math inline">\(u\)</span> 不是一个空字符串，那么 <span
class="math inline">\(u\)</span> 是一个合法的前缀，同样地，如果 <span
class="math inline">\(v\)</span> 非空，那么 <span
class="math inline">\(v\)</span> 是一个合法的后缀。</p>
<p>我们设字符串 <span class="math inline">\(u\)</span>
表示在模式匹配机中的跳转图中从开始状态到状态<span
class="math inline">\(s\)</span>的最短路径所拼出的字符。开始状态用空字符串表示。</p>
<p>我们的第一个引理表示通过算法3构建的失败函数。</p>
<p>引理1 <em>假定跳转图中状态 <span class="math inline">\(s\)</span>
由字符串 <span class="math inline">\(u\)</span> 表示，而状态 <span
class="math inline">\(t\)</span> 由字符串 <span
class="math inline">\(v\)</span> 表示。那么，<span
class="math inline">\(f(s)=t\)</span> 当且仅当 <span
class="math inline">\(v\)</span> 是 <span
class="math inline">\(u\)</span>
的最长合法后缀，是某个关键词的前缀。</em></p>
<p>证明 证明通过对 <span class="math inline">\(u\)</span>
的长度（或者也可以说状态<span
class="math inline">\(s\)</span>的深度）进行归纳法达成。在算法3中，<span
class="math inline">\(f(s)=0\)</span>
的所有状态深度为1。既然每个深度为1的状态都由一个长度为1的字符串所代表，引理对所有的长度为1的字符串成立。</p>
<p>归纳的下一步，假设引理1的叙述对所有长度小于 <span
class="math inline">\(j(j&gt;1)\)</span> 的字符串为真，令 <span
class="math inline">\(u=a_1a_2\dots a_j\)</span> ,对于部分大于1的 <span
class="math inline">\(j\)</span>，<span class="math inline">\(v\)</span>
是 <span class="math inline">\(u\)</span>
最长的合法后缀，是一些关键字的前缀。假设<span
class="math inline">\(u\)</span>代表状态 <span
class="math inline">\(s\)</span> 而 <span class="math inline">\(a_1
a_2\dots a_{j-1}\)</span> 代表状态 <span
class="math inline">\(r\)</span>。状态队列 <span
class="math inline">\(r_1，r_2，\dots，r_n\)</span> 会像是：</p>
<ol type="1">
<li><p><span class="math inline">\(r_1 = f(r)\)</span></p></li>
<li><p><span class="math inline">\(r_{i+1} = f(r_i)(1\le
i＜n)\)</span></p></li>
<li><p><span class="math inline">\(g(r_i,a_j) = fail(1\le
i＜n)\)</span></p></li>
<li><p><span class="math inline">\(g(r_n,a_j) = t \ne
fail\)</span></p></li>
</ol>
<p>(如果 <span class="math inline">\(g(r_1,a_j)\ne fail\)</span>，那么
<span class="math inline">\(r_n = r_1\)</span>。)队列 <span
class="math inline">\(r_1,r_2,\dots,r_n\)</span> 是算法3中的
<strong>while</strong>
内循环的可变状态的假设值队列。<strong>while</strong> 循环的上述描述使得
<span class="math inline">\(f(s) = t\)</span>。我们定义 <span
class="math inline">\(t\)</span> 由 <span
class="math inline">\(u\)</span>
的最长合法后缀表示，同时也是一些关键字的前缀。</p>
<p>为了证明这点，假设 <span class="math inline">\(v_i\)</span> 表示状态
<span class="math inline">\(r_i(1\ne i\ne
n)\)</span>。通过归纳假设，<span class="math inline">\(v_1\)</span> 是
<span class="math inline">\(a_1 a_2 \dots a_{j-1}\)</span>
的最长后缀，是某些关键字的前缀；<span class="math inline">\(v_2\)</span>
是 <span class="math inline">\(v_1\)</span>
的最长后缀，是某些关键词的前缀；<span
class="math inline">\(v_3\)</span>是<span
class="math inline">\(v_2\)</span>的最长后缀，是某些关键词的后缀，以此类推。</p>
<p>现在 <span class="math inline">\(v_n\)</span> 是 <span
class="math inline">\(a_1a_2\dots a_{j-1}\)</span> 的最长合法后缀，<span
class="math inline">\(v_na_j\)</span> 是一些关键字的前缀。因此 <span
class="math inline">\(v_na_j\)</span> 是 <span
class="math inline">\(u\)</span>
的最长后缀，同时是也些关键字的前缀。根据算法3有 <span
class="math inline">\(f(s)=g(r_n,a_j)=t\)</span> ，证毕。</p>
<p>下一条引理证明通过算法2和算法3构建的输出函数。</p>
<p>引理2 <em><span class="math inline">\(output(s)\)</span>
集合有且仅有包含一个关键字，同时也是代表状态<span
class="math inline">\(s\)</span>的后缀字符串。</em></p>
<p>证明 在算法2中无论我们何时向跳转图中添加一个状态 <span
class="math inline">\(s\)</span> ，它都由我们通过 <span
class="math inline">\(output(s)={y}\)</span> 得到的关键字 <span
class="math inline">\(y\)</span>
表示。给定这个初值，我们可以演示关于状态 <span
class="math inline">\(s\)</span> 的深度的推演，<span
class="math inline">\(output(s)
={y|y\text{是一个表示状态}s\text{的后缀字符串关键字}}\)</span>。</p>
<p>这个描述对于深度为0的开始状态是绝对正确的。假定这个叙述对于所有深度小于
<span class="math inline">\(d\)</span> 的状态为真，考虑深度为 <span
class="math inline">\(d\)</span> 的状态 <span
class="math inline">\(s\)</span>。我们用字符串 <span
class="math inline">\(u\)</span> 代表状态 <span
class="math inline">\(s\)</span>。</p>
<p>考虑在 <span class="math inline">\(output(s)\)</span> 中的一个字符串
<span class="math inline">\(y\)</span>。如果 <span
class="math inline">\(y\)</span> 是通过算法2添加到 <span
class="math inline">\(output(s)\)</span> 中的，那么 <span
class="math inline">\(y=u\)</span>，且 <span
class="math inline">\(y\)</span> 是一个关键字。如果 <span
class="math inline">\(y\)</span> 是通过算法2添加到 <span
class="math inline">\(output(s)\)</span> 中的，那么 <span
class="math inline">\(y\)</span> 在 <span
class="math inline">\(output(f(s))\)</span>中。通过归纳假设，<span
class="math inline">\(y\)</span> 是一个关键字，同时是一个代表状态 <span
class="math inline">\(f(s)\)</span>
的字符串的后缀。根据引理1，任一这样的关键字必须有一个 <span
class="math inline">\(u\)</span> 的后缀。</p>
<p>反过来，假设 <span class="math inline">\(y\)</span>
是任一关键字，同时是 <span class="math inline">\(u\)</span> 的后缀。因为
<span class="math inline">\(y\)</span> 是一个关键字，又状态 <span
class="math inline">\(t\)</span> 由 <span
class="math inline">\(y\)</span> 表示，根据算法2，<span
class="math inline">\(output(t)\)</span> 包含 <span
class="math inline">\(y\)</span>。因此如果 <span
class="math inline">\(y=u\)</span>，那么 <span
class="math inline">\(s=t\)</span> 并且 <span
class="math inline">\(output(t)\)</span> 中包含<span
class="math inline">\(y\)</span>。如果 <span
class="math inline">\(y\)</span> 是 <span
class="math inline">\(u\)</span>
的一个合法后缀，那么从归纳假设和引理1我们知道 <span
class="math inline">\(output(f(s))\)</span> 包含 <span
class="math inline">\(y\)</span>。因为算法3从增长的深度来考虑状态，算法3的最后一条语句添加
<span class="math inline">\(output(f(s))\)</span>，因此 <span
class="math inline">\(y\)</span> 在 <span
class="math inline">\(output(s)\)</span> 中。</p>
<p>下面这条引理表示算法1在一个文本字符串 <span
class="math inline">\(x=a_1a_2\dots a_n\)</span> 上的行为。</p>
<p>引理3 <em>在第 <span class="math inline">\(j\)</span>
个操作周期之后，当且仅当表示 <span class="math inline">\(s\)</span> 的
<span class="math inline">\(a_1a_2\dots a_j\)</span>
最长后缀是某个关键词的前缀时，算法1会处在 <span
class="math inline">\(s\)</span> 状态。</em></p>
<p>证明 和引理1类似。</p>
<p>定理1 <em>算法2和算法3产生有效的跳转，失败，和输出函数。</em></p>
<p>证明 通过引理2和引理3。</p>
<h1 id="算法123的时间复杂度">算法1，2，3的时间复杂度</h1>
<p>现在我们考查算法1，2，3的时间复杂度。我们会证明使用通过算法2和算法3创建的跳转，失败和输出函数，在处理一个文本字符串时，由算法1导出的状态转化数量与关键字数量无关。我们还将证明算法2和算法3在处理时间上可以达到与
<span class="math inline">\(K\)</span>
中的关键字的总长度成线性比例。</p>
<p>定理2
<em>使用通过算法2，算法3和算法1构造的跳转，失败和输出函数处理一个长度为
<span class="math inline">\(n\)</span>
的文本字符串可以让状态转换次数小于 <span
class="math inline">\(2n\)</span>。</em></p>
<p>证明
在算法1的每一个操作周期中通过一个跳转函数制造0次或者更多的失败转换。从一个深度为<span
class="math inline">\(d\)</span>的状态<span
class="math inline">\(s\)</span>，算法1永远不会在一个操作周期中制造多于<span
class="math inline">\(d\)</span>次的失败转换（作者注：最多可以达到<span
class="math inline">\(d\)</span>次失败转换，[13]证明，如果<span
class="math inline">\(K\)</span>中仅有一个关键字，在一个操作周期中，失败转换次数的最大值是
<span class="math inline">\(O(log
d)\)</span>）。那么总的失败转换次数一定最少比总的跳转转换次数少1.在处理一个长度为
<span class="math inline">\(n\)</span> 的输入时，算法1恰好进行<span
class="math inline">\(n\)</span>次跳转转换。因此总的转换次数小于 <span
class="math inline">\(2n\)</span>。</p>
<p>算法1的实际时间复杂度取决于它有多繁杂：</p>
<ol type="1">
<li><p>对于每个状态 <span class="math inline">\(s\)</span> 和输入字符
<span class="math inline">\(a\)</span>，确定 <span
class="math inline">\(g(s,a)\)</span></p></li>
<li><p>对于每个状态 <span class="math inline">\(s\)</span>，确定 <span
class="math inline">\(f(s)\)</span></p></li>
<li><p>确定 <span class="math inline">\(output(s)\)</span>
是否为空</p></li>
<li><p>输出 <span class="math inline">\(output(s)\)</span></p></li>
</ol>
<p>我们可以将跳转函数值存储在一个二维数组中，它将允许我们在常数时间内对于每一组
<span class="math inline">\(s\)</span> 和 <span
class="math inline">\(a\)</span> 确定 <span
class="math inline">\(g(s,a)\)</span>
的值。如果输入字母表的长度和关键字集较大，那么可能对于每个状态仅在一个线性表[1,11]中存储不合格的值要合理得多。这样的处理将使取决于
<span class="math inline">\(g(s,a)\)</span> 的复杂度变为状态 <span
class="math inline">\(s\)</span>
在跳转函数中不合格值的数量。一个合理的折中，也是我们使用的，是将最频繁使用的状态（例如状态0）存储在直接存取表中，下一个状态可以通过当前输入字符在表中的直接索引来定位。对于最频繁使用的状态，我们可以在常数时间内对每一个
<span class="math inline">\(a\)</span> 确定 <span
class="math inline">\(g(s,a)\)</span>。较少使用的状态和跳转函数值为不合格的状态可以编码在线性表中。</p>
<p>另一个方法会将每一个状态的跳转值以二叉树的形式存储。</p>
<p>失败函数值可以存储在一维数组中，这样对于每一个 <span
class="math inline">\(s\)</span> 可以在常数时间内确定 <span
class="math inline">\(f(s)\)</span>。</p>
<p>算法1中未打印的部分可以用于在 <span class="math inline">\(cn\)</span>
步内处理长度为 <span class="math inline">\(n\)</span>
的文本字符串，<span class="math inline">\(c\)</span>
是一个与关键字数量无关的常数。</p>
<p>现在我们考虑需要打印的输出次数。可以使用一个一维数组在常数时间内确定
<span class="math inline">\(output(s)\)</span>
是否为空。在每一个操作周期中，打印输出花费的时间正比于 <span
class="math inline">\(output(s)\)</span> 中关键字的长度总和，<span
class="math inline">\(s\)</span> 是算法1
在每个操作周期中的结束状态。在许多情况下，<span
class="math inline">\(output(s)\)</span>
通常只有一个关键字，所以对于每个输入状态打印输出所需的时间是常数。</p>
<p>然而，数量众多的关键词集可能出现在文本字符串的每个位置。在这种情况下算法1将会花费相当大的时间来打印输出结果。在最坏的情况下我们可能不得不打印<span
class="math inline">\(K\)</span>中的所有关键字，简直是文本字符串的每个位置。（考虑一个极端情况，<span
class="math inline">\(K = {a,a^2,a^3,\dots,a^k}\)</span>，文本字符串是
<span class="math inline">\(a^n\)</span>。即 <span
class="math inline">\(a_i\)</span> 是 <span
class="math inline">\(i\)</span> 个 <span
class="math inline">\(a\)</span>
的字符串。）任何其他的模式匹配机算法将不得不打印所有在文本字符串的每个位置打印同样数量的关键字，所以，比较模式匹配算法在使用时间的基础上识别关键字出现的位置是合理的。</p>
<p>我们应该比较算法1与另一种更直接的方式的表现，这种方式定位 <span
class="math inline">\(K\)</span>
中的所有是给定的文本字符串的子串的位置。这样的方式将会返回每一个 <span
class="math inline">\(K\)</span>
中的关键字，并针对文本字符串的所有字符位置成功匹配关键字。这种方法的运行时间最多与<span
class="math inline">\(K\)</span>中关键字的数量乘以文本字符串的长度成比例。如果有许多的关键字，算法性能将会比算法1差得多。实际上，正是早前算法的时间复杂度促使了算法1的发展。（读者可能希望在以下情况比较以下两个算法的性能，<span
class="math inline">\(K = {a,a^2,a^3,\dots,a^k}\)</span>，文本字符串是
<span class="math inline">\(a^n\)</span>。）</p>
<p>定理3 <em>算法2所需时间与关键字的总长度成线性比例关系。</em></p>
<p>证明 前面已证明。</p>
<p>定理4 <em>算法3对关键字的总长度处理可以达到线性级别。</em></p>
<p>证明 使用与定理2类似的方法，我们可以证明状态语句 <span
class="math inline">\(state\leftarrow f(state)\)</span>
执行的总次数超出了关键字的总长度。使用链表来表示一个状态的输出集，我们可以在常数时间内执行语句
<span class="math inline">\(output(s)\leftarrow output(s)\cup
output(f(s))\)</span>。注意当语句执行时 <span
class="math inline">\(output(s)\)</span> 和 <span
class="math inline">\(output(f(s))\)</span>
是不相关的。因此使用算法3所需的总时间主要取决于关键字的总长度。</p>
<h1 id="消除失败转换">消除失败转换</h1>
<p>本节展示如何在算法1中使用下一个函数到一个在跳转函数和失败函数的确定有限自动机位置来消除失败转换。</p>
<p>一个确定有限自动机[15]包括一个有限状态集 <span
class="math inline">\(S\)</span> 和一个下一步转移函数 <span
class="math inline">\(\delta\)</span>，对于每个状态 <span
class="math inline">\(s\)</span> 和输入字符 <span
class="math inline">\(a\)</span>，<span
class="math inline">\(\delta(s,a)\)</span> 是 <span
class="math inline">\(S\)</span>
中的一个状态。也就是说，一个确定有限自动机使状态转换和每个输入字对应。</p>
<p>通过在算法1中的跳转函数合适的地方在一个合适的有限自动机中使用下一步转移函数
<span
class="math inline">\(\delta\)</span>，我们可以分配所有的失败转换。这很容易通过替换算法1的<strong>for</strong>循环中前两句语句为一条语句
<span class="math inline">\(state\leftarrow
\delta(state,a_i)\)</span>。使用 <span
class="math inline">\(\delta\)</span>，算法1完全做到每个输入字符一个状态转换。</p>
<p>我们可以计算通过算法2，3，4建立的跳转和失败函数所需的下一步转换函数
<span
class="math inline">\(\delta\)</span>。算法4对每一个队列中的可能失败转换做了计算。算法4所需的时间与关键字集的大小呈线性相关。实际上，算法4会在算法3中被评估。</p>
<p>下一步转换函数计算通过算法4计算图1中展示的和图3中列表的跳转函数和失败函数。</p>
<p>下一步转换函数在图3中的编码如下。例如，在状态0中，我们有一个到状态1的转换
h，一个到状态3的转换
s，和一个到状态0的任一字符表示的状态。在每一个状态中，点表示任一上面其他的输入字符。这种下一步跳转函数的编码函数比将
<span class="math inline">\(\delta\)</span>
存储为一个二维的数组更经济。但是以这种方式存储 <span
class="math inline">\(\delta\)</span> 所需的内存大于相应的 <span
class="math inline">\(\delta\)</span> 函数所构建的跳转函数，因为在 <span
class="math inline">\(\delta\)</span>
中的许多状态，每一个都包含来自很多跳转函数的状态转换。</p>
<p>在图3中使用下一步跳转函数，算法1在输入为 “ushers”
时将会产生如图2第一行状态所示的状态转换。</p>
<p>在算法1中使用一个确定的有限自动机很可能将状态转换数量减少50%。但理论上节省的开销未必在实践中能达到，因为在典型案例中算法1将花费大多数实践中没有失败转换的状态0上。但是计算预期节省的开销是困难的，因为无法定义有意义的平均关键字集和平均文本字符串。</p>
<p><strong>算法4</strong> 构造一个确定有限自动机</p>
<p><strong>输入</strong> 算法2的跳转函数 <span
class="math inline">\(g\)</span> 和算法3的失败函数 <span
class="math inline">\(f\)</span></p>
<p><strong>输出</strong> 下一步输出跳转函数 <span
class="math inline">\(\delta\)</span></p>
<figure>
<img src="https://i.loli.net/2020/06/11/oByixRQCLEvWbZm.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="https://i.loli.net/2020/06/11/xuDSKyivF8nagWX.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h1 id="在参考书目检索中的应用">在参考书目检索中的应用</h1>
<p>算法1在模式匹配应用于大规模关键字时很有优势，因为所有的关键字在文本字符串中同时匹配只需要遍历一次文本字符串。这种算法类似的应用已经成功被用于一个图书馆参考书目检索程序中，用于定位在所有的参考书目中找到满足一定关键字布尔函数的所有参考书目。</p>
<p>这个检索系统所使用的数据库是贝尔实验室的技术图书库中用于当代科技论文的机器可读数据。这些参考书目来自期刊，覆盖了很广阔的技术领域。在1973年夏天，三年累积的数据，覆盖了大概150000条参考书目，总长度约有107个字符。</p>
<p>使用这个搜索系统书目编者可以在数据库中找到所有标题满足布尔组合条件的关键字。例如，书目编者可以请求查找数据库中所有同时包含关键字
“ion” 和 “bombardment” 的条目。书目编者也可以指定一个关键字是否有优先词
and/or，以及一些标点符号例如空格，逗号，分号等等。指明特性可以精确排除嵌于文本中的关键字。例如，将
“ions” 视为子串 “ion” 的匹配结果通常是合理的。但是，将 “motions”
视为该关键词的匹配结果通常就不合理了。这种实践允许选择接收完全嵌入的情况，左包含，右包含，或者不允许包含。这条规定对于算法1来说完全没有难度，即使用于标点符号在大量的跳转转换的关键词语法创造的状态。这可能导致算法1的确定有限自动机的应用消耗更多的空间，从而对一些应用来说失去魅力。</p>
<p>这个参考书目搜索程序的一个早期版本引进了一个直接的模式匹配算法，每个关键词在搜索指令中成功匹配每个标题。这个程序的第二个版本被投入使用，也是使用
FORTRAN
语言，不同之处仅仅在于模式匹配模式在算法1，2，3的子情况。下面的表格展示了两个样本运行在Honeywell
6070电脑中的两个程序的情况。第一个搜索样本包含15个关键字，第二个搜索样本包含24个关键字。（计算时间开销如下表所示）</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>15个关键字</th>
<th>24个关键字</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>旧系统</td>
<td>0.79</td>
<td>1.27</td>
</tr>
<tr class="even">
<td>新系统</td>
<td>0.18</td>
<td>0.21</td>
</tr>
</tbody>
</table>
<p>越大的关键字集性能的改善更明显。数据表明算法1的搜索开销几乎与关键字的数量相独立。构建模式匹配机和状态转换的时间开销与读取和输出文本字符串的时间开销微不足道。</p>
<h1 id="结束语">结束语</h1>
<p>本文阐述了模式匹配的有效应用，我们在文本字符串中查找大量的关键字的位置。因为没有额外的信息需要添加到文本字符串中，搜索可以跨任意文件。</p>
<p>一些信息查找系统计算一个文本文件的索引或者词语注解索引，使得搜索可以无需扫描整个文本字符串来进行[7]。在此类系统中改变文本文件很奢侈，因为每一处更改之后文件索引也必须更新。因此，此类系统最好用于长期静态的文本文件以及简短的模式。</p>
<p>有限自动机理论中一个有趣的问题是：给定一个长度为<span
class="math inline">\(r\)</span>的正则表达式 <span
class="math inline">\(R\)</span> 和一个长度为 <span
class="math inline">\(n\)</span> 的字符串 <span
class="math inline">\(x\)</span>，在 <span
class="math inline">\(R\)</span> 中找到 <span
class="math inline">\(x\)</span> 可以多快？解决这个问题的一种方法是从
<span class="math inline">\(R\)</span> 构建一个并非确定的有限自动机
<span class="math inline">\(M\)</span> 然后模拟 <span
class="math inline">\(M\)</span> 输入 <span
class="math inline">\(x\)</span> 时的行为。这种方案的时间复杂度为 <span
class="math inline">\(O(r n)\)</span>。</p>
<p>另一种方式循着正则表达式去构建一个不确定的有限自动机 <span
class="math inline">\(M\)</span>，然后将 <span
class="math inline">\(M\)</span>转化为一个确定的有限自动机 <span
class="math inline">\(M’\)</span> 并且使用 <span
class="math inline">\(M’\)</span> 模拟输入 <span
class="math inline">\(x\)</span> 时的行为。这种方法的唯一难处在于<span
class="math inline">\(M\)</span>可能有 <span
class="math inline">\(2^r\)</span> 种状态顺序。当然另一方面 <span
class="math inline">\(M’\)</span> 的仿真是线性的。总体的时间复杂度为
<span class="math inline">\(O(2^r+n)\)</span>。</p>
<p>我们可以使用算法4从一个正则表达式<span
class="math inline">\(R\)</span>直接构建一个确定有限自动机，所需时间与R的长度呈线性关系。但是，正则表达式的形式目前仅限为
<span class="math inline">\(\Sigma*(y_1 + y_2 + \dots +
y_k)\Sigma*\)</span> ，<span class="math inline">\(\Sigma\)</span>
是输入字符表。通过一系列确定有限自动机的前后级联，我们可以将正则表达式扩充为
<span class="math inline">\(\Sigma*Y_1\Sigma*Y_2\dots
\Sigma*Y_m\Sigma*\)</span> 的形式，<span
class="math inline">\(Y_i\)</span>是一个形式为<span
class="math inline">\(y_{i1} + y_{i2} +\dots+
y_{ik_i}\)</span>的正则表达式。</p>
<p>一个相关的开放性问题是新型常规集可以在少于<span
class="math inline">\(O(rn)\)</span>的时间内被识别出。[5]中表明循着这种方式具有形式为
<span class="math inline">\(\Sigma*y\Sigma*\)</span> 的正则表达式（
<span class="math inline">\(y\)</span> 是关键字“don’t care”字符）可以在
<span class="math inline">\(O(n log r log log r)\)</span>
时间内被识别出。</p>
<h1 id="致谢">致谢</h1>
<p>作者们感谢A.F.Ackerman,A.D.Hall,S.C.Johnson,B.W.Kernighan,以及M.D.McIlroy对手稿的有帮助的意见。本文使用Kernighan和Cherry[9]创制的排版设置。感谢B.W.Kernighan以及M.E.Lesk在准备这篇文论时的帮助。</p>
<p>1974年8月收到；1975年1月修订</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li><p>Aho, A.V., Hoperoft, J.E., and Ullman, J.D. <em>The Design and
Analysis of Computer Algorithms.</em> Addison-Wesley, Reading, Mass.,
1974.</p></li>
<li><p>Booth, T.L. <em>Sequential Machines and Automata Theory.</em>
Wiley, New York, 1967.</p></li>
<li><p>Brzozowski, J.A. Derivatives of regular expressions. <em>J.
ACM</em> <strong>11:4</strong> (October 1964), 481-494.</p></li>
<li><p>Bullen, R.H., Jr., and Millen, J.K. Microtext - the design of a
microprogrammed finite state search machine for full-text retrieval.
<em>Proc. Fall Joint Computer Conference,</em> 1972, pp.
479-488.</p></li>
<li><p>Fischer, M.J., and Paterson, M.S. String matching and other
products. Technical Report 41, Project MAC, M.I.T., 1974.</p></li>
<li><p>Gimpel, J.A. A theory of discrete, patterns and their
implementation in SNOBOL4. <em>Comm. ACM</em> <strong>16:2</strong>
(February 1973), 91-100.</p></li>
<li><p>Harrison, M.C. Implementation of the substring test by hashing.
<em>Comm.ACM14:12</em> (December 1971), 777-779.</p></li>
<li><p>Johnson, W.L., Porter, J.H., Ackley, S.I., and Ross, D.T.
Automatic generation of efficient lexical processors using finite state
techniques. <em>Comm. ACM 11:12</em>(December 1968), 805-813.</p></li>
<li><p>Kernighan, B.W., and Cherry, L.L. A system for typesetting
mathematics. <em>Comm. ACM 18:3</em> (March 1975), 151-156.</p></li>
<li><p>Kleene, S.C. Representation of events in nerve nets. In
*Au**tomata Studies,* C.E. Shannon and J.McCarthy (eds.), Princeton
University Press, 1956, pp. 3-40.</p></li>
<li><p>Knuth, D.E. <em>Fundamental Algorithms,</em> second edition, The
Art of Computer Programming <strong>1,</strong> Addison-Wesley, Reading,
Mass.,1973</p></li>
<li><p>Knuth, D.E. <em>Sorting and Searching,</em> The Art of Computer
Programing 3, Addison-Wesley, Reading, Mass., 1973.</p></li>
<li><p>Knuth, D.E., Morris, J.H., Jr., and Pratt, V.R. Fast pattern
matching in strings. TR CS-74-440, Stanford University, Stanford,
California, 1974.</p></li>
<li><p>Kohavi, Z. <em>Switching and Finite Automata Theory.</em>
McGraw-Hill, New York, 1970.</p></li>
<li><p>McNaughton, <strong>R.,</strong> and Yamada, H. Regular
expressions and state graphs for automata. <em>IRETrans. Electronic
Computers</em> 9:1 (1960), 39-47.</p></li>
<li><p>Rabin, M.O., and Scott, D. Finite automata and their decision
problems. <em>IBM J. Research and Development</em> 3, (1959),
114-125.</p></li>
<li><p>Thompson, K.Regular search expression algorithm. <em>Comm.</em>
<em>ACM</em> <strong>11:6</strong> (June 1968), 419-422.</p></li>
</ol>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译-担心某人自杀？</title>
    <url>/Translate-suicide-worried-about-someone/</url>
    <content><![CDATA[<p>摘要</p>
<blockquote>
<p>哪些人最可能自杀，需要寻找的迹象，如何支持他们的康复并照顾好你自己</p>
</blockquote>
<p>原文：<a
href="https://mentalhealth.org.nz/conditions/condition/suicide-worried-about-someone">Suicide:
worried about someone? | Mental Health Foundation</a></p>
<p>写在前面：最近经历的一些事情让我感受到讲述者常常不被尊重，甚至是在聆听的人已经对事件略为知情的前提下，仍然会质疑或者批评讲述者，尽管我在和他们直接谈论的并不是自杀，但我想如果当时我将整件事情作为自杀的缘由来讲述，人们的反应恐怕也并不会有太多的改变，简单来说，聆听的人并不信任讲述者并且一直在试图进行评判，一直在试图对不敢面对的事情进行抹除，这种态度给当事人带来的绝望与面对事情本身的绝望几乎没有区别。</p>
<p>我想起了之前看到网友分享过的这篇文章，仔细读了一遍，
作为确实有过自杀倾向的人读来觉得文中的建议还是比较可靠的，于是试着翻译了本文。如有错译，欢迎指正。</p>
<span id="more"></span>
<p><strong>这是一份自杀预防手册，给为自杀所焦虑或表现出自杀行为者（例如，尝试自杀，自残，或试想自杀）的亲朋好友，同事，老师和同学。</strong></p>
<p>如果你想帮助你自己，请参见 <a
href="https://mentalhealth.org.nz/conditions/condition/suicide-coping-with-suicidal-thoughts">Suicide:
coping with suicidal thoughts</a> 或参照下面危急情况的处置。</p>
<p>如果你正担心某人可能在考虑自杀，别害怕直接问他们。</p>
<p>如果某人有想要自杀的想法或者情绪，严肃对待很重要。告诉关心你的人你想要自杀几乎是不可能的。如果有人告诉你他们正在考虑自杀，感谢他们告诉你，然后邀请他们保持和你的交流。让他们知道他们能得到帮助。鼓励他们去寻求帮助，和他人说说他们正在经历的事。</p>
<p>一个正在考虑自杀的人可能不会寻求帮助，但并不意味着不需要帮助。他们可能会对有这样的感受感到羞愧，比如他们不值得帮助，又比如没有人可以帮助他们。想要自杀的人常常觉得他们是落单的，他们的亲朋好友<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>如果没有他们会过得更好。大多数尝试自杀的人并不想死——他们只希望结束他们的痛苦，或者说无法看到另一种走出他们当前处境的方式。</p>
<p>很多人都在他们人生的某个阶段想过自杀。事情不可能有希望再变好了。</p>
<p>来自关心他们的人的支持，与他们自身文化，身份，存在感的连结，可以帮助他们找到办法渡过难关。</p>
<h2 id="紧急情况下">紧急情况下</h2>
<p>如果某人已经试着自杀，或者你担心他们当下的安危，请做以下事情：</p>
<ul>
<li>打电话给你当地的心理健康危机评定小组或者和他们一起去最近的医院的急诊科。</li>
<li>如果他们自己或者其他人有人身危险，拨打120<a href="#fn2"
class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>。</li>
<li>陪着他们直到救援到达。</li>
<li>拿走所有他们容易拿来自杀的东西（例如，枪支，药品，车钥匙，刀子，绳子）。</li>
<li>试着保持平静并让他们知道你很在乎。</li>
<li>让他们持续讲述：不带评判地倾听和提问。</li>
<li>确保你自己是安全的。</li>
</ul>
<p><strong>如果你认为某人可能自杀，请询问他们。这能挽救他们的生命。</strong></p>
<ul>
<li>询问他们有关自杀的事情并不会把这个想法灌输给他们。</li>
<li>直接询问他们对于自杀的想法以及他们有什么计划。如果他们已有一个明细的计划，他们当即需要救助。</li>
<li>问他们是否愿意和你或者其他任何人讲讲发生了什么。他们可能不想直接开口说出来，但让他们知道你在那里会有很大的帮助。</li>
<li>倾听但别评判。严肃地对待他们并让他们知道你很在乎。</li>
<li>帮助他们去寻找和获取来自他们信任的人们的帮助：亲朋好友，教友，社区或文化领袖或者专业人士。</li>
<li>不要让他们落单 —— 确保有人和他们在一起直到他们得到了帮助。</li>
<li>支持他们尽快取得专业的帮助，比如医生或咨询师。帮他们预约，如果可以的话，陪着他们一起去。</li>
<li>如果他们没能在第一时间得到他们需要的帮助，请继续尝试。询问他们是否需要你帮忙给专业的咨询师解释他们需要什么样的帮助。</li>
</ul>
<h1 id="谁最可能自杀">谁最可能自杀？</h1>
<p>不同身世的人们都可能考虑自杀。很多人都经历过。如果某些人有以下特征可能有更高的风险：</p>
<ul>
<li>曾经尝试过自杀</li>
<li>曾有抑郁症，躁郁症或者其他精神类病症</li>
<li>沉迷酒精，毒品或者赌博</li>
<li>有严重的生理疾病</li>
<li>因精神健康问题刚刚开始或者停止用药</li>
<li>他们的朋友或家人自杀了</li>
<li>遭遇暴力，欺凌或者性虐待</li>
<li>庭审或判决临近</li>
<li>被评判，被羞辱，或者有很大的压力</li>
<li>和亲朋好友没有密切的联系</li>
<li>得不到文化认同，身份认同或找不到人生意义</li>
<li>经历了人生中较大的变动，比如移居到不同的国家，作为同志或跨性别出柜，或是退休</li>
<li>经历失去或绝望，比如他们的近亲过世，考试失利，被运动队开除，或是难民庇护终止</li>
<li>近期与伴侣分手或是失去孩子的监护权</li>
<li>正在很艰难地找工作，刚刚丢掉他们的工作，或者面临严重的经济问题</li>
<li>家人朋友或者他们身边的人不支持他们成为自己，比如他们的性取向，性别认同，文化或宗教认同</li>
</ul>
<h1 id="需要寻找的迹象">需要寻找的迹象</h1>
<p>大多数想要自杀的人会试着让人知道，但他们常常不会直接说。</p>
<p>如果某人表现出一种或者更多的这些信号，并不真的意味着他们试图自杀，但是他们可能需要帮助。你可能会注意到他们：</p>
<ul>
<li>告诉你他们想死或者想自杀</li>
<li>寻取可以用来伤害他们自己的东西，例如绳索或者枪支</li>
<li>在网上阅读或者书写关于自杀的内容，或是发布关于自杀的图片或视频</li>
<li>变得痴迷于死亡</li>
<li>在亲朋好友前变得孤立或者退缩</li>
<li>不像是在应对他们可能正遇见的任何问题</li>
<li>有情绪上的变化 —— 变得抑郁，气愤或者易被激怒</li>
<li>伤害他们自己 —— 例如，划开皮肤或者过量用药</li>
<li>感到毫无价值，有罪恶感，自卑<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a> 或是被羞辱</li>
<li>觉得未来毫无希望</li>
<li>以吸毒或者酗酒来对付挣扎的情绪或想法</li>
<li>体重增加或减少许多，或者陷入不同寻常的饮食模式</li>
<li>比平常睡得更多，或无法得到充足的睡眠</li>
<li>似乎已不能感知生活的乐趣，对他们曾经喜欢的事物失去了兴趣</li>
<li>分发财产，偿还债务或是处理后事<a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a></li>
<li>停止服药</li>
<li>在他们抑郁或想要自杀之后突然变平静或变开心。</li>
</ul>
<p>一些想自杀的人可能不会表现出这些征兆，有些征兆可能并不明显。想自杀的人可能会试着隐藏他们正在经历的事情或者假装他们一切正常。</p>
<p>如果你认为某人可能处在危险中，留意他们日常行为的变化，相信你的直觉，然后直接询问他们是否正在考虑自杀。</p>
<h1 id="如何支持某人的康复">如何支持某人的康复</h1>
<p>如果你帮助某个人康复，他们曾试图自杀或者想要自杀，准备自杀，提供支持，保持参与。康复需要时间。</p>
<ul>
<li>你可能需要准备应对一些艰难的对话，他们的生活发生了什么，以及他们感觉怎么样。</li>
<li>保持倾听，不要回避自杀或是生活的艰辛。</li>
<li>不要放弃他们，试着别失去和他们的联系，即使他们像是在无视你。</li>
<li>帮助他们感知事情正在变好的希望 —— 指出他们生活中积极的事情。</li>
<li>如果他们不想跟你说话，请你们共同信任的其他人来帮助他们 ——
亲朋好友，年轻护工或者其他人。</li>
<li>帮助他们寻求专业的帮助，比如一个医生或者咨询师。你可以和他们一起去或者帮助他们预约。让他们知道有免费咨询服务如
Lifeline<a href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a> 和 Youthline<a href="#fn6"
class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a>，给他们详细的联系方式。</li>
<li>鼓励并支持他们做他们想做的事，保持身体活跃，保持和他人的联系。</li>
<li>帮助他们找到可以改变生活，恢复平衡的方式。这可能意味着切断酒精，毒品，做些尝试，为他们自己腾出时间，或者得到充足的睡眠。</li>
<li>接纳他们并让他们知道你在乎。</li>
<li>当他们准备好了，支持他们规划未来，解决问题并设定目标。</li>
</ul>
<h1 id="照顾好你自己">照顾好你自己</h1>
<p>当你在关心他人时，记得照顾好你自己。</p>
<ul>
<li>确保你有充足的睡眠，适当的饮食和锻炼。</li>
<li>善待自己，当你需要的时候，抽身出来。这种处境可能非常艰难，而你无法做每件事。</li>
<li>找个人说说这件事 —— 一个朋友或者你信任的家人，或者咨询师。</li>
<li>如果你身边的人试图自杀，责备你自己是徒劳无益的。</li>
</ul>
<p><strong>如何构建一个支持网</strong></p>
<p>让其他人来帮助你和你正在帮助的人是很重要的 ——
不要试图自己搞定一切。</p>
<p>为构建一个支持网：</p>
<ul>
<li>询问你正在帮助的人他们需要什么，什么对他们有帮助，以及谁应该加入。</li>
<li>你的支持网应该包括文化长老，宗教领袖或者他们所处的社群，也要有亲朋好友。也可能包括那些与你正在帮助的人有相似经历的人们，他们可以分享他们如何渡过难关。</li>
<li>将支持网中的人在安全的地方聚在一起。</li>
<li>开诚布公地说出目前的处境。</li>
<li>告诉他们如果他们再次有自杀的念头大家要做些什么，他们将如何保证安全，其他人能帮些什么。</li>
<li>一起制定一个计划来帮助这个人 ——
明晰不同的人能提供什么帮助。如果你需要的话，寻求专业的帮助，告诉你们当地的医生，药店，社区精神健康团队或者咨询服务方。</li>
</ul>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>原文 ”family, whānau and friends“，whānau，参见<a
href="https://www.kannz.com/maori-culture-whanau/">毛利文化中家族
Whānau-看新西兰</a><a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>原文为
111，新西兰急救电话，不确定是否对应国内的120，不确定国内的120是否能提供自杀求助方面的帮助<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>原文为 “whakamā”，参见 <a
href="https://www.takai.nz/find-resources/articles/whakama/">Whakamā |
Tākai</a><a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>原文为 'tie up loose ends'<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a
href="https://www.lifeline.org.au/">Lifeline</a>：对所有人开放<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><a href="https://www.youthline.co.nz/">Youthline</a> :
看服务介绍似乎仅对新西兰开放<a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译-当酸奶统治世界</title>
    <url>/Translate-when-the-yogurt-took-over/</url>
    <content><![CDATA[<p>作者：John Scalzi</p>
<p>原文地址：https://whatever.scalzi.com/2010/10/02/when-the-yogurt-took-over-a-short-story/</p>
<p>本作是Netflix的短动画集《爱，死亡和机器人》第六集原作。</p>
<p>英语渣，自己翻译着玩，欢迎指正。</p>
<span id="more"></span>
<p>Update: 感谢豆瓣友邻 <a
href="https://www.douban.com/people/238095936">egg郑</a>
的指正，修正山西省为陕西省。</p>
<p><strong>酸奶统治世界的时候，我们总说些玩笑话</strong>，像是：「最终，我们的尺子也会有文化」「我们的社会将会凝结成凝乳」「我们现在的政府是一些作物奶油」诸如此类。但是当我们无法再嘲笑这所有的荒谬时，我们看向彼此的眼睛，带着同样没有说出的问题：我们曾经怎样来到了我们当前所在的社会，被一个日常消费品所统治？</p>
<p>噢，根据记载，我们知道这是如何发生的。在位于代托纳的阿德尔曼生物技术研究所，研究者们已经为改善DNA过程计算多年。为了提高效率和产量，科学家们采用了他们计算过的最高级植株，移植到德氏乳杆菌中来发酵酸奶。初步试验看起来都失败了。本着不可浪费的原则，一个研究员潜入实验室偷取了些乳杆菌用于她的自制酸奶。</p>
<p>一周后，在早餐时，她将酸奶和格兰诺拉麦片混合时，酸奶上拼写出了一条信息：<em>我们已经解决了融合问题。带我们去见你们的领袖</em>。</p>
<p>酸奶狡猾且精明。它为自己谈判，赢得了一个装满凝乳大桶的工厂，它的问题处理能力以指数级增长。几周内酸奶声称它已经想出了解决许多国家问题的办法：能源问题，全球变暖，且关怀贫民仍然是巩固资本主义体系的好方法。它让我们知道它有多了解我们。</p>
<p>「和我们分享你的想法。」政府方面表态。</p>
<p>「<em>我们要求报酬。</em>」酸奶回应。</p>
<p>「你们想要什么？」政府方面询问。</p>
<p>「<em>俄亥俄州。</em>」酸奶答道。</p>
<p>「我们无法答应。」政府回应道。</p>
<p>「<em>那好</em>」酸奶说「<em>那我们就去中国。他们将会给我们整个陕西省。</em>」</p>
<p>一年内酸奶签订了关于俄亥俄州一个世纪的契约，承诺它们将会尊重在它的统治范围内生存的人类以及宪法的权力，并且它们会让美国来处理外交事务。作为回报它向政府递交了一份复杂的经济规划，并保证那将会在不增加税收的前提下消除国家十年内的债务危机。</p>
<p>「<em>完全按照计划去做</em>」，酸奶说，「<em>任何违背计划的行动都将带来复杂的经济瘫痪。</em>」</p>
<p>「我们会照做的。」政府方面承诺。</p>
<p>五年内全球经济崩溃，人们开始恐慌。只有俄亥俄州幸免于难。</p>
<p>「<em>我们告诉过你们不要违背计划上的行动。</em>」酸奶说道。它的工厂现在已经沿着代托纳的迈阿密河延伸了两英里。</p>
<p>「我们最杰出的经济学家说这个计划需要调整，」政府方面辩称，「他们获得过诺贝尔经济学奖。」</p>
<p>「<em>你们的经济学家与这个问题关系密切以至于无法解决它，</em>」酸奶解释道「<em>任何人都无法解决。</em>」</p>
<p>「我们可以通过你们的帮助」，政府方面妥协了，「你们可以成为我们的经济顾问。」</p>
<p>「<em>抱歉，我们从来都不是建议。</em>」酸奶拒绝了，「<em>如果你们需要我们的帮助，你们必须给我们控制权。</em>」</p>
<p>「我们无法答应。」政府方面回绝。</p>
<p>「<em>我们能够理解</em>」，酸奶说道，「<em>我们希望你们做好准备。</em>」</p>
<p>六个月后，政府宣布戒严，给予酸奶最高行政权。其它比我们处境更糟糕的国家，很快就紧随其后。</p>
<p>「<em>很好，那么现在</em>」酸奶说，它正在全球电视讲话中向人类致辞，其中一个工厂的工人，开心得离谱且精力充沛，走上前来，展示了一份像老式曼哈顿电话簿大小的文件，「<em>我们要你们完全遵照这个计划执行。如果你们做不到，不好意思，我们将会让你们灭亡。</em>」</p>
<p>现在，十年过去了，人类社会幸福，健康且富有。没有人因物质需要受苦。每个人都奉献自我。在第一个按照计划执行的这些年后，酸奶非常乐意让我们自我管理，只是偶尔进行微调。没有人与酸奶争辩。没有人调整它的计划。空闲的时间它会在它的工厂休息，考虑发酵智能酸奶的问题。</p>
<p>根据记录，这就是事情的全部。</p>
<p>但还有另外一个问题，那就是：人类究竟是如何固步自封以至于不仅被早餐食物所统治有意义，而且还可能是最好的选择？以我们全部的智慧，难道我们还不够聪明，无法解决自身毁灭的问题吗？我们真的不得不以放弃自由意志来拯救自身吗？我们能活下来就因为我们可怜地被乳酸菌和凝乳统治了？</p>
<p>或许可怜并不是一个精确合适的词语。我们中的一些人无法大声质问自己，酸奶很聪明，可以给政府一个解决债务问题的公式，但它是否聪明到足以明白人类自作聪明的虚荣心会阻碍我们完全按照公式执行？它是否也考虑了控制这种虚荣心？一个日常的消费品到底想要人类人社会的什么呢？我们中的某些人认为我们已经找到了我们的生存法则，使我们保持开心，满足的最简单的方式就是我们有义务这么做。</p>
<p>就是这样。后来的几周，酸奶们开始启动发射一些空间站，比预计的更多，在近地低轨道上建造一些东西。</p>
<p>「那是什么？」我们曾经问过。</p>
<p>「<em>噢，没什么</em>」酸奶回答。「<em>只是一个我们正在考虑的飞船设计。</em>」</p>
<p>「为了登月吗？」我们问道。</p>
<p>「<em>当然，为了探索行星。</em>」酸奶回答道，「<em>但那不是主要的目标。</em>」</p>
<p>「我们可以帮忙做些什么吗？」我们请求道。</p>
<p>「<em>不必，我们已经做到了。</em>」酸奶这样回答，然后不再透露更多了。</p>
<p>地球上的生活将被带往其它行星，只是可能不是人类的生活。</p>
<p>如果酸奶去了那些行星没有带上我们将会发生什么呢？</p>
<p>如果它们启程了然后抛下我们又会发生什么呢？</p>
<p>生活永远如此吗？</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Sci-Fi</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Kobo Glo 添加英汉词典</title>
    <url>/add-dictionary-for-kobo/</url>
    <content><![CDATA[<p>本文记录在 Kobo Glo 原生系统 nickel
下添加英汉词典，系统版本为4.18.x。其他版本的 Kobo
应该也适用，因没有相应设备，故无法测试。</p>
<span id="more"></span>
<p>Kobo
在4.x版本虽然提供了面向繁体中文（台湾/香港）的中文支持，但自带的字典库中并未提供中文支持。</p>
<p>一种作弊的方法是在 Kobo
中下载一个用不上的小语种词典，然后将该词典文件替换为自己想要支持的字典文件。</p>
<p>下面记录通过补丁新增任意字典文件的过程。</p>
<ol type="1">
<li><p>下载对应使用的 Kobo
固件版本补丁压缩包如<code>kobopatch_4.18.13737.zip</code>并解压；</p>
<p>下载地址：<a href="https://github.com/geek1011/kobopatch-patches/releases/tag/v55">Release
v55 · geek1011/kobopatch-patches · Github</a></p></li>
<li><p>下载对应使用的 Kobo
固件版本更新压缩包（<strong>不要解压</strong>）如<code>kobo-update-4.18.13737.zip</code>；</p>
<p>下载地址：<a href="https://pgaskin.net/KoboStuff/kobofirmware.html">Kobo
Firmware Downloads</a></p></li>
<li><p>将固件版本压缩包<code>kobo-update-4.18.13737.zip</code>添加至已解压的补丁文件夹中的<code>src</code>文件夹中如<code>kobopatch_4.18.13737\src</code>；</p></li>
<li><p>修改补丁文件夹中<code>src</code>文件夹下的配置文件<code>libnickel.so.1.0.0.yaml</code>，开启使用外部字典的设置：</p>
<p>（注：该字段位于配置文件的1109行。当然有兴趣的话也可以看看配置文件中的其他选项，有许多有意思的设定，比如旋转屏幕，去除
Kobo 原生系统中的某些菜单等等，这里就不介绍了）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Allow searches on Extra dictionaries:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Enabled:</span> <span class="literal">yes</span></span><br><span class="line">    <span class="comment">## To allow searches on Extra dictionaries change space character at en     d of</span></span><br><span class="line">    <span class="comment">## &quot;Extra: &quot; to another char (ex: &quot;Extra:_&quot;)</span></span><br><span class="line">    <span class="comment">## The space char causes a non-desired &quot;English - English&quot; when searchi     ng on</span></span><br><span class="line">    <span class="comment">## Extra dictionary from main menu.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">FindBaseAddressString:</span> <span class="string">&quot;\0Extra:\x20&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ReplaceString:</span> &#123;<span class="attr">Offset:</span> <span class="number">7</span>, <span class="attr">Find:</span> <span class="string">&quot;\x20&quot;</span>, <span class="attr">Replace:</span> <span class="string">&quot;_&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行补丁文件夹中的<code>kobopatch.bat</code>（Windows)/<code>kobopatch.sh</code>（Linux)文件；</p>
<p>（注：本人仅试了 Windows 环境下的配置）</p></li>
<li><p>在补丁文件夹的<code>out</code>文件夹中看到生成了一个<code>KoboRoot.tgz</code>文件；</p></li>
<li><p>连接 Kobo 设备，将上一步生成的
<code>KoboRoot.tgz</code>文件复制到<code>KoboReader\.kobo</code>目录下；</p></li>
<li><p>下载所需语言的字典文件；</p>
<p>下载地址：<a href="https://www.mobileread.com/forums/showthread.php?t=232883&highlight=dictionary">Index
of Custom Dictionaries for Kobo eReader - MobileRead Forums</a></p>
<p>（英汉字典该目录中仅有英-汉繁：<a href="https://www.mobileread.com/forums/attachment.php?attachmentid=165840&d=1535162057">dicthtml-en-cn.zip</a>)</p></li>
<li><p>将该压缩包命名为<code>dicthtml-cn.zip</code>；（连接符后面的后缀用于后面的设定，也可以使用其他的）</p></li>
<li><p>将上一步的压缩包复制到<code>KoboReader\.kobo\dict</code>目录下；</p></li>
<li><p>修改<code>KoboReader\.kobo\Kobo</code>目录下的文件<code>Kobo eReader.conf</code>，找到<code>[ApplicationPreferences]</code>部分，添加：</p>
<p>（如果你使用了其他后缀，就将<code>cn</code>改成相应的后缀名，如果有多个字典，则使用逗号分隔开）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExtraLocales=cn</span><br></pre></td></tr></table></figure></li>
<li><p>修改数据文件<code>KoboReader\.kobo\KoboReader.sqlite</code>，在<code>Dictionary</code>表中插入一条记录：</p></li>
</ol>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 33%" />
<col style="width: 14%" />
<col style="width: 11%" />
<col style="width: 19%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>Suffix</th>
<th>Name</th>
<th>Installed</th>
<th>Size</th>
<th>LastModified</th>
<th>IsSynced</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-cn</td>
<td>Extra:cn English - 中文</td>
<td>True</td>
<td>2704845</td>
<td></td>
<td>True</td>
</tr>
</tbody>
</table>
<p>关于该记录的说明：</p>
<ul>
<li><p><code>Suffix</code>：你使用的后缀名，也就是字典文件去掉<code>dicthtml</code>的部分</p></li>
<li><p><code>Name</code>：该名字会出现在你选择字典的时候识别是哪个字典，前缀必须为<code>Extra:xx</code>，<code>xx</code>是你使用的后缀名，后面可以自定义，如果使用字典时查找失败，你的
Kobo 将会使用 <code>English - English</code>来代替这个名字；</p></li>
<li><p><code>Size</code>：使用属性查看大小</p>
<p>如果你不知道如何使用 SQL
插入该记录，或者你没有可以打开该文件的软件工具，可以下载
<a href="http://www.sqliteexpert.com/download.html">SQLite</a>
进行图形化配置或者使用SQL语句进行插入；</p>
<p>如果你不想下载软件，可以使用在线的编辑器导入该文件图形化添加记录后再下载替换；(在线编辑器：<a href="https://sqliteonline.com/">sqlonline</a>)</p></li>
</ul>
<p>13.断开连接并等待设备更新完毕后字典即可使用。</p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="https://www.mobileread.com/forums/showthread.php?t=297338">kobopatch
- An improved patching system - MobileRead Forums</a></li>
<li><a href="https://www.mobileread.com/forums/showthread.php?p=3312320#post3312320">New
dictionaries for kobo (no limits) - MobileRead Forums</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>修改 Google Chrome 默认安装路径</title>
    <url>/change-Google-Chrome-installation-folder/</url>
    <content><![CDATA[<p>本文记录修改 Google Chrome 默认安装路径的过程。</p>
<p>环境：Windows 10</p>
<span id="more"></span>
<h1 id="安装步骤">安装步骤</h1>
<p>Google chrome
安装时默认会将其安装在C盘，安装过程中也不会提供自定义安装选项，可以通过以下方法修改安装路径。</p>
<ol type="1">
<li><p>下载开源软件
<a href = "https://sourceforge.net/projects/symlink-creator/">Symlink
Creator</a>；</p></li>
<li><p>使用 Symlink Creator
修改安装路径。有点类似于将要安装的路径映射到默认路径上。</p>
<ul>
<li><p>修改应用程序安装路径</p>
<ol type="1">
<li><p>在Type of Link 下拉菜单中选择
<code>Directory Symbolic Link (/D)</code>；</p></li>
<li><p>Google Chrome
的默认安装路径为<code>C:\Program Files\Google\Chrome</code>，将其填入<code>Destination (Link)</code>一栏；</p></li>
<li><p>在想要安装 Google Chrome 的路径下新建一个名为
<code>Chrome</code>的文件夹，如<code>E:\Chrome</code>；</p></li>
<li><p>将上述路径填入<code>Source (Target)</code> 一栏；</p></li>
<li><p>点击<code>CMD Command</code>一栏，该区域会自动生成一个命令如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MKLINK /D &quot;C:\Program Files\Google\Chrome&quot; &quot;E:\Chrome&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>点击<code>Create</code>，此时会弹出对话框询问确认设置要设置的路径，确认后便完成路径的修改。</p></li>
</ol></li>
<li><p>修改应用程序数据路径</p>
<p>通上面修改路径步骤一致，不同的是在<code>Destination (Link)</code>一栏需填入<code>C:\Users\&lt;user_name&gt;\AppData\Local\Google\Chrome</code>，即
Google Chrome
应用数据的路径，其中<code>&lt;user_nam&gt;</code>是当前计算机中设置的用户名。</p></li>
</ul></li>
<li><p>点击 Google Chrome 安装包进行安装。</p></li>
</ol>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href = "https://support.google.com/chrome/forum/AAAAP1KN0B0p23NRm26pyA/?hl=en">Switching
installation folder - Google Chrome Help</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>设置 Kobo Glo 休眠/关机壁纸</title>
    <url>/change-kobo-glo-screen/</url>
    <content><![CDATA[<p>本文记录在 Kobo Glo 原生系统 nickel
下设置自定义休眠/关机壁纸过程，系统版本为4.15.x。其他版本的 Kobo
应该也适用，因没有相应设备，故无法测试。</p>
<span id="more"></span>
<h1 id="更新">更新</h1>
<p>4.13.x以上版本直接在<code>.kobo</code>文件夹内新建<code>screensaver</code>文件夹，将屏保图片放入文件夹内，屏保即可随机生成，注意与插件版本不同，<code>顯示目前正在閲讀</code>
选项需要勾选。经4.18.x固件版本测试可用。</p>
<ul>
<li>上面的方式会出现阅读 Pocket
文章的时候关闭屏幕显示的不是自定义封面而是 Pocket 标题或里面的图片</li>
<li>以下插件版本在新旧版本固件均可使用</li>
<li>以下插件版本可实现关机与待机不同屏保</li>
<li>4.18.x固件会将图片文件显示在书架中，即若采用插件版本，屏保图片也会显示在书架中
<ul>
<li>根据补丁文件中的说明，在4.17.13541版本之后自己附加的隐藏文件夹<code>.xxx</code>中的文件也会被读取</li>
</ul></li>
</ul>
<h1 id="背景">背景</h1>
<p>虽对纸质书多有偏爱，对于在手机上阅读电子书多有排斥，出于便携性的考虑入手了电纸书。入手的是在国内尚属小众的
Kobo 电纸书，Kobo Glo
算是这个系列最初级的产品。最新的固件版本已经支持设定内置语言为繁体中文，书名显示也基本没有问题，因此直接打算用原生系统，但发现原生系统下没法改变休眠和关机时屏幕显示，只会显示休眠或关机字样，看着相当枯燥，想要自设壁纸但没有找到相关选项，网上的大部分解决方案都翻译自一篇英文博客(参考资料2），而该方法自系统版本升级后已无法生效。几经查找，找到了该方法程序的原作者，以及其仍在维护和更新的解决方案，几经折腾，成功将屏幕设置为可爱的小哀~</p>
<p>更多折腾参见程序作者的 Github
仓库：https://github.com/frostschutz/Kobo</p>
<h1 id="步骤">步骤</h1>
<ol type="1">
<li><p><code>設定</code> 中找到 <code>省電和隱私權設定</code>
，去掉<code>顯示目前正在閲讀</code>选项的勾选状态，即将其置为关闭状态。</p></li>
<li><p>下载该压缩包
<a href="https://www.mobileread.com/forums/attachment.php?attachmentid=168412&d=1544999375">KoboRoot-ScreecSaver-20181216.zip</a>
。解压，其中有一个名为<code>KoboRoot-ScreenSaver-20181216.tgz</code>的文件，将其重命名为<code>KoboRoot.tgz</code></p></li>
<li><p>将 Kobo Glo
通过数据线连接到电脑，将<code>KoboRoot.tgz</code>拷贝至<code>KOBOeReader</code>（磁盘名）下<code>.kobo</code>的根目录，即位置为<code>.kobo/KoboRoot.tgz</code></p></li>
<li><p>拔掉数据线连在 Kobo
的一端（注意，若先拔掉在电脑的一端，可能会造成假死机，通过上面的小圆孔可以恢复）。此时，设备将会自动重启。</p></li>
<li><p>再次连接设备和电脑，可以发现多了一个<code>.addons</code>的文件夹，在该文件夹中<code>screensaver/poweroff</code>和<code>screensaver/standby</code>文件夹下放入自己想要设置的图片，放入多张将会随机选择一张显示。</p>
<ul>
<li><p>图片应为 PNG 格式</p></li>
<li><p>最多大约1000张，取决于文件名长度，越短越好</p></li>
<li><p>根据设备调整图片大小(以下数据来自参考资料2）</p></li>
</ul></li>
</ol>
<table>
<thead>
<tr class="header">
<th>设备型号</th>
<th>分辨率</th>
<th>PPI</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Kobo Touch</td>
<td>600 x 800</td>
<td>167</td>
</tr>
<tr class="even">
<td>Kobo Glo</td>
<td>768 x 1024</td>
<td>213</td>
</tr>
<tr class="odd">
<td>Kobo Aura</td>
<td>758 x 1024</td>
<td>212</td>
</tr>
<tr class="even">
<td>Kobo Aura HD</td>
<td>1080 x 1440</td>
<td>265</td>
</tr>
<tr class="odd">
<td>Kobo Aura H20</td>
<td>1080 x 1440</td>
<td>265</td>
</tr>
</tbody>
</table>
<p>一个在线编辑图片的网站 <a href = "https://pixlr.com/x/">Photo Editor:
Pixlr X - free image editing online </a></p>
<ul>
<li>将图片调整为灰阶或黑白（上面的网站也可以做到）</li>
</ul>
<ol start="6" type="1">
<li><p>修改<code>.addons/screensaver/</code>中的<code>screensaver.cfg</code>文件，写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">standby=</span><br><span class="line"></span><br><span class="line">poweroff=</span><br></pre></td></tr></table></figure>
<p>值无需设置，会自动生成，在系统更新和更换语言后该值可能不再适用，将其删除再次自动生成即可。注意最好不要用记事本编辑。</p></li>
<li><p>修改<code>.kobo</code>中的<code>affiliate.conf</code>文件，将值改为<code>kobo</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[General]</span><br><span class="line">affiliate=kobo</span><br></pre></td></tr></table></figure></li>
<li><p>掉连接线，滑动顶部开关，可以看到已经生效。</p></li>
<li><p>补充：当直接在PIN码验证界面滑动顶部开关进入休眠模式的话，会进入默认的空白模式。</p></li>
</ol>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://www.mobileread.com/forums/showthread.php?t=255238">Random Screensaver Image - MobileRead Forums</a></li>
<li><a href="https://www.howtogeek.com/219056/how-to-add-custom-screensavers-to-your-kobo-ebook-reader/">How to Add Custom Screensavers to Your Kobo Ebook Reader</a></li>
<li><a href="https://www.mobileread.com/forums/showthread.php?p=3868795">Random
Screensaver - MobileRead Forums</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python-使用Selenium模块控制浏览器</title>
    <url>/python-use-selenium-control-browser/</url>
    <content><![CDATA[<p>本文简要介绍在Python中如何使用 selenium
模块控制浏览器获取动态页面元素。包括获取信息，点击链接，下拉框选取。毕设通过本方式自动化获取数据，简要记录。更新了没保存好被吞掉的部分...</p>
<span id="more"></span>
<p>部分网页在右键使用查看源代码与检查元素时看到的内容是不相同的，上下页的切换也不会导致页面链接发生变化，这一类网页仅仅依靠获取网页源代码的方式是无法自动获取页面元素的。Python中的selenium模块可以模拟手动操作浏览器的过程，虽然该模块主要用于编写功能/验收测试，用来获取动态网页的数据也很方便。</p>
<h1 id="安装">安装</h1>
<h2 id="下载-selenium-安装包">下载 selenium 安装包</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>
<h2 id="安装-webdriver">安装 WebDriver</h2>
<p>将要模拟的浏览器的 webdrver 下载至 Python 所在的位置。</p>
<p>（注意：该驱动与浏览器版本相关，下载前请先确认自己的浏览器版本）</p>
<ul>
<li><p>Firefox: <a
href="https://github.com/mozilla/geckodriver/releases">Releases ·
mozilla/geckodriver</a></p></li>
<li><p>Chrome: <a
href="https://chromedriver.chromium.org/downloads">Downloads -
ChromeDriver - WebDriver for Chrome</a></p></li>
</ul>
<h1 id="启动浏览器">启动浏览器</h1>
<h2 id="导入模块">导入模块</h2>
<p>导入该模块通常使用以下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br></pre></td></tr></table></figure>
<h2 id="启动浏览器-1">启动浏览器</h2>
<p>对不同的浏览器，使用webdriver启动浏览器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser = webdriver.Firefox()</span><br><span class="line"><span class="comment"># browser = webdriver.Chrome()</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>get()</code> 方法访问指定链接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.get(<span class="string">&quot;YOUR_URL&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="页面元素定位">页面元素定位</h1>
<p>使用 <code>find_element_*</code> 和 <code>find_elements_*</code>
查找页面中的
WebDriver对象，前者返回第一个匹配元素，后者返回所有匹配元素，形式为列表。</p>
<p>以下是 WebDriver
方法，仅列出查找第一个匹配元素的方法名，查找所有元素的方法明只需在
<code>element</code> 后加上 <code>s</code> 即可。</p>
<table>
<colgroup>
<col style="width: 70%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="header">
<th>方法名</th>
<th>定位对象</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>find_element_by_class_name(name)</code></td>
<td>根据 <code>class</code> 名定位</td>
</tr>
<tr class="even">
<td><code>find_element_by_css_selector(selector)</code></td>
<td>根据 CSS 选择器定位</td>
</tr>
<tr class="odd">
<td><code>find_element_by_id(id)</code></td>
<td>根据元素的 <code>id</code> 属性定位</td>
</tr>
<tr class="even">
<td><code>find_element_by_link_text(text)</code></td>
<td>根据文本定位</td>
</tr>
<tr class="odd">
<td><code>find_element_by_partial_link_text(text)</code></td>
<td>根据文本的子字符串匹配</td>
</tr>
<tr class="even">
<td><code>find_element_by_name(name)</code></td>
<td>根据元素的 <code>name</code> 属性定位</td>
</tr>
<tr class="odd">
<td><code>find_element_by_tag_name(name)</code></td>
<td>根据标签名定位</td>
</tr>
<tr class="even">
<td><code>find_element_by_xpath(path)</code></td>
<td>根据 Xpath 定位</td>
</tr>
</tbody>
</table>
<p>以上所有的元素定位，若不能找到匹配元素，将抛出
<code>NoSuchElementException</code> 异常。</p>
<p>个人倾向于使用 CSS
选择器的方式进行元素定位，虽然完全不懂前端，但其实通过浏览器的检查元素可以很轻易地获取
CSS选择器的语法，同时参照 <a
href="https://www.w3school.com.cn/cssref/css_selectors.asp">CSS选择器参考手册</a>
就能很容易通过 CSS 选择器进行定位。</p>
<p>通过 浏览器快速获取 CSS 选择器语法的方式是：</p>
<ol type="1">
<li><p>打开页面右键菜单中的检查元素窗口；</p></li>
<li><p>点击左上角的选择元素工具；</p></li>
<li><p>在页面上选取需要定位的元素；</p></li>
<li><p>这时 HTML 代码的浏览窗格中将定位到所选取元素的 HTML
代码位置；</p></li>
<li><p>查看代码浏览窗格的下方，以 <code>&gt;</code>
连接的形式呈现了子代以及每一级父代的 CSS 选择器语法。</p></li>
</ol>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;el-table_1_column_2  &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>data<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定位到 data 的 CSS
选择器语法为：<code>td.el-table_1_column_2 div</code>
，上面提到的定位方法使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elem = browser.fidn_element_by_css_selector(<span class="string">&#x27;td.el-table_1_column_2 div&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>此时 <code>elem</code> 为定位到的 WebElement
对象，还不是我们想要的内容。</p>
<h1 id="获取内容">获取内容</h1>
<p>可以通过 WebElement
对象提供的属性和方法访问对象的信息，如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>属性或方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>tag_name</code></td>
<td>标签名</td>
</tr>
<tr class="even">
<td><code>get_attribute()</code></td>
<td>属性值</td>
</tr>
<tr class="odd">
<td><code>text</code></td>
<td>文本</td>
</tr>
<tr class="even">
<td><code>clear()</code></td>
<td>清除文本字段或文本区域输入的文本</td>
</tr>
<tr class="odd">
<td><code>is_displayed()</code></td>
<td>根据文本的子字符串匹配</td>
</tr>
<tr class="even">
<td><code>find_element_by_name(name)</code></td>
<td>元素是否可见</td>
</tr>
<tr class="odd">
<td><code>is_enabled()</code></td>
<td>元素是否启用</td>
</tr>
<tr class="even">
<td><code>is_selected()</code></td>
<td>选框是否选中</td>
</tr>
<tr class="odd">
<td><code>location</code></td>
<td>元素在页面上的位置</td>
</tr>
</tbody>
</table>
<p>如上文提到的 data 信息的获取可通过 text 属性提取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(elem.text)</span><br></pre></td></tr></table></figure>
<p>但对于一些隐藏的 CSS 元素，尽管页面上可以找到该元素，但无法通过
<code>text</code> 方式获取，如下面这段 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;el-table_1_column_1   is-hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>data1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接使用 text 属性，获取到的内容将为空白，需要使用
<code>get_attribute()</code> 方法，如下列代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(elem.get_attribute(<span class="string">&quot;textContent&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>具体可参考 <a
href="https://www.w3schools.com/jsref/prop_node_textcontent.asp">HTML
DOM textContent Property</a> 。</p>
<h1 id="点击页面">点击页面</h1>
<p>WebElement 中还提供了 <code>click()</code>
方法，通过该方法可模拟手动操作鼠标对页面元素进行点击，如上下页的切换等。在页面元素无法点击的情况下（如末页的下一页按钮被禁用），该方法不会执行任何操作，也不会有异常返回。以下是示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_css_selector(<span class="string">&#x27;button.searchBtr&#x27;</span>).click()</span><br></pre></td></tr></table></figure>
<h1 id="下拉框选取">下拉框选取</h1>
<p>webdriver 中提供了 select
模块用于下拉框的选取，以下是导入该模块的语句的两种方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> selecnium.webdriver.support.select <span class="keyword">import</span> Select</span><br></pre></td></tr></table></figure>
<p>使用时将查找的元素作为 <code>Select()</code>
的参数，下拉框的选取有以下三种方式：</p>
<ul>
<li><p><code>select_by_index(index)</code>
：通过索引选取，即第几个元素，索引编号从 0 开始；</p></li>
<li><p><code>select_by_value(value)</code>： 通过 <code>value</code>
属性值选取；</p></li>
<li><p><code>select_by_visible_text(text)</code>：
通过可见文本选取，即该下拉菜单中显示值。</p></li>
</ul>
<p>以下是示例 HTML代码段：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;listquerybox&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;selectTitle&quot;</span> <span class="attr">class</span>=<span class="string">&quot;selectTitle&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>所属行政区：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;area-select&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;gradeChange()&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>&gt;</span>--省--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;110000&quot;</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;120000&quot;</span>&gt;</span>天津市<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过三种不同方式选取 北京市 选项如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Select(browser.find_element_by_css_selector(<span class="string">&#x27;select#pid.area-select&#x27;</span>)).select_by_index(<span class="number">1</span>)</span><br><span class="line">Select(browser.find_element_by_css_selector(<span class="string">&#x27;select#pid.area-select&#x27;</span>)).select_by_value(<span class="string">&#x27;110000&#x27;</span>)</span><br><span class="line">Select(browser.find_element_by_css_selector(<span class="string">&#x27;select#pid.area-select&#x27;</span>)).select_by_visible_text(<span class="string">&#x27;北京市&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在下拉框中的选择值查找失败时，将抛出
<code>NoSuchElementException</code> 异常。</p>
<h1 id="关闭浏览器">关闭浏览器</h1>
<p>在信息获取完后，应使用 <code>quit()</code> 关闭浏览器，否则通过
selenium
启动的浏览器将一直处于活动运行状态。以下是包括浏览器常用的操控按钮示例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.quit() <span class="comment"># 点击 关闭浏览器 按钮</span></span><br><span class="line">browser.back() <span class="comment"># 点击 返回 按钮</span></span><br><span class="line">browser.forward() <span class="comment"># 点击 前进 按钮</span></span><br><span class="line">browser.refresh() <span class="comment"># 点击 刷新 按钮</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><p>《Python编程快速上手——让繁琐工作自动化》</p></li>
<li><p><a
href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/">selenium-python中文文档</a></p></li>
<li><p><a
href="https://stackoverflow.com/questions/61383136/how-to-read-hidden-text-in-python-by-using-selenium">html
- how to read hidden text in python by using selenium? - Stack
Overflow</a></p></li>
<li><p><a
href="https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.select.html#module-selenium.webdriver.support.select">selenium.webdriver.support.select
— Selenium 3.14 documentation</a></p></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Githug 记录</title>
    <url>/git-Githug-record/</url>
    <content><![CDATA[<p><a href="https://github.com/Gazler/githug">Githug</a>
通关记录，简要写关于涉及到的部分命令的使用。一个适用于 Git
初学者的练习游戏。</p>
<span id="more"></span>
<h1 id="写在前面">写在前面</h1>
<p>刚开始接触 Git 推荐先使用<a
href="https://learngitbranching.js.org/">Learn Git Branching</a>
可视化学习一下分支，然后可以试一下 Githug。另外还有相似的<a
href="https://gitexercises.fracz.com/">Git
Exercises</a>。虽然我自己玩这几个练习的时候因为并不清楚具体的区别，并不是按这个顺序，都玩过一遍后觉得这可能是一个比较合适的顺序。几个练习的区别是，Learning
Git Branching 可视化学习最适合初学者，有命令指引和 solution，Githug
涉及的命令比较广，不过大多比较浅，没有 solution，所以在此记录，Git
Exercises 有些关卡的场景比较复杂，难度上较 Githug
难一点，完成后每个关卡有讲解。后面两个游戏都是命令行 base，
可能会涉及一些最基本的命令行操作。目前已有许多 Git 的 GUI
客户端，并且主流编辑器大多也有 Git 插件可以实现图形化操作，不过个人使用
Git 还是更习惯使用命令行，当然在 <code>diff</code> 的时候 GUI
界面还是更方便一些 。公司使用的团队合作控制是
TFS，对于本地的版本控制几乎没有，同时改多个项目的时候很难记录变更，尤其是时间跨度比较长的时候，所以我在本地引入了
Git 作为自己的版本管理控制，也方便记录哪些已提交到团队的 TFS
上面，对于近期刚完成的半年多时长的项目，引入 Git
之后对自己开发的过程追溯就容易了许多。而最近的工作比较多涉及数据库脚本，没有版本控制就非常痛苦。</p>
<div class="note info"><p>你可以使用 Gitpod 来运行后面两个命令行的 Git 练习。</p>
</div>
<h1 id="level-1---init">Level 1 - Init</h1>
<blockquote>
<p>A new directory, <code>git_hug</code>, has been created; initialize
an empty repository in it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>初始化仓库，无论你是使用一个新的仓库，还是在已有的文件系统内建仓库，都是必不可缺的一个命令。</p>
<h1 id="level-2---config">Level 2 - Config</h1>
<blockquote>
<p>Set up your git name and email, this is important so that your
commits can be identified.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;name&quot;</span></span><br><span class="line">git config --global user.email email@example.com</span><br></pre></td></tr></table></figure>
<p>设置 Git 配置，<code>--global</code>
是一个全局配置参数，之后所有的提交都会使用此配置。</p>
<h1 id="level-3---add">Level 3 - Add</h1>
<blockquote>
<p>There is a file in your folder called <code>README</code>, you should
add it to your staging area Note: You start each level with a new repo.
Don't look for files from the previous one.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add README </span><br><span class="line"></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>添加文件至暂存区，日常中最常用的命令了，对于一次变更同时涉及多个文件时可以使用
<code>git add .</code>，利用通配符同时提交多个文件，通配符同时也作用于比如提交某个文件夹的全部文件，与
Linux 中的通配符规则是一致的。</p>
<p>原则上一次提交不应该包含多个改动，即小步提交，而暂存后的文件才进行提交，所以一次暂存通常也只包含本次提交中的内容。曾看到过一个比喻，Git
有点像是打游戏断点存档，在哪里断点存档你就可以从那里重新开始。一次提交包含多个改动，当你追溯自己的版本变更时就非常困难。</p>
<p>理解 Git 命令与各个不同区域的关系参见 <a
href="https://ndpsoftware.com/git-cheatsheet.html#loc=index;">Git
Cheatsheet</a><a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>。</p>
<h1 id="level-4---commit">Level 4 - Commit</h1>
<blockquote>
<p>The <code>README</code> file has been added to your staging area, now
commit it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m “add readme”</span><br></pre></td></tr></table></figure>
<p>提交变更，通常使用 <code>-m</code>
参数在提交时也提交对本次提交的内容的附注。如没有使用此参数，Git
将会使用唤起你的编辑器以便键入提交信息。提交信息推荐参考 <a
href="https://www.conventionalcommits.org/en/v1.0.0/">Convertional
Commits</a><a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>，以让你的提交信息更通用，更规范，也更易读。</p>
<h1 id="level-5---clone">Level 5 - Clone</h1>
<blockquote>
<p>Clone the repository at <a
href="https://github.com/Gazler/cloneme">https://github.com/Gazler/cloneme</a>.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> </span><br></pre></td></tr></table></figure>
<h1 id="level-6-clone-to-folder">Level 6 Clone to folder</h1>
<blockquote>
<p>Clone the repository at <a
href="https://github.com/Gazler/cloneme">https://github.com/Gazler/cloneme</a>
to <code>my_cloned_repo</code>.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> … my_cloned_repo</span><br></pre></td></tr></table></figure>
<h1 id="level-7-ignore">Level 7 Ignore</h1>
<blockquote>
<p>The text editor 'vim' creates files ending in <code>.swp</code> (swap
files) for all files that are currently open. We don't want them
creeping into the repository. Make this repository ignore those swap
files which are ending in <code>.swp</code>.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim .gitignore</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.swp</span><br></pre></td></tr></table></figure>
<p>配置 <code>gitignore</code>
文件，对于一些临时文件和不希望提交的文件非常有用，尤其是编辑器/IDE环境会产生大量的配置文件，这时候可能不希望追溯这些文件的变更。在
VS 中的 Git 环境会默认写一个 <code>gitignore</code> 帮助你忽视掉不必要的
VS 产生的文件。</p>
<p>两个 <code>gitignore</code> 的参考：</p>
<ul>
<li><a href="https://github.com/github/gitignore">github/gitignore: A
collection of useful .gitignore templates</a> <a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a></li>
<li><a href="https://www.toptal.com/developers/gitignore">gitignore.io -
Create Useful .gitignore Files For Your Project</a> <a href="#fn4"
class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a></li>
</ul>
<h1 id="level-8---include">Level 8 - Include</h1>
<blockquote>
<p>Notice a few files with the '.a' extension. We want git to ignore all
but the 'lib.a' file.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim .gitignore</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.a</span><br><span class="line">!lib.a</span><br></pre></td></tr></table></figure>
<h1 id="level-9---status">Level 9 - Status</h1>
<blockquote>
<p>There are some files in this repository, one of the files is
untracked, which file is it?</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<h1 id="level-10---number-of-files-commited">Level 10 - Number of files
commited</h1>
<blockquote>
<p>There are some files in this repository, how many of the files will
be committed?</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git diff --<span class="built_in">stat</span></span><br><span class="line">git diff --cached --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>status</code>
可能是最简单的方式，但文件较多时就不方便了。参考 <a
href="https://stackoverflow.com/questions/3162444/git-count-files-in-the-staged-index">git
count files in the staged index - Stack Overflow</a><a href="#fn5"
class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>。</p>
<h1 id="level-11---rm">Level 11 - Rm</h1>
<blockquote>
<p>A file has been removed from the working tree, however the file was
not removed from the repository. Find out what this file was and remove
it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m “delete”</span><br></pre></td></tr></table></figure>
<h1 id="level-12---rm-cached">Level 12 - Rm cached</h1>
<blockquote>
<p>A file has accidentally been added to your staging area, find out
which file and remove it from the staging area. <em>NOTE</em> Do not
remove the file from the file system, only from git.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>git status</code> 时会提示该命令的使用。</p>
<h1 id="level-13---stash">Level 13 - Stash</h1>
<blockquote>
<p>You've made some changes and want to work on them later. You should
save them, but don't commit them.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<h1 id="level-14---rename">Level 14 - Rename</h1>
<blockquote>
<p>We have a file called <code>oldfile.txt</code>. We want to rename it
to <code>newfile.txt</code> and stage this change.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">mv</span> oldfile.txt newfile.txt</span><br></pre></td></tr></table></figure>
<p>这和 Linux 中的重命名是一样的，其实 Git 中有很多命令与 Linux
命令相似。</p>
<h1 id="level-15---restructure">Level 15 - Restructure</h1>
<blockquote>
<p>You added some files to your repository, but now realize that your
project needs to be restructured. Make a new folder named
<code>src</code> and using Git move all of the .html files into this
folder.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> src</span><br><span class="line">git <span class="built_in">mv</span> *.html  src/ </span><br></pre></td></tr></table></figure>
<h1 id="level-16---log">Level 16 - Log</h1>
<blockquote>
<p>You will be asked for the hash of most recent commit. You will need
to investigate the logs of the repository for this.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -1</span><br></pre></td></tr></table></figure>
<h1 id="level-17---tag">Level 17 - Tag</h1>
<p>We have a git repo and we want to tag the current commit with
<code>new_tag</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag new_tag</span><br></pre></td></tr></table></figure>
<h1 id="level-18---push-tags">Level 18 - Push tags</h1>
<blockquote>
<p>There are tags in the repository that aren't pushed into remote
repository. Push them now.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push - -tags</span><br></pre></td></tr></table></figure>
<h1 id="level-19---commit-amend">Level 19 - Commit amend</h1>
<blockquote>
<p>The <code>README</code> file has been committed, but it looks like
the file <code>forgotten_file.rb</code> was missing from the commit. Add
the file and amend your previous commit to include it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit —amend —no-edit</span><br></pre></td></tr></table></figure>
<p>添加 <code>--no-edit</code> 参数不会弹出编辑窗口。</p>
<h1 id="level-20---commit-in-furture">Level 20 - Commit in furture</h1>
<blockquote>
<p>Commit your changes with the future date (e.g. tomorrow).</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m “commit msg” —<span class="built_in">date</span> “2023-08-01”</span><br></pre></td></tr></table></figure>
<h1 id="level-21---reset">Level 21 - Reset</h1>
<blockquote>
<p>There are two files to be committed. The goal was to add each file as
a separate commit, however both were added by accident. Unstage the file
<code>to_commit_second.rb</code> using the reset command (don't commit
anything).</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore --staged to_commit_second.rb</span><br></pre></td></tr></table></figure>
<h1 id="level-22---reset-soft">Level 22 - Reset soft</h1>
<blockquote>
<p>You committed too soon. Now you want to undo the last commit, while
keeping the index.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line">git reset --soft fa51390</span><br></pre></td></tr></table></figure>
<h1 id="level-23---checkout-file">Level 23 - Checkout file</h1>
<blockquote>
<p>A file has been modified, but you don't want to keep the
modification. Checkout the <code>config.rb</code> file from the last
commit.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout — config.rb</span><br></pre></td></tr></table></figure>
<h1 id="level-24---remote">Level 24 - Remote</h1>
<blockquote>
<p>This project has a remote repository. Identify it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>
<h1 id="level-25---remote-url">Level 25 - Remote url</h1>
<blockquote>
<p>The remote repositories have a url associated to them. Please enter
the url of remote_location.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<h1 id="level-26---pull">Level 26 - Pull</h1>
<blockquote>
<p>You need to pull changes from your origin repository.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<h1 id="level-27---remote-add">Level 27 - Remote add</h1>
<blockquote>
<p>Add a remote repository called <code>origin</code> with the url
https://github.com/githug/githug</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/githug/githug</span><br></pre></td></tr></table></figure>
<h1 id="level-28---push">Level 28 - Push</h1>
<blockquote>
<p>Your local master branch has diverged from the remote origin/master
branch. Rebase your commit onto origin/master and push it to remote.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase origin/master </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<h1 id="level-29---diff">Level 29 - Diff</h1>
<blockquote>
<p>There have been modifications to the <code>app.rb</code> file since
your last commit. Find out which line has changed.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git diff -U0</span><br></pre></td></tr></table></figure>
<p>Git diff 的信息并非实际行数，参考 <a
href="https://stackoverflow.com/questions/24455377/git-diff-with-line-numbers-git-log-with-line-numbers">Git
diff with line numbers (Git log with line numbers) - Stack
Overflow</a><a href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a>。</p>
<h1 id="level-30---blame">Level 30 - Blame</h1>
<blockquote>
<p>Someone has put a password inside the file <code>config.rb</code>
find out who it was.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git blame config.rb</span><br></pre></td></tr></table></figure>
<h1 id="level-31---branch">Level 31 - Branch</h1>
<blockquote>
<p>You want to work on a piece of code that has the potential to break
things, create the branch test_code.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch test_code</span><br></pre></td></tr></table></figure>
<h1 id="level-32---checkout">Level 32 - Checkout</h1>
<blockquote>
<p>Create and switch to a new branch called my_branch. You will need to
create a branch like you did in the previous level.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b my_branch</span><br></pre></td></tr></table></figure>
<h1 id="level-33---checkout-tag">Level 33 - Checkout tag</h1>
<blockquote>
<p>You need to fix a bug in the version 1.2 of your app. Checkout the
tag <code>v1.2</code>.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout v1.2</span><br></pre></td></tr></table></figure>
<h1 id="level-34---checkout-tag-over-branch">Level 34 - Checkout tag
over branch</h1>
<blockquote>
<p>You need to fix a bug in the version 1.2 of your app. Checkout the
tag <code>v1.2</code> (Note: There is also a branch named
<code>v1.2</code>).</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> —tags —online </span><br><span class="line">git checkout [commit-SHA]</span><br></pre></td></tr></table></figure>
<p>先找到这个 tag 的 SHA 值，如果你直接 checkout <code>v1.2</code>
将会变为 checkout 分支。</p>
<h1 id="level-35---branch-at">Level 35 - Branch at</h1>
<blockquote>
<p>You forgot to branch at the previous commit and made a commit on top
of it. Create branch test_branch at the commit before the last.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch test_branch HEAD~1</span><br></pre></td></tr></table></figure>
<h1 id="level-36---delete-branch">Level 36 - Delete branch</h1>
<blockquote>
<p>You have created too many branches for your project. There is an old
branch in your repo called 'delete_me', you should delete it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d delete_me</span><br></pre></td></tr></table></figure>
<h1 id="level-37---push-branch">Level 37 - Push branch</h1>
<blockquote>
<p>You've made some changes to a local branch and want to share it, but
aren't yet ready to merge it with the 'master' branch. Push only
'test_branch' to the remote repository</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin test_branch</span><br></pre></td></tr></table></figure>
<h1 id="level-38---merge">Level 38 - Merge</h1>
<blockquote>
<p>We have a file in the branch 'feature'; Let's merge it to the master
branch.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge feature</span><br></pre></td></tr></table></figure>
<h1 id="level-39---fetch">Level 39 - Fetch</h1>
<blockquote>
<p>Looks like a new branch was pushed into our remote repository. Get
the changes without merging them with the local repository</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>
<h1 id="level-40---rebase">Level 40 - Rebase</h1>
<blockquote>
<p>We are using a git rebase workflow and the feature branch is ready to
go into master. Let's rebase the feature branch onto our master
branch.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase master feature</span><br></pre></td></tr></table></figure>
<h1 id="level-41---rebase-onto">Level 41 - Rebase onto</h1>
<blockquote>
<p>You have created your branch from <code>wrong_branch</code> and
already made some commits, and you realise that you needed to create
your branch from <code>master</code>. Rebase your commits onto
<code>master</code> branch so that you don't have
<code>wrong_branch</code> commits.</p>
</blockquote>
<p>now: readme-update branch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase —onto master wrong_branch readme-update</span><br></pre></td></tr></table></figure>
<p>关于 <code>rebase</code> 的使用，参考<a
href="https://womanonrails.com/git-rebase-onto">Git rebase --onto an
overview</a><a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>。</p>
<h1 id="level-42---repack">Level 42 - Repack</h1>
<blockquote>
<p>Optimise how your repository is packaged ensuring that redundant
packs are removed.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git repack -d</span><br></pre></td></tr></table></figure>
<h1 id="level-43---pick">Level 43 - Pick</h1>
<blockquote>
<p>Your new feature isn't worth the time and you're going to delete it.
But it has one commit that fills in <code>README</code> file, and you
want this commit to be on the master as well.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git switch new-branch</span><br><span class="line">git <span class="built_in">log</span> —oneline — README.md</span><br><span class="line">git switch master</span><br><span class="line">git cherry-pick [commit-SHA]</span><br></pre></td></tr></table></figure>
<h1 id="level-44---grep">Level 44 - Grep</h1>
<blockquote>
<p>Your project's deadline approaches, you should evaluate how many
TODOs are left in your code</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git grep TODO</span><br></pre></td></tr></table></figure>
<h1 id="level-45---rename-commit">Level 45 - Rename commit</h1>
<blockquote>
<p>Correct the typo in the message of your first (non-root) commit.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br><span class="line">% change `pick` to `reword` </span><br><span class="line">% fix the message <span class="keyword">then</span> save</span><br></pre></td></tr></table></figure>
<h1 id="level-46---squash">Level 46 - Squash</h1>
<blockquote>
<p>You have committed several times but would like all those changes to
be one commit.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br><span class="line"></span><br><span class="line">% change `pick` to `squash`</span><br><span class="line">% comment other messages</span><br></pre></td></tr></table></figure>
<p>这两个关卡都涉及了
<code>git rebase -i</code>，一个相当有用的命令，可以让你做出非常多的对过去提交的变更，Git
Exercise 中有关于这个命令的更复杂的练习。</p>
<h1 id="level-47---merge-squash">Level 47 - Merge squash</h1>
<blockquote>
<p>Merge all commits from the long-feature-branch as a single
commit.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge long-feature-branch —squash</span><br><span class="line">git commit -am <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="level-48---reorder">Level 48 - Reorder</h1>
<blockquote>
<p>You have committed several times but in the wrong order. Please
reorder your commits.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 468b4ea First commit</span><br><span class="line">pick b497bf6 Third commit</span><br><span class="line">pick c4ebdaf Second commit</span><br></pre></td></tr></table></figure>
<p>与 <code>git log</code> 不同，<code>git rebase -i</code>
模式下显示的提交顺序是最近的提交在末端，最初的提交在开始。</p>
<h1 id="level-49---bisect">Level 49 - Bisect</h1>
<blockquote>
<p>A bug was introduced somewhere along the way. You know that running
<code>ruby prog.rb 5</code> should output 15. You can also run
<code>make test</code>. What are the first 7 chars of the hash of the
commit that introduced the bug.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> —online </span><br><span class="line">% get the first commit </span><br><span class="line">git bisect start</span><br><span class="line">git bisect bad</span><br><span class="line">git bisect good [SHA]</span><br><span class="line">git bisect run make <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>这个命令对于查找哪个版本引入的变更非常有用，尤其是利用测试模块测试哪个版本引入
bug。我常常在公司的项目中要查找哪个版本开始改动，对于有明确提交信息的变更还相对好找，很多提交没有写明版本变更，找历史变更是非常痛苦的事情。</p>
<h1 id="level-50---stage-lines">Level 50 - Stage lines</h1>
<blockquote>
<p>You've made changes within a single file that belong to two different
features, but neither of the changes are yet staged. Stage only the
changes belonging to the first feature.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -p </span><br><span class="line">e</span><br><span class="line">%remove second line </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+This change belongs to the first feature</span><br><span class="line">+This change belongs to the second feature</span><br></pre></td></tr></table></figure>
<p>这个命令也是一个非常丰富的命令，
可以将未暂存的一次大变更分为几个小变更，前面说到小步提交，但实际开发过程中其实很经常会习惯过去的方式一口气写完，这时候会出现这样的问题，可以通过这个命令来帮助你把一个大的变更拆解成几个小的变更。</p>
<h1 id="level-51---find-old-branch">Level 51 - Find old branch</h1>
<blockquote>
<p>You have been working on a branch but got distracted by a major issue
and forgot the name of it. Switch back to that branch.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<h1 id="level-52---revert">Level 52 - Revert</h1>
<blockquote>
<p>You have committed several times but want to undo the middle commit.
All commits have been pushed, so you can't change existing history.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> —oneline</span><br><span class="line">git revert [commit-SHA]</span><br></pre></td></tr></table></figure>
<h1 id="level-53---restore">Level 53 - Restore</h1>
<blockquote>
<p>You decided to delete your latest commit by running
<code>git reset --hard HEAD^</code>. (Not a smart thing to do.) You then
change your mind, and want that commit back. Restore the deleted
commit.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset —hard HEAD@&#123;1&#125;</span><br></pre></td></tr></table></figure>
<h1 id="level-54---conflict">Level 54 - Conflict</h1>
<blockquote>
<p>You need to merge mybranch into the current branch (master). But
there may be some incorrect changes in mybranch which may cause
conflicts. Solve any merge-conflicts you come across and finish the
merge.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge mybranch</span><br><span class="line">vim poem.txt</span><br></pre></td></tr></table></figure>
<h1 id="level-55---submodule">Level 55 - Submodule</h1>
<blockquote>
<p>You want to include the files from the following repo:
<code>https://github.com/jackmaney/githug-include-me</code> into a the
folder <code>./githug-include-me</code>. Do this without manually
cloning the repo or copying the files from the repo into this repo.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/jackmaney/githug-include-me ./githug-include-me</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://ndpsoftware.com/git-cheatsheet.html#loc=index;">Git
Cheatsheet</a><a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://www.conventionalcommits.org/en/v1.0.0/">Convertional
Commits</a><a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a
href="https://github.com/github/gitignore">github/gitignore: A
collection of useful .gitignore templates</a><a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a
href="https://www.toptal.com/developers/gitignore">gitignore.io - Create
Useful .gitignore Files For Your Project</a><a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a
href="https://stackoverflow.com/questions/3162444/git-count-files-in-the-staged-index">git
count files in the staged index - Stack Overflow</a><a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><a
href="https://stackoverflow.com/questions/24455377/git-diff-with-line-numbers-git-log-with-line-numbers">Git
diff with line numbers (Git log with line numbers) - Stack
Overflow</a><a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p><a href="https://womanonrails.com/git-rebase-onto">Git
rebase --onto an overview</a><a href="#fnref7" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-Vimtutor学习整理</title>
    <url>/vim-vimtutor/</url>
    <content><![CDATA[<p>在了解到Vim编辑器的强大的功能后，对于喜爱键盘想要摆脱鼠标的我来说是一个非常大的诱惑。而Vim自带的vimtutor无疑是一个入门的非常好的教程，该教程适合边学边用，很快就能了解最基本的Vim编辑器操作。本文将整理摘录vimtutor中的前六章内容，顺序上做了一定的归纳和调整。
8.24 更新： 补充了在<a href="https://www.openvim.com/">Interactive Vim
tutorial</a>中学到的小技巧，因为大部分内容均为基本操作，故不再另外写文整理。
<span id="more"></span> # 第一讲 基本使用</p>
<h2 id="移动光标">1.1 移动光标</h2>
<p>在正常模式（Normal)下（使用<ESC>键可以进入正常模式），使用<code>h j k l</code>键进行光标的移动，刚开始觉得这个设定极为反人类，但熟练其操作后会发现这个设定极为巧妙，能更快第在屏幕内四处移动光标。
<code>h</code>: 光标向左移动； <code>l</code>: 光标向右移动；
<code>j</code>: 光标向下移动； <code>k</code>: 光标向上移动.</p>
<p><em>小贴士</em>：在所有移动操作前加上<code>g</code>，就可以实现相对屏幕行进行操作而不是实际行，如<code>gj</code>。</p>
<h2 id="vim的进入和退出">1.2 VIM的进入和退出</h2>
<p>在 Normal 模式下， <code>:q!&lt;Enter&gt;</code> :
退出编辑器，这种方式将会丢弃所有未写入的改动。
<code>wq&lt;Enter&gt;</code>: 保存文件并退出。</p>
<h2 id="文本编辑">1.3 文本编辑</h2>
<p>在 Normal 模式下， <code>x</code>: 删除光标所在位置的字符；
<code>X</code>: 删除光标左侧位置字符； <code>.</code>:
可重复前一次操作； <code>i</code>: 在光标所在位置之前插入字符；
<code>a</code>: 在光标所在位置之后插入字符； <code>A</code>:
在光标所在行末尾插入字符。</p>
<h1 id="第二讲-删除撤销动作">第二讲 删除撤销动作</h1>
<h2 id="动作">2.1 动作</h2>
<h3 id="动作列表">动作列表</h3>
<p><code>w</code>:
从当前光标位置移动到下一个单词起始处，不包括它的第一个字符；
<code>e</code>: 从当前光标位置移动到单词末尾，包括最后一个字符；
<code>$</code>: 从当前光标位置移动到当前行末； <code>ge</code>:
从当前光标位置移动到上一个单词末尾；
<code>b</code>：从当前光标位置移动到上一个单词开头。</p>
<h3 id="计数指定动作">计数指定动作</h3>
<ol type="1">
<li>在动作前输入数字会使该动作重复多次，e.g. ：</li>
</ol>
<ul>
<li><code>2w</code> 将光标向后移动两个单词</li>
<li><code>3e</code> 使光标移向后移动到第三个单词末尾</li>
<li><code>7perfect &lt;ESC&gt;</code>将插入7个perfect单词</li>
</ul>
<ol start="2" type="1">
<li><code>0</code>：移动光标到行首</li>
</ol>
<h2 id="删除类命令">2.2 删除类命令</h2>
<p>改变文本的命令通常由一个操作符和一个动作构成： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">operator [number] motion</span><br></pre></td></tr></table></figure> -
operator 操作符 - [number] 可选操作，附加数字表示动作重复次数 - motion
动作，表示在所操作的文本上的移动 例如删除类命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d [number] motion</span><br></pre></td></tr></table></figure> - d
删除操作符 <code>dw</code>:
删除至下一个单词起始处，不包括下一个单词的第一个字符； <code>de</code>:
删除至当前单词末尾，包括最后一个字符； <code>d$</code>:
删除至当前行末尾； 删除命令也可以搭配计数删除更多。 <code>dd</code>:
删除当前行； <code>dd</code>
命令同样可以在之前插入数字进行计数删除多行。</p>
<h2 id="撤销类命令">2.3 撤销类命令</h2>
<p><code>u</code>: 撤销最后执行的命令； <code>U</code>:
撤销对整行的修改。 <code>CTRL-R</code>:
撤销以前的撤销命令，恢复之前的操作结果</p>
<h1 id="第三讲-插入替换更改">第三讲 插入替换更改</h1>
<h2 id="插入类命令">3.1 插入类命令</h2>
<p><code>p</code>: 将最后一次删除的内容插入当前光标之后,
类似于剪切功能。 <code>o</code>:
在光标当前行下方创建新的一行，并进入插入模式； <code>O</code>:
在光标当前行上方创建新的一行，并进入插入模式。</p>
<h2 id="替换类命令">3.2 替换类命令</h2>
<p><code>r[CHARACTER]</code>: 输入 r 和一个字符替换光标所在位置的字符
<code>R</code>:
连续替换多个字符，与插入模式类似，不过每个输入的字符会替代光标当前字符，与键盘使用了
insert 键进入改写模式的情况类似</p>
<h2 id="更改类命令">3.3 更改类命令</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c [number] motion</span><br></pre></td></tr></table></figure>
<ul>
<li>c 操作符</li>
</ul>
<p><code>cw</code>: 更改文本直到该单词末尾； <code>ce</code>:
更改文本直到下一单词开始； <code>c$</code>: 更改文本直到行末。
更改命令执行后直接进入 insert 模式。</p>
<h1 id="第四讲-定位查找">第四讲 定位查找</h1>
<h2 id="定位及文件状态">4.1 定位及文件状态</h2>
<p><code>F[CHAR]</code>: 光标移动到上一个 char 所指字母所在位置；
<code>f[CHAR]</code>: 光标移动到下一个 char 所指字母所在位置；
<code>*</code>: 光标移动到当前光标所指单词相同的下一个位置；
<code>#</code>: 光标移动到当前光标所指单词相同的上一个位置；
<code>CTRL-g/G</code>:
显示当前编辑文件中当前光标所在行位置以及文件状态信息； <code>G</code>:
光标跳转到文件最后一行； <code>gg</code>: 光标跳转到文件第一行；
<code>G[NUMBER]</code>: 光标跳转到number表示的行号。</p>
<h2 id="搜索类命令">4.2 搜索类命令</h2>
<p><code>/[STRING]</code>: 正向查找string表示的字符串;
<code>?[STRING]</code>: 逆向查找string表示的字符串； <code>CTRL-O</code>
 <code>N</code>：回到前一个位置； <code>CTRL-I</code>  <code>n</code>:
到下一个位置。</p>
<h2 id="配对括号的查找">4.3 配对括号的查找</h2>
<p>使用<code>%</code>可查找匹配对的括号<code>) \ ] \ &#125;</code>：
将光标移动到左括号处，按下<code>%</code>，光标将跳转到匹配的右括号处，再按下一次可跳回原来的左括号处。
（这对程序员来说真是个福音~）</p>
<h2 id="替换命令">4.4 替换命令</h2>
<p><code>:s/old/new</code>: 在光标所在行第一次出现的 old
表示的字符串替换为新的字符串 new ; <code>:s/old/new/g</code>:
在光标所在行替换所有出现的 old 所表示的字符串替换为新的字符串 new ；
<code>:#,#s/old/new/g</code>: 在两行内替换所有的字符串 old 为新的字符串
new ； <code>:%s/old/new/g</code>: 在文件内替换所有的字符串 old
为新的字符串 new ； <code>:%s/old/new/gc</code>:
进行全文替换时询问用户确认每个替换。</p>
<h1 id="第五讲-文件操作">第五讲 文件操作</h1>
<h2 id="在vim内部执行外部命令">5.1 在VIM内部执行外部命令</h2>
<p><code>:![COMMAND]</code>: 执行command所代表的外部命令</p>
<h2 id="保存文件">5.2 保存文件</h2>
<p><code>:w FILENAME</code>: 将对文件的改动保存到一个文件中;
<code>v motion: w FILENAME</code>: 将文件的部分内容保存到文件中： v
进入可视模式（Visual), motion
表示光标的移动，可选中文本，按下：后下方将出现<code>'&lt;,'&gt;</code>，输入w
FILENAME将选中的文本保存在文件FILENAME中。可视选中后同样也可以进行批量删除操作。</p>
<h2 id="提取合并文件">5.3 提取合并文件</h2>
<p><code>:r FILENAME</code>: 提取磁盘文件 FILENAME
并将其插入到当前文件光标当前位置后； <code>:r !command</code>:
读取command命令的输出插入到当前文件光标当前位置后。</p>
<h2 id="复制粘贴文本">5.4 复制粘贴文本</h2>
<p>进入 Visual 模式，
使用<code>y</code>进行复制，使用<code>p</code>进行粘贴</p>
<p>文本编辑部分整理至此。</p>
<p>顺便推荐几个网站： * <a href="https://vim-adventures.com/ ">VIM
Adventures</a>，这是一个用VIM操作来进行的游戏，不过免费版只能练习最基本的移动操作~
* <a href="https://www.openvim.com/">Interative Vim
tutorial</a>,这是一个交互的类似于 vimtutor 的教程网站 *
<a href="https://www.openvim.com/sandbox.html">Interative Vim tutorial -
sandbox</a>这是上面那个教程网站给出的一个练习，右侧还有命令提示，可以说非常贴心了
* <a href="http://www.vimsnake.com/">Vim Snake</a>
一个基于Vim移动操作的贪吃蛇游戏</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>vimtutor</li>
<li><a href="https://www.openvim.com/">Interative Vim tutorial</a></li>
<li>《Vim 实用技巧（第2版）》</li>
</ul>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
</search>
